"""Python script to load and plot the reports generated by the measure_variant script.

The two reports, namely 'latest_report.csv' and 'reference_report.csv', contain a single
column with the relative error of respectively the latest and reference variants.

"""

from glob import glob
import os
from typing import Optional
from dataclasses import dataclass
from tqdm.auto import tqdm
import numpy as np
import compress_json
import matplotlib.pyplot as plt


def get_color_by_model_name(name: str) -> str:
    """Return the color associated with the model name."""
    if name.startswith("HLL<"):
        return "tab:blue"

    if name.startswith("CF"):
        return "tab:green"

    if name.startswith("TabacPP"):
        return "tab:red"

    if name.startswith("Tabac"):
        return "tab:purple"

    if name.startswith("SA"):
        return "tab:brown"

    if name.startswith("FrankPP"):
        return "tab:pink"

    if name.startswith("SM"):
        return "tab:gray"

    if name.startswith("SM"):
        return "tab:cyan"

    if name.startswith("H3B"):
        return "tab:olive"

    if name.startswith("H2B"):
        return "#7A9F22"

    if "Simple" in name:
        return "tab:orange"

    raise ValueError(f"Unknown model name: {name}")


@dataclass
class Report:
    """Dataclass to store the data of a report."""

    exact_cardinalities: np.ndarray
    estimated_cardinalities: np.ndarray
    absolute_relative_errors: np.ndarray
    memory_requirements: np.array
    time_requirements: np.array
    precision: Optional[int]
    bits: Optional[int]
    name: str
    color: str

    @property
    def subtractions(self) -> np.ndarray:
        """Return the subtraction of the exact and estimated cardinality."""
        return self.exact_cardinalities - self.estimated_cardinalities

    @staticmethod
    def from_path(path: str) -> "Report":
        """Load a report from a given path."""
        data = compress_json.load(path)
        measurements = data["measures"]

        measurements = sorted(
            measurements, key=lambda row: row["cardinality_sample"]["exact_cardinality_mean"]
        )

        exact_cardinalities_iterator = (
            row["cardinality_sample"]["exact_cardinality_mean"] for row in measurements
        )
        estimated_cardinalities_iterator = (
            row["cardinality_sample"]["estimated_cardinality_mean"]
            for row in measurements
        )
        absolute_relative_errors_iterator = (
            row["cardinality_sample"]["absolute_relative_error_mean"]
            for row in measurements
        )
        memory_requirements_iterator = (
            row["memory_requirements_mean"] for row in measurements
        )
        time_requirements_iterator = (
            row["time_requirements_mean"] for row in measurements
        )

        exact_cardinalities = np.fromiter(
            exact_cardinalities_iterator, dtype=np.float64
        )
        estimated_cardinalities = np.fromiter(
            estimated_cardinalities_iterator, dtype=np.float64
        )
        absolute_relative_errors = np.fromiter(
            absolute_relative_errors_iterator, dtype=np.float64
        )
        memory_requirements = np.fromiter(
            memory_requirements_iterator, dtype=np.float64
        )
        time_requirements = np.fromiter(time_requirements_iterator, dtype=np.float64)

        name = path.split(os.sep)[-1].split(".json")[0]

        return Report(
            exact_cardinalities=exact_cardinalities,
            estimated_cardinalities=estimated_cardinalities,
            absolute_relative_errors=absolute_relative_errors,
            memory_requirements=memory_requirements,
            time_requirements=time_requirements,
            precision=data["precision"],
            bits=data["bits"],
            name=name,
            color=get_color_by_model_name(name),
        )


def hyperloglog_error(p: int) -> float:
    """Returns the expected error of the HyperLogLog algorithm for a given precision."""
    return 1.04 / (p**0.5)


def plot_all():
    """Load the reports and plot the histograms, boxplots and relative error plots."""
    # Load the reports
    fig, axs = plt.subplots(2, 2, figsize=(15, 15), sharex=False, sharey=False)

    plotted_precisions = []

    for path in tqdm(
        glob("*.json"),
        desc="Loading reports",
        unit="report",
        leave=False,
        dynamic_ncols=True,
    ):
        report = Report.from_path(path)

        if report.precision is not None:
            if report.precision != 9:
                continue

        # We plot several rectangles to illustrate the areas that are not covered by the reports.
        axs[0][0].plot(
            report.exact_cardinalities,
            report.absolute_relative_errors,
            label=report.name,
            color=report.color,
        )

        # We plot several rectangles to illustrate the areas that are not covered by the reports.

        axs[1][0].plot(
            report.exact_cardinalities,
            report.subtractions,
            label=report.name,
            color=report.color,
        )

        axs[0][1].plot(
            report.exact_cardinalities,
            report.memory_requirements,
            label=report.name,
            color=report.color,
        )

        axs[1][1].plot(
            report.exact_cardinalities,
            report.time_requirements,
            label=report.name,
            color=report.color,
        )

        if report.precision is not None and report.precision not in plotted_precisions:
            for ax in axs.flatten():
                ax.axvline(
                    5 * 2**report.precision,
                    linestyle="--",
                    color=report.color,
                    label=f"5 * 2**{report.precision}",
                )
                ax.axvline(
                    7.5 * 2**report.precision,
                    linestyle="--",
                    color=report.color,
                    label=f"7.5 * 2**{report.precision}",
                )
                plotted_precisions.append(report.precision)

    axs[0][0].set_title("Relative error")
    axs[0][0].set_yscale("log")
    axs[1][0].set_title("Subtraction Exact - Estimate")
    axs[1][0].set_yscale("symlog")
    axs[0][1].set_title("Memory requirements (log, bytes)")
    axs[0][1].set_yscale("symlog")
    axs[1][1].set_title("Time requirements (log, ns)")
    axs[1][1].set_yscale("symlog")

    axs[0][0].set_ylabel("Relative error")
    axs[1][0].set_ylabel("Subtraction Exact - Estimate")
    axs[0][1].set_ylabel("Memory requirements (bytes)")
    axs[1][1].set_ylabel("Time requirements (log, ns)")

    for ax in axs.flatten():
        ax.set_xlabel("Exact cardinality (log scale)")
        ax.set_xscale("symlog")
        ax.grid(which="both", linestyle="--", alpha=0.5)
        ax.legend()

    fig.tight_layout()
    fig.savefig("comparison.png")


if __name__ == "__main__":
    plot_all()
