#![feature(prelude_import)]
/*!# ðŸ§® HyperLogLog-rs
[![downloads](https://img.shields.io/crates/d/hyperloglog-rs)](https://crates.io/crates/hyperloglog-rs)
[![dependents](https://img.shields.io/librariesio/dependents/cargo/hyperloglog-rs)](https://crates.io/crates/hyperloglog-rs/reverse_dependencies)
[![CI](https://github.com/LucaCappelletti94/hyperloglog-rs/actions/workflows/rust.yml/badge.svg)](https://github.com/LucaCappelletti94/hyperloglog-rs/actions)
![license](https://img.shields.io/crates/l/hyperloglog-rs)
[![Latest version](https://img.shields.io/crates/v/hyperloglog-rs.svg)](https://crates.io/crates/hyperloglog-rs)
[![Documentation](https://docs.rs/hyperloglog-rs/badge.svg)](https://docs.rs/hyperloglog-rs)

This is a Rust library that provides an implementation of the `HyperLogLog` (HLL) algorithm, trying to be parsimonious with memory.
It also provides an implementation based on the MLE algorithm, which is a more accurate version of the `HyperLogLog` algorithm but is slower.

You can use it to estimate the cardinality of large sets, and determine also the union and intersection of two sets.

## Usage

Add this to your `Cargo.toml`:

```toml
[dependencies]
hyperloglog = "0.1"
```

## Examples

```rust
use hyperloglog_rs::prelude::*;

let mut hll = PlusPlus::<Precision6, Bits5, <Precision6 as ArrayRegister<Bits5>>::ArrayRegister, twox_hash::XxHash>::default();
hll.insert(&1);
hll.insert(&2);

let mut hll2 = PlusPlus::<Precision6, Bits5, <Precision6 as ArrayRegister<Bits5>>::ArrayRegister, twox_hash::XxHash>::default();
hll2.insert(&2);
hll2.insert(&3);

let union = hll | hll2;

let estimated_cardinality: f64 = union.estimate_cardinality();
assert!(
estimated_cardinality >= 3.0_f64 * 0.9 &&
estimated_cardinality <= 3.0_f64 * 1.1,
"Expected cardinality to be around 3, got {}",
estimated_cardinality
);

let intersection_cardinality: f64 = hll.estimate_intersection_cardinality(&hll2);

assert!(
        intersection_cardinality >= 1.0_f64 * 0.9 &&
        intersection_cardinality <= 1.0_f64 * 1.1,
        "Expected intersection cardinality to be around 1, got {}",
        intersection_cardinality
);
```

### Using MLE estimation
The [MLE estimation for HyperLogLog counters by Otmar Ertl](https://oertl.github.io/hyperloglog-sketch-estimation-paper/paper/paper.pdf) provides a more accurate estimation of the cardinality of a set, but it is slower than the standard `HyperLogLog` algorithm. Here is an example of how to use it:

```rust
#[cfg(feature = "mle")]
{
        use hyperloglog_rs::prelude::*;

        let mut hll1: MLE<PlusPlus::<Precision6, Bits5, <Precision6 as ArrayRegister<Bits5>>::ArrayRegister, twox_hash::XxHash>> = MLE::default();

        hll1.insert(&1);
        hll1.insert(&2);
        hll1.insert(&3);

        let mut hll2: MLE<PlusPlus::<Precision6, Bits5, <Precision6 as ArrayRegister<Bits5>>::ArrayRegister, twox_hash::XxHash>> = MLE::default();

        hll2.insert(&2);
        hll2.insert(&3);
        hll2.insert(&4);

        let estimated_cardinality: f64 = hll1.estimate_cardinality();
        assert!(
                estimated_cardinality >= 3.0_f64 * 0.9 &&
                estimated_cardinality <= 3.0_f64 * 1.1,
                "MLE: Expected cardinality to be around 3, got {}",
                estimated_cardinality
        );

        let estimate_intersection_cardinality: f64 = hll1.estimate_intersection_cardinality(&hll2);

        assert!(
                estimate_intersection_cardinality >= 2.0_f64 * 0.9 &&
                estimate_intersection_cardinality <= 2.0_f64 * 1.1,
                "MLE: Expected intersection cardinality to be around 2, got {}",
                estimate_intersection_cardinality
        );
}
```

## No STD
This crate is designed to be as lightweight as possible and does not require any dependencies from the Rust standard library (std). As a result, it can be used in a bare metal or embedded context, where std may not be available. The only feature that requires std is the MLE estimation, which is optional.

## Fuzzing
Fuzzing is a technique for finding security vulnerabilities and bugs in software by providing random input to the code. We make sure that our fuzz targets are continuously updated and run against the latest versions of the library to ensure that any vulnerabilities or bugs are quickly identified and addressed.

[Learn more about how we fuzz here](https://github.com/LucaCappelletti94/hyperloglog-rs/tree/main/fuzz)

## Citations
Some relevant citations to learn more:

* Philippe Flajolet, Eric Fusy, Olivier Gandouet, FrÃ©dÃ©ric Meunier. "[HyperLogLog: the analysis of a near-optimal cardinality estimation algorithm.](https://hal.science/file/index/docid/406166/filename/FlFuGaMe07.pdf)" In Proceedings of the 2007 conference on analysis of algorithms, pp. 127-146. 2007.
*/
#![deny(missing_docs)]
#![deny(unsafe_code)]
#![warn(clippy::all)]
#![warn(clippy::pedantic)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
mod basicloglog {
    //! Implementation of the basic struct for [`HyperLogLog`] counter.
    use crate::prelude::*;
    use crate::utils::{HasherType, Number, One, PositiveInteger, Words, Zero};
    use core::fmt::Debug;
    use core::fmt::Formatter;
    use core::hash::Hash;
    use core::iter::{FromIterator, Take};
    use core::marker::PhantomData;
    use core::ops::{BitOr, BitOrAssign};
    /// A basic counter data structure for HyperLogLog-like counters.
    pub(crate) struct BasicLogLog<
        P: Precision,
        B: Bits,
        R: Registers<P, B>,
        Hasher: HasherType,
    > {
        /// The registers of the counter.
        registers: R,
        /// The number of registers with zero values.
        number_of_zero_registers: P::NumberOfRegisters,
        /// The harmonic sum of the registers, i.e. the sum of 2^(-register_value) for all registers.
        harmonic_sum: f64,
        /// Phantom data to ensure the type parameters are used.
        _phantom: PhantomData<(P, B, Hasher)>,
    }
    #[automatically_derived]
    impl<
        P: Precision,
        B: Bits,
        R: Registers<P, B>,
        Hasher: HasherType,
    > mem_dbg::MemDbgImpl for BasicLogLog<P, B, R, Hasher>
    where
        R: mem_dbg::MemDbgImpl,
        P::NumberOfRegisters: mem_dbg::MemDbgImpl,
        f64: mem_dbg::MemDbgImpl,
        PhantomData<(P, B, Hasher)>: mem_dbg::MemDbgImpl,
    {
        #[inline(always)]
        fn _mem_dbg_rec_on(
            &self,
            _memdbg_writer: &mut impl core::fmt::Write,
            _memdbg_total_size: usize,
            _memdbg_max_depth: usize,
            _memdbg_prefix: &mut String,
            _memdbg_is_last: bool,
            _memdbg_flags: mem_dbg::DbgFlags,
        ) -> core::fmt::Result {
            let mut id_sizes: Vec<(usize, usize)> = ::alloc::vec::Vec::new();
            id_sizes
                .push((
                    0usize,
                    { builtin # offset_of(BasicLogLog < P, B, R, Hasher >, registers) },
                ));
            id_sizes
                .push((
                    1usize,
                    {
                        builtin # offset_of(
                            BasicLogLog < P, B, R, Hasher >, number_of_zero_registers
                        )
                    },
                ));
            id_sizes
                .push((
                    2usize,
                    {
                        builtin # offset_of(
                            BasicLogLog < P, B, R, Hasher >, harmonic_sum
                        )
                    },
                ));
            id_sizes
                .push((
                    3usize,
                    { builtin # offset_of(BasicLogLog < P, B, R, Hasher >, _phantom) },
                ));
            let n = id_sizes.len();
            id_sizes.push((n, core::mem::size_of::<Self>()));
            id_sizes.sort_by_key(|x| x.1);
            for i in 0..n {
                id_sizes[i].1 = id_sizes[i + 1].1 - id_sizes[i].1;
            }
            if !_memdbg_flags.contains(mem_dbg::DbgFlags::RUST_LAYOUT) {
                id_sizes.sort_by_key(|x| x.0);
            }
            for (i, (field_idx, padded_size)) in id_sizes.into_iter().enumerate().take(n)
            {
                match field_idx {
                    0usize => {
                        <R as mem_dbg::MemDbgImpl>::_mem_dbg_depth_on(
                            &self.registers,
                            _memdbg_writer,
                            _memdbg_total_size,
                            _memdbg_max_depth,
                            _memdbg_prefix,
                            Some("registers"),
                            i == n - 1,
                            padded_size,
                            _memdbg_flags,
                        )?
                    }
                    1usize => {
                        <P::NumberOfRegisters as mem_dbg::MemDbgImpl>::_mem_dbg_depth_on(
                            &self.number_of_zero_registers,
                            _memdbg_writer,
                            _memdbg_total_size,
                            _memdbg_max_depth,
                            _memdbg_prefix,
                            Some("number_of_zero_registers"),
                            i == n - 1,
                            padded_size,
                            _memdbg_flags,
                        )?
                    }
                    2usize => {
                        <f64 as mem_dbg::MemDbgImpl>::_mem_dbg_depth_on(
                            &self.harmonic_sum,
                            _memdbg_writer,
                            _memdbg_total_size,
                            _memdbg_max_depth,
                            _memdbg_prefix,
                            Some("harmonic_sum"),
                            i == n - 1,
                            padded_size,
                            _memdbg_flags,
                        )?
                    }
                    3usize => {
                        <PhantomData<
                            (P, B, Hasher),
                        > as mem_dbg::MemDbgImpl>::_mem_dbg_depth_on(
                            &self._phantom,
                            _memdbg_writer,
                            _memdbg_total_size,
                            _memdbg_max_depth,
                            _memdbg_prefix,
                            Some("_phantom"),
                            i == n - 1,
                            padded_size,
                            _memdbg_flags,
                        )?
                    }
                    _ => {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                }
            }
            Ok(())
        }
    }
    #[automatically_derived]
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> mem_dbg::CopyType
    for BasicLogLog<P, B, R, Hasher>
    where
        R: mem_dbg::MemSize,
        P::NumberOfRegisters: mem_dbg::MemSize,
        f64: mem_dbg::MemSize,
        PhantomData<(P, B, Hasher)>: mem_dbg::MemSize,
    {
        type Copy = mem_dbg::False;
    }
    #[automatically_derived]
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> mem_dbg::MemSize
    for BasicLogLog<P, B, R, Hasher>
    where
        R: mem_dbg::MemSize,
        P::NumberOfRegisters: mem_dbg::MemSize,
        f64: mem_dbg::MemSize,
        PhantomData<(P, B, Hasher)>: mem_dbg::MemSize,
    {
        fn mem_size(&self, _memsize_flags: mem_dbg::SizeFlags) -> usize {
            let mut bytes = core::mem::size_of::<Self>();
            bytes
                += <R as mem_dbg::MemSize>::mem_size(&self.registers, _memsize_flags)
                    - core::mem::size_of::<R>();
            bytes
                += <P::NumberOfRegisters as mem_dbg::MemSize>::mem_size(
                    &self.number_of_zero_registers,
                    _memsize_flags,
                ) - core::mem::size_of::<P::NumberOfRegisters>();
            bytes
                += <f64 as mem_dbg::MemSize>::mem_size(
                    &self.harmonic_sum,
                    _memsize_flags,
                ) - core::mem::size_of::<f64>();
            bytes
                += <PhantomData<
                    (P, B, Hasher),
                > as mem_dbg::MemSize>::mem_size(&self._phantom, _memsize_flags)
                    - core::mem::size_of::<PhantomData<(P, B, Hasher)>>();
            bytes
        }
    }
    #[automatically_derived]
    impl<
        P: ::core::clone::Clone + Precision,
        B: ::core::clone::Clone + Bits,
        R: ::core::clone::Clone + Registers<P, B>,
        Hasher: ::core::clone::Clone + HasherType,
    > ::core::clone::Clone for BasicLogLog<P, B, R, Hasher>
    where
        P::NumberOfRegisters: ::core::clone::Clone,
    {
        #[inline]
        fn clone(&self) -> BasicLogLog<P, B, R, Hasher> {
            BasicLogLog {
                registers: ::core::clone::Clone::clone(&self.registers),
                number_of_zero_registers: ::core::clone::Clone::clone(
                    &self.number_of_zero_registers,
                ),
                harmonic_sum: ::core::clone::Clone::clone(&self.harmonic_sum),
                _phantom: ::core::clone::Clone::clone(&self._phantom),
            }
        }
    }
    #[automatically_derived]
    impl<
        P: ::core::marker::Copy + Precision,
        B: ::core::marker::Copy + Bits,
        R: ::core::marker::Copy + Registers<P, B>,
        Hasher: ::core::marker::Copy + HasherType,
    > ::core::marker::Copy for BasicLogLog<P, B, R, Hasher>
    where
        P::NumberOfRegisters: ::core::marker::Copy,
    {}
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> Debug
    for BasicLogLog<P, B, R, Hasher> {
        fn fmt(&self, formatter: &mut Formatter<'_>) -> core::fmt::Result {
            formatter
                .debug_struct("BasicLogLog")
                .field("registers", &self.registers)
                .field("number_of_zero_registers", &self.number_of_zero_registers)
                .field("harmonic_sum", &self.harmonic_sum)
                .finish()
        }
    }
    /// Implementation of partial equality for [`HyperLogLog`] so as to compare two [`HyperLogLog`] instances
    /// ignoring the harmonic sum.
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> PartialEq
    for BasicLogLog<P, B, R, Hasher> {
        fn eq(&self, other: &Self) -> bool {
            self.registers == other.registers
        }
    }
    /// Implementation of equality for [`HyperLogLog`] so as to compare two [`HyperLogLog`] instances
    /// ignoring the harmonic sum.
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> Eq
    for BasicLogLog<P, B, R, Hasher> {}
    impl<
        P: Precision,
        B: Bits,
        R: Registers<P, B>,
        Hasher: HasherType,
    > BasicLogLog<P, B, R, Hasher> {
        /// Create a new [`HyperLogLog`] counter.
        fn new() -> Self {
            Self {
                registers: R::zeroed(),
                number_of_zero_registers: P::NUMBER_OF_REGISTERS,
                harmonic_sum: f64::integer_exp2(P::EXPONENT),
                _phantom: PhantomData,
            }
        }
        /// Computes the hash of a value and splits it into a register value and an index.
        fn compute_hash<T: Hash>(value: T) -> u64 {
            let mut hasher = Hasher::default();
            value.hash(&mut hasher);
            hasher.finish()
        }
        /// Splits a hash into a register value and an index.
        fn insert_register_value_and_index(
            &mut self,
            new_register_value: u8,
            index: P::NumberOfRegisters,
        ) -> bool {
            if true {
                if !(new_register_value < 1 << B::NUMBER_OF_BITS) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!("Register value is too large."),
                        );
                    }
                }
            }
            let (old_register_value, larger_register_value) = self
                .registers
                .set_greater(index, new_register_value);
            self.number_of_zero_registers
                -= P::NumberOfRegisters::from_bool(old_register_value == 0);
            self.harmonic_sum
                += f64::integer_exp2_minus(larger_register_value)
                    - f64::integer_exp2_minus(old_register_value);
            old_register_value != new_register_value
        }
    }
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> Default
    for BasicLogLog<P, B, R, Hasher> {
        /// Returns a new [`HyperLogLog`] instance with default configuration settings.
        fn default() -> Self {
            Self::new()
        }
    }
    impl<
        P: Precision,
        B: Bits,
        R: Registers<P, B>,
        Hasher: HasherType,
    > HyperLogLog<P, B, Hasher> for BasicLogLog<P, B, R, Hasher> {
        type Registers = R;
        /// Returns the number of registers with zero values.
        fn get_number_of_zero_registers(&self) -> P::NumberOfRegisters {
            self.number_of_zero_registers
        }
        /// Returns a reference to the registers of the [`HyperLogLog`] counter.
        fn registers(&self) -> &Self::Registers {
            &self.registers
        }
        /// Returns the harmonic sum of the registers.
        fn harmonic_sum(&self) -> f64 {
            self.harmonic_sum
        }
        fn get_register(&self, index: P::NumberOfRegisters) -> u8 {
            self.registers.get_register(index)
        }
        fn from_registers(registers: R) -> Self {
            let mut number_of_zero_registers = P::NumberOfRegisters::ZERO;
            let mut harmonic_sum = f64::ZERO;
            for register in registers.iter_registers() {
                number_of_zero_registers
                    += P::NumberOfRegisters::from_bool(register == 0);
                harmonic_sum += f64::integer_exp2_minus(register);
            }
            Self {
                registers,
                number_of_zero_registers,
                harmonic_sum,
                _phantom: PhantomData,
            }
        }
    }
    impl<
        P: Precision,
        B: Bits,
        R: Registers<P, B>,
        A: Hash,
        Hasher: HasherType,
    > FromIterator<A> for BasicLogLog<P, B, R, Hasher> {
        fn from_iter<T: IntoIterator<Item = A>>(iter: T) -> Self {
            let mut hll = Self::new();
            hll.extend(iter);
            hll
        }
    }
    impl<
        P: Precision,
        B: Bits,
        R: Registers<P, B>,
        Hasher: HasherType,
        Rhs: HyperLogLog<P, B, Hasher>,
    > BitOrAssign<Rhs> for BasicLogLog<P, B, R, Hasher> {
        fn bitor_assign(&mut self, rhs: Rhs) {
            let mut rhs_registers = rhs.registers().iter_registers();
            self.registers
                .apply(|old_register| {
                    let rhs_register: u8 = rhs_registers.next().unwrap();
                    if rhs_register > old_register {
                        self.harmonic_sum
                            += f64::integer_exp2_minus(rhs_register)
                                - f64::integer_exp2_minus(old_register);
                        self.number_of_zero_registers
                            -= P::NumberOfRegisters::from_bool(old_register == 0);
                        rhs_register
                    } else {
                        old_register
                    }
                });
        }
    }
    impl<
        P: Precision,
        B: Bits,
        R: Registers<P, B>,
        Rhs: HyperLogLog<P, B, Hasher>,
        Hasher: HasherType,
    > BitOr<Rhs> for BasicLogLog<P, B, R, Hasher> {
        type Output = Self;
        fn bitor(mut self, rhs: Rhs) -> Self {
            self.bitor_assign(rhs);
            self
        }
    }
    impl<
        P: Precision,
        B: Bits,
        R: Registers<P, B> + Words,
        Hasher: HasherType,
    > Hybridazable for BasicLogLog<P, B, R, Hasher> {
        type IterSortedHashes<'words> = Take<R::WordIter<'words>> where Self: 'words;
        fn is_hybrid(&self) -> bool {
            self.harmonic_sum < f64::ZERO
        }
        fn new_hybrid() -> Self {
            let mut default: Self = BasicLogLog::default();
            default.clear_words();
            default
        }
        fn dehybridize(&mut self) {
            if self.is_hybrid() {
                let number_of_hashes = self.number_of_hashes();
                self.number_of_zero_registers = P::NUMBER_OF_REGISTERS;
                self.harmonic_sum = f64::integer_exp2(P::EXPONENT);
                let registers = self.registers.clone();
                self.registers = R::zeroed();
                for hash in registers.words().take(number_of_hashes) {
                    let (register_value, index) = Self::split_hash(hash);
                    self.insert_register_value_and_index(register_value, index);
                }
            }
        }
        fn number_of_hashes(&self) -> usize {
            self.get_number_of_zero_registers().to_usize()
        }
        fn capacity(&self) -> usize {
            self.registers.number_of_words()
        }
        fn clear_words(&mut self) {
            self.registers.clear();
            self.number_of_zero_registers = P::NumberOfRegisters::ZERO;
            self.harmonic_sum = f64::NEG_INFINITY;
        }
        fn iter_sorted_hashes(&self) -> Self::IterSortedHashes<'_> {
            self.registers.words().take(self.number_of_hashes())
        }
        fn contains<T: Hash>(&self, element: &T) -> bool {
            if true {
                if !(self.number_of_hashes() <= self.registers.number_of_words()) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "Number of hashes ({0}) is greater than the number of words ({1}) in the list of hashes.",
                                self.number_of_hashes(),
                                self.registers.number_of_words(),
                            ),
                        );
                    }
                }
            }
            self.registers
                .find_sorted_with_len(
                    Self::compute_hash(element),
                    self.number_of_hashes(),
                )
        }
        fn hybrid_insert<T: Hash>(&mut self, value: &T) -> bool {
            if self.is_hybrid() {
                if self.capacity() == self.number_of_hashes() {
                    if true {
                        match (
                            &self.number_of_hashes(),
                            &self.registers.number_of_words(),
                        ) {
                            (left_val, right_val) => {
                                if !(*left_val == *right_val) {
                                    let kind = ::core::panicking::AssertKind::Eq;
                                    ::core::panicking::assert_failed(
                                        kind,
                                        &*left_val,
                                        &*right_val,
                                        ::core::option::Option::Some(
                                            format_args!(
                                                "Number of hashes ({0}) is not equal to the number of words ({1}) in the list of hashes.",
                                                self.number_of_hashes(),
                                                self.registers.number_of_words(),
                                            ),
                                        ),
                                    );
                                }
                            }
                        };
                    }
                    self.dehybridize();
                    self.insert(value)
                } else {
                    let hash = Self::compute_hash(value);
                    if self
                        .registers
                        .sorted_insert_with_len(hash, self.number_of_hashes())
                    {
                        if true {
                            if !(self.number_of_zero_registers <= P::NUMBER_OF_REGISTERS)
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Number of zero registers ({0}) is greater than the number of registers ({1})",
                                            self.number_of_zero_registers,
                                            P::NUMBER_OF_REGISTERS,
                                        ),
                                    );
                                }
                            }
                        }
                        self.number_of_zero_registers += P::NumberOfRegisters::ONE;
                        true
                    } else {
                        false
                    }
                }
            } else {
                self.insert(value)
            }
        }
    }
    impl<P: Precision, B: Bits, Hasher: HasherType, R: Registers<P, B>> SetProperties
    for BasicLogLog<P, B, R, Hasher> {
        fn is_empty(&self) -> bool {
            self.number_of_zero_registers == P::NUMBER_OF_REGISTERS
        }
        fn is_full(&self) -> bool {
            self.harmonic_sum
                <= f64::integer_exp2_minus_signed(
                    i8::try_from(maximal_multeplicity(P::EXPONENT, B::NUMBER_OF_BITS))
                        .unwrap() - i8::try_from(P::EXPONENT).unwrap() - 1,
                )
        }
    }
    impl<
        P: Precision,
        B: Bits,
        Hasher: HasherType,
        R: Registers<P, B>,
        T: Hash,
    > ApproximatedSet<T> for BasicLogLog<P, B, R, Hasher> {
        fn may_contain(&self, element: &T) -> bool {
            self.get_register(Self::hash_and_index::<T>(element).1) > 0
        }
    }
    impl<P: Precision, B: Bits, Hasher: HasherType, R: Registers<P, B>> MutableSet
    for BasicLogLog<P, B, R, Hasher> {
        fn clear(&mut self) {
            self.registers.clear();
            self.number_of_zero_registers = P::NUMBER_OF_REGISTERS;
            self.harmonic_sum = f64::integer_exp2(P::EXPONENT);
        }
    }
    impl<
        P: Precision,
        B: Bits,
        Hasher: HasherType,
        R: Registers<P, B>,
        T: Hash,
    > ExtendableApproximatedSet<T> for BasicLogLog<P, B, R, Hasher> {
        fn insert(&mut self, element: &T) -> bool {
            let (new_register_value, index) = Self::hash_and_index::<T>(element);
            self.insert_register_value_and_index(new_register_value, index)
        }
    }
}
mod bits {
    //! Submodule providing the trait marker Bits.
    use core::fmt::Debug;
    #[cfg(feature = "std")]
    use crate::utils::Named;
    /// Trait marker for the number of bits.
    pub trait Bits: Default + Copy + PartialEq + Eq + Send + Sync + Debug {
        /// The number of bits.
        const NUMBER_OF_BITS: u8;
    }
    #[non_exhaustive]
    /// A struct representing the number of bits.
    pub struct Bits1;
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Bits1 {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_unit_struct(__serializer, "Bits1")
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Bits1 {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Bits1>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Bits1;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "unit struct Bits1",
                        )
                    }
                    #[inline]
                    fn visit_unit<__E>(
                        self,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(Bits1)
                    }
                }
                _serde::Deserializer::deserialize_unit_struct(
                    __deserializer,
                    "Bits1",
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Bits1>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for Bits1 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Bits1")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Bits1 {
        #[inline]
        fn default() -> Bits1 {
            Bits1 {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Bits1 {
        #[inline]
        fn clone(&self) -> Bits1 {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Bits1 {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Bits1 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Bits1 {
        #[inline]
        fn eq(&self, other: &Bits1) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Bits1 {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Bits1 {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Bits1,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Bits1 {
        #[inline]
        fn cmp(&self, other: &Bits1) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Bits1 {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[cfg(feature = "std")]
    impl Named for Bits1 {
        #[inline]
        fn name(&self) -> String {
            ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("B{0}", 1));
                res
            })
        }
    }
    impl Bits for Bits1 {
        const NUMBER_OF_BITS: u8 = 1;
    }
    #[non_exhaustive]
    /// A struct representing the number of bits.
    pub struct Bits2;
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Bits2 {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_unit_struct(__serializer, "Bits2")
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Bits2 {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Bits2>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Bits2;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "unit struct Bits2",
                        )
                    }
                    #[inline]
                    fn visit_unit<__E>(
                        self,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(Bits2)
                    }
                }
                _serde::Deserializer::deserialize_unit_struct(
                    __deserializer,
                    "Bits2",
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Bits2>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for Bits2 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Bits2")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Bits2 {
        #[inline]
        fn default() -> Bits2 {
            Bits2 {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Bits2 {
        #[inline]
        fn clone(&self) -> Bits2 {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Bits2 {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Bits2 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Bits2 {
        #[inline]
        fn eq(&self, other: &Bits2) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Bits2 {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Bits2 {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Bits2,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Bits2 {
        #[inline]
        fn cmp(&self, other: &Bits2) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Bits2 {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[cfg(feature = "std")]
    impl Named for Bits2 {
        #[inline]
        fn name(&self) -> String {
            ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("B{0}", 2));
                res
            })
        }
    }
    impl Bits for Bits2 {
        const NUMBER_OF_BITS: u8 = 2;
    }
    #[non_exhaustive]
    /// A struct representing the number of bits.
    pub struct Bits3;
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Bits3 {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_unit_struct(__serializer, "Bits3")
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Bits3 {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Bits3>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Bits3;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "unit struct Bits3",
                        )
                    }
                    #[inline]
                    fn visit_unit<__E>(
                        self,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(Bits3)
                    }
                }
                _serde::Deserializer::deserialize_unit_struct(
                    __deserializer,
                    "Bits3",
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Bits3>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for Bits3 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Bits3")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Bits3 {
        #[inline]
        fn default() -> Bits3 {
            Bits3 {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Bits3 {
        #[inline]
        fn clone(&self) -> Bits3 {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Bits3 {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Bits3 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Bits3 {
        #[inline]
        fn eq(&self, other: &Bits3) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Bits3 {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Bits3 {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Bits3,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Bits3 {
        #[inline]
        fn cmp(&self, other: &Bits3) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Bits3 {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[cfg(feature = "std")]
    impl Named for Bits3 {
        #[inline]
        fn name(&self) -> String {
            ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("B{0}", 3));
                res
            })
        }
    }
    impl Bits for Bits3 {
        const NUMBER_OF_BITS: u8 = 3;
    }
    #[non_exhaustive]
    /// A struct representing the number of bits.
    pub struct Bits4;
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Bits4 {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_unit_struct(__serializer, "Bits4")
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Bits4 {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Bits4>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Bits4;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "unit struct Bits4",
                        )
                    }
                    #[inline]
                    fn visit_unit<__E>(
                        self,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(Bits4)
                    }
                }
                _serde::Deserializer::deserialize_unit_struct(
                    __deserializer,
                    "Bits4",
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Bits4>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for Bits4 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Bits4")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Bits4 {
        #[inline]
        fn default() -> Bits4 {
            Bits4 {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Bits4 {
        #[inline]
        fn clone(&self) -> Bits4 {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Bits4 {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Bits4 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Bits4 {
        #[inline]
        fn eq(&self, other: &Bits4) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Bits4 {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Bits4 {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Bits4,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Bits4 {
        #[inline]
        fn cmp(&self, other: &Bits4) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Bits4 {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[cfg(feature = "std")]
    impl Named for Bits4 {
        #[inline]
        fn name(&self) -> String {
            ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("B{0}", 4));
                res
            })
        }
    }
    impl Bits for Bits4 {
        const NUMBER_OF_BITS: u8 = 4;
    }
    #[non_exhaustive]
    /// A struct representing the number of bits.
    pub struct Bits5;
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Bits5 {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_unit_struct(__serializer, "Bits5")
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Bits5 {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Bits5>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Bits5;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "unit struct Bits5",
                        )
                    }
                    #[inline]
                    fn visit_unit<__E>(
                        self,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(Bits5)
                    }
                }
                _serde::Deserializer::deserialize_unit_struct(
                    __deserializer,
                    "Bits5",
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Bits5>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for Bits5 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Bits5")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Bits5 {
        #[inline]
        fn default() -> Bits5 {
            Bits5 {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Bits5 {
        #[inline]
        fn clone(&self) -> Bits5 {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Bits5 {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Bits5 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Bits5 {
        #[inline]
        fn eq(&self, other: &Bits5) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Bits5 {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Bits5 {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Bits5,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Bits5 {
        #[inline]
        fn cmp(&self, other: &Bits5) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Bits5 {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[cfg(feature = "std")]
    impl Named for Bits5 {
        #[inline]
        fn name(&self) -> String {
            ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("B{0}", 5));
                res
            })
        }
    }
    impl Bits for Bits5 {
        const NUMBER_OF_BITS: u8 = 5;
    }
    #[non_exhaustive]
    /// A struct representing the number of bits.
    pub struct Bits6;
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Bits6 {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_unit_struct(__serializer, "Bits6")
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Bits6 {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Bits6>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Bits6;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "unit struct Bits6",
                        )
                    }
                    #[inline]
                    fn visit_unit<__E>(
                        self,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(Bits6)
                    }
                }
                _serde::Deserializer::deserialize_unit_struct(
                    __deserializer,
                    "Bits6",
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Bits6>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for Bits6 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Bits6")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Bits6 {
        #[inline]
        fn default() -> Bits6 {
            Bits6 {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Bits6 {
        #[inline]
        fn clone(&self) -> Bits6 {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Bits6 {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Bits6 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Bits6 {
        #[inline]
        fn eq(&self, other: &Bits6) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Bits6 {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Bits6 {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Bits6,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Bits6 {
        #[inline]
        fn cmp(&self, other: &Bits6) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Bits6 {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[cfg(feature = "std")]
    impl Named for Bits6 {
        #[inline]
        fn name(&self) -> String {
            ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("B{0}", 6));
                res
            })
        }
    }
    impl Bits for Bits6 {
        const NUMBER_OF_BITS: u8 = 6;
    }
    #[non_exhaustive]
    /// A struct representing the number of bits.
    pub struct Bits7;
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Bits7 {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_unit_struct(__serializer, "Bits7")
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Bits7 {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Bits7>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Bits7;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "unit struct Bits7",
                        )
                    }
                    #[inline]
                    fn visit_unit<__E>(
                        self,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(Bits7)
                    }
                }
                _serde::Deserializer::deserialize_unit_struct(
                    __deserializer,
                    "Bits7",
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Bits7>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for Bits7 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Bits7")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Bits7 {
        #[inline]
        fn default() -> Bits7 {
            Bits7 {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Bits7 {
        #[inline]
        fn clone(&self) -> Bits7 {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Bits7 {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Bits7 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Bits7 {
        #[inline]
        fn eq(&self, other: &Bits7) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Bits7 {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Bits7 {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Bits7,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Bits7 {
        #[inline]
        fn cmp(&self, other: &Bits7) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Bits7 {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[cfg(feature = "std")]
    impl Named for Bits7 {
        #[inline]
        fn name(&self) -> String {
            ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("B{0}", 7));
                res
            })
        }
    }
    impl Bits for Bits7 {
        const NUMBER_OF_BITS: u8 = 7;
    }
    #[non_exhaustive]
    /// A struct representing the number of bits.
    pub struct Bits8;
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Bits8 {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_unit_struct(__serializer, "Bits8")
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Bits8 {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Bits8>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Bits8;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "unit struct Bits8",
                        )
                    }
                    #[inline]
                    fn visit_unit<__E>(
                        self,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(Bits8)
                    }
                }
                _serde::Deserializer::deserialize_unit_struct(
                    __deserializer,
                    "Bits8",
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Bits8>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for Bits8 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Bits8")
        }
    }
    #[automatically_derived]
    impl ::core::default::Default for Bits8 {
        #[inline]
        fn default() -> Bits8 {
            Bits8 {}
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Bits8 {
        #[inline]
        fn clone(&self) -> Bits8 {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Bits8 {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Bits8 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Bits8 {
        #[inline]
        fn eq(&self, other: &Bits8) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Bits8 {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::cmp::PartialOrd for Bits8 {
        #[inline]
        fn partial_cmp(
            &self,
            other: &Bits8,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            ::core::option::Option::Some(::core::cmp::Ordering::Equal)
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Ord for Bits8 {
        #[inline]
        fn cmp(&self, other: &Bits8) -> ::core::cmp::Ordering {
            ::core::cmp::Ordering::Equal
        }
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Bits8 {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[cfg(feature = "std")]
    impl Named for Bits8 {
        #[inline]
        fn name(&self) -> String {
            ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("B{0}", 8));
                res
            })
        }
    }
    impl Bits for Bits8 {
        const NUMBER_OF_BITS: u8 = 8;
    }
}
mod estimator {
    //! This module defines the traits for the cardinality estimators.
    use core::hash::Hash;
    use crate::prelude::*;
    /// Trait for properties of a set.
    pub trait SetProperties {
        /// Returns whether the set is empty.
        fn is_empty(&self) -> bool;
        /// Returns whether the set is full.
        fn is_full(&self) -> bool;
    }
    /// Trait for an approximated set.
    pub trait ApproximatedSet<T: Hash>: SetProperties {
        /// Returns whether the set contains the element.
        fn may_contain(&self, element: &T) -> bool;
    }
    /// Trait for a mutable set.
    pub trait MutableSet: SetProperties {
        /// Empties the set.
        fn clear(&mut self);
    }
    /// Trait for an extendable approximated set.
    pub trait ExtendableApproximatedSet<T: Hash> {
        /// Insert an element into the set and return whether the element has been inserted.
        fn insert(&mut self, element: &T) -> bool;
        #[inline]
        /// Extend the [`HyperLogLog`] counter with the elements from an iterator.
        fn extend<I: IntoIterator<Item = T>>(&mut self, iter: I) {
            for value in iter {
                self.insert(&value);
            }
        }
    }
    /// Trait for a cardinality estimator.
    pub trait Estimator<F: Number>: Sized + Send + Sync {
        /// Estimates the cardinality.
        fn estimate_cardinality(&self) -> F;
        /// Returns an estimate of two [`HyperLogLog`] counters union cardinality.
        fn estimate_union_cardinality(&self, other: &Self) -> F;
        /// Returns whether the union estimate is currently non-deterministic.
        fn is_union_estimate_non_deterministic(&self, other: &Self) -> bool;
        #[inline]
        /// Returns an estimate of the intersection cardinality between two counters.
        fn estimate_intersection_cardinality(&self, other: &Self) -> F {
            let self_cardinality = self.estimate_cardinality();
            let other_cardinality = other.estimate_cardinality();
            let union_cardinality = self.estimate_union_cardinality(other);
            if self_cardinality + other_cardinality < union_cardinality {
                F::ZERO
            } else {
                self_cardinality + other_cardinality - union_cardinality
            }
        }
        #[inline]
        /// Returns an estimate of the Jaccard index between two counters.
        fn estimate_jaccard_index(&self, other: &Self) -> F {
            let self_cardinality = self.estimate_cardinality();
            let other_cardinality = other.estimate_cardinality();
            let union_cardinality = self.estimate_union_cardinality(other);
            if self_cardinality + other_cardinality < union_cardinality
                || union_cardinality.is_zero()
            {
                F::ZERO
            } else {
                (self_cardinality + other_cardinality - union_cardinality)
                    / union_cardinality
            }
        }
        #[inline]
        /// Returns an estimate of the cardinality of the current counter minus the cardinality of the other counter.
        fn estimate_difference_cardinality(&self, other: &Self) -> F {
            let union_cardinality = self.estimate_union_cardinality(other);
            let other_cardinality = other.estimate_cardinality();
            if union_cardinality < other_cardinality {
                F::ZERO
            } else {
                union_cardinality - other_cardinality
            }
        }
    }
}
mod hybrid {
    //! Marker struct for the hybrid approach, that keeps the hash explicit up until they fit into the registers.
    use crate::prelude::*;
    use core::cmp::Ordering;
    use core::hash::Hash;
    /// A struct representing the hybrid for approximate set cardinality estimation,
    /// where the hash values are kept explicit up until they fit into the registers.
    pub struct Hybrid<H> {
        /// The inner counter.
        inner: H,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<H> _serde::Serialize for Hybrid<H>
        where
            H: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "Hybrid",
                    false as usize + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "inner",
                    &self.inner,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, H> _serde::Deserialize<'de> for Hybrid<H>
        where
            H: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "inner" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"inner" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de, H>
                where
                    H: _serde::Deserialize<'de>,
                {
                    marker: _serde::__private::PhantomData<Hybrid<H>>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de, H> _serde::de::Visitor<'de> for __Visitor<'de, H>
                where
                    H: _serde::Deserialize<'de>,
                {
                    type Value = Hybrid<H>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct Hybrid",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            H,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Hybrid with 1 element",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(Hybrid { inner: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<H> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("inner"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<H>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("inner")?
                            }
                        };
                        _serde::__private::Ok(Hybrid { inner: __field0 })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["inner"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Hybrid",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Hybrid<H>>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl<H> mem_dbg::MemDbgImpl for Hybrid<H>
    where
        H: mem_dbg::MemDbgImpl,
    {
        #[inline(always)]
        fn _mem_dbg_rec_on(
            &self,
            _memdbg_writer: &mut impl core::fmt::Write,
            _memdbg_total_size: usize,
            _memdbg_max_depth: usize,
            _memdbg_prefix: &mut String,
            _memdbg_is_last: bool,
            _memdbg_flags: mem_dbg::DbgFlags,
        ) -> core::fmt::Result {
            let mut id_sizes: Vec<(usize, usize)> = ::alloc::vec::Vec::new();
            id_sizes.push((0usize, { builtin # offset_of(Hybrid < H >, inner) }));
            let n = id_sizes.len();
            id_sizes.push((n, core::mem::size_of::<Self>()));
            id_sizes.sort_by_key(|x| x.1);
            for i in 0..n {
                id_sizes[i].1 = id_sizes[i + 1].1 - id_sizes[i].1;
            }
            if !_memdbg_flags.contains(mem_dbg::DbgFlags::RUST_LAYOUT) {
                id_sizes.sort_by_key(|x| x.0);
            }
            for (i, (field_idx, padded_size)) in id_sizes.into_iter().enumerate().take(n)
            {
                match field_idx {
                    0usize => {
                        <H as mem_dbg::MemDbgImpl>::_mem_dbg_depth_on(
                            &self.inner,
                            _memdbg_writer,
                            _memdbg_total_size,
                            _memdbg_max_depth,
                            _memdbg_prefix,
                            Some("inner"),
                            i == n - 1,
                            padded_size,
                            _memdbg_flags,
                        )?
                    }
                    _ => {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                }
            }
            Ok(())
        }
    }
    #[automatically_derived]
    impl<H> mem_dbg::CopyType for Hybrid<H>
    where
        H: mem_dbg::MemSize,
    {
        type Copy = mem_dbg::False;
    }
    #[automatically_derived]
    impl<H> mem_dbg::MemSize for Hybrid<H>
    where
        H: mem_dbg::MemSize,
    {
        fn mem_size(&self, _memsize_flags: mem_dbg::SizeFlags) -> usize {
            let mut bytes = core::mem::size_of::<Self>();
            bytes
                += <H as mem_dbg::MemSize>::mem_size(&self.inner, _memsize_flags)
                    - core::mem::size_of::<H>();
            bytes
        }
    }
    #[automatically_derived]
    impl<H: ::core::fmt::Debug> ::core::fmt::Debug for Hybrid<H> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "Hybrid",
                "inner",
                &&self.inner,
            )
        }
    }
    #[automatically_derived]
    impl<H: ::core::clone::Clone> ::core::clone::Clone for Hybrid<H> {
        #[inline]
        fn clone(&self) -> Hybrid<H> {
            Hybrid {
                inner: ::core::clone::Clone::clone(&self.inner),
            }
        }
    }
    #[automatically_derived]
    impl<H: ::core::marker::Copy> ::core::marker::Copy for Hybrid<H> {}
    impl<H: Hybridazable> Default for Hybrid<H>
    where
        H: Default,
    {
        #[inline]
        fn default() -> Self {
            Self { inner: H::new_hybrid() }
        }
    }
    impl<H: Hybridazable> Hybridazable for Hybrid<H>
    where
        H: Hybridazable,
    {
        type IterSortedHashes<'words> = H::IterSortedHashes<'words> where Self: 'words;
        #[inline]
        fn dehybridize(&mut self) {
            self.inner.dehybridize();
        }
        #[inline]
        fn new_hybrid() -> Self {
            Self::default()
        }
        #[inline]
        fn is_hybrid(&self) -> bool {
            self.inner.is_hybrid()
        }
        #[inline]
        fn number_of_hashes(&self) -> usize {
            self.inner.number_of_hashes()
        }
        #[inline]
        fn capacity(&self) -> usize {
            self.inner.capacity()
        }
        #[inline]
        fn clear_words(&mut self) {
            self.inner.clear_words();
        }
        #[inline]
        fn iter_sorted_hashes(&self) -> Self::IterSortedHashes<'_> {
            self.inner.iter_sorted_hashes()
        }
        #[inline]
        fn contains<T: Hash>(&self, element: &T) -> bool {
            self.inner.contains(element)
        }
        #[inline]
        fn hybrid_insert<T: Hash>(&mut self, value: &T) -> bool {
            self.inner.hybrid_insert(value)
        }
    }
    impl<H: PartialEq> PartialEq<Self> for Hybrid<H> {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.inner == other.inner
        }
    }
    impl<H: PartialEq<H>> PartialEq<H> for Hybrid<H> {
        #[inline]
        fn eq(&self, other: &H) -> bool {
            &self.inner == other
        }
    }
    impl<H: Eq> Eq for Hybrid<H> {}
    impl<H: SetProperties + Hybridazable> SetProperties for Hybrid<H> {
        #[inline]
        fn is_empty(&self) -> bool {
            if self.is_hybrid() {
                self.inner.number_of_hashes() == 0
            } else {
                self.inner.is_empty()
            }
        }
        #[inline]
        fn is_full(&self) -> bool {
            if self.is_hybrid() {
                self.inner.number_of_hashes() == self.inner.capacity()
            } else {
                self.inner.is_full()
            }
        }
    }
    impl<T: Hash, H: ApproximatedSet<T> + Hybridazable> ApproximatedSet<T>
    for Hybrid<H> {
        #[inline]
        fn may_contain(&self, element: &T) -> bool {
            if self.is_hybrid() {
                Hybridazable::contains(&self.inner, element)
            } else {
                self.inner.may_contain(element)
            }
        }
    }
    impl<H: MutableSet + Hybridazable> MutableSet for Hybrid<H> {
        #[inline]
        fn clear(&mut self) {
            self.inner.clear_words();
        }
    }
    impl<
        T: Hash,
        H: ExtendableApproximatedSet<T> + Hybridazable,
    > ExtendableApproximatedSet<T> for Hybrid<H> {
        #[inline]
        fn insert(&mut self, element: &T) -> bool {
            if self.is_hybrid() {
                Hybridazable::hybrid_insert(&mut self.inner, element)
            } else {
                self.inner.insert(element)
            }
        }
    }
    #[inline]
    /// Returns the number of unique values from two sorted iterators.
    ///
    /// # Implementative details
    /// The sets we are considering are the union of the two sorted iterators
    /// of Hybrid counters' hashes. The largest possible number of unique values
    /// in each iterator is the number of words in a 2**18 counter, with the bit
    /// size set to 8 (used primarely to benefit from the SIMD instructions).
    /// As such 8 * 2**18 = 2**21, divided by the number of bits in a u64, we get
    /// 2**21 / 64 = 2**15 unique values. The number of unique values in the union
    /// of the two sets is at most the sum of the number of unique values in each set,
    /// so at most 2**16 unique values. We can thus use a u32 to represent the number
    /// of unique values.
    fn unique_values_from_sorted_iterators<
        T: Ord,
        I: Iterator<Item = T>,
        J: Iterator<Item = T>,
    >(mut left: I, mut right: J) -> u32 {
        let mut count = u32::ZERO;
        let mut maybe_left_value = left.next();
        let mut maybe_right_value = right.next();
        while let Some(ord) = maybe_left_value
            .as_ref()
            .and_then(|left_value| {
                maybe_right_value.as_ref().map(|right_value| left_value.cmp(right_value))
            })
        {
            count += u32::ONE;
            match ord {
                Ordering::Less => {
                    maybe_left_value = left.next();
                }
                Ordering::Greater => {
                    maybe_right_value = right.next();
                }
                Ordering::Equal => {
                    maybe_left_value = left.next();
                    maybe_right_value = right.next();
                }
            }
        }
        if maybe_left_value.is_some() {
            count += u32::ONE;
        }
        if maybe_right_value.is_some() {
            count += u32::ONE;
        }
        count + u32::try_from(left.count()).unwrap()
            + u32::try_from(right.count()).unwrap()
    }
    /// Trait for a struct that can be used in the hybrid approach.
    pub trait Hybridazable: Default {
        /// The type of the iterator over the sorted hashes.
        type IterSortedHashes<'words>: Iterator<Item = u64> where Self: 'words;
        /// De-hybridize the struct, i.e., convert it to a register-based counter.
        fn dehybridize(&mut self);
        /// Returns a new hybrid instance.
        fn new_hybrid() -> Self;
        /// Returns whether the struct is currently behaving as
        /// a hybrid counter.
        fn is_hybrid(&self) -> bool;
        /// Returns the number of hashes currently inserted.
        fn number_of_hashes(&self) -> usize;
        /// Returns the capacity of the counter.
        fn capacity(&self) -> usize;
        /// Clears the counter.
        fn clear_words(&mut self);
        /// Returns an iterator over the sorted hashes.
        fn iter_sorted_hashes(&self) -> Self::IterSortedHashes<'_>;
        /// Returns whether the counter contains the element.
        fn contains<T: Hash>(&self, element: &T) -> bool;
        /// Inserts a value into the counter.
        fn hybrid_insert<T: Hash>(&mut self, value: &T) -> bool;
    }
    #[cfg(feature = "std")]
    impl<H: Named> Named for Hybrid<H> {
        #[inline]
        fn name(&self) -> String {
            ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("Hybrid{0}", self.inner.name()),
                );
                res
            })
        }
    }
    impl<H: Clone + Estimator<f64> + Hybridazable + Default> Estimator<f64> for Hybrid<H>
    where
        Hybrid<H>: Default,
    {
        #[inline]
        fn estimate_cardinality(&self) -> f64 {
            if self.inner.is_hybrid() {
                f64::from(u16::try_from(self.inner.number_of_hashes()).unwrap())
            } else {
                self.inner.estimate_cardinality()
            }
        }
        #[inline]
        fn is_union_estimate_non_deterministic(&self, other: &Self) -> bool {
            !(self.is_hybrid() && other.is_hybrid())
                && self.inner.is_union_estimate_non_deterministic(&other.inner)
        }
        #[inline]
        fn estimate_union_cardinality(&self, other: &Self) -> f64 {
            match (self.is_hybrid(), other.is_hybrid()) {
                (true, true) => {
                    f64::from(
                        unique_values_from_sorted_iterators(
                            self.iter_sorted_hashes(),
                            other.iter_sorted_hashes(),
                        ),
                    )
                }
                (true, false) => {
                    let mut copy = self.clone();
                    copy.dehybridize();
                    copy.estimate_union_cardinality(other)
                }
                (false, true) => other.estimate_union_cardinality(self),
                (false, false) => self.inner.estimate_union_cardinality(&other.inner),
            }
        }
    }
}
mod hyperloglog {
    //! The `hyperloglog` module contains the [`HyperLogLog`] trait that defines the interface for [`HyperLogLog`] counters.
    use crate::prelude::*;
    use core::hash::{Hash, Hasher};
    /// Trait for [`HyperLogLog`] counters.
    pub trait HyperLogLog<
        P: Precision,
        B: Bits,
        HS: Hasher + Default,
    >: Sized + Default + Eq + PartialEq + BitOrAssign<
            Self,
        > + BitOr<Self, Output = Self> + Send + Sync + SetProperties + MutableSet {
        /// The type of the registers of the [`HyperLogLog`] counter.
        type Registers: Registers<P, B>;
        /// Returns a reference to the registers of the [`HyperLogLog`] counter.
        fn registers(&self) -> &Self::Registers;
        /// Returns the harmonic sum of the registers.
        fn harmonic_sum(&self) -> f64;
        /// Returns the number of registers with zero values. This value is used for computing a small
        /// correction when estimating the cardinality of a small set.
        ///
        /// # Examples
        ///
        /// ```
        /// #[cfg(feature = "beta")]
        /// {
        ///     use hyperloglog_rs::prelude::*;
        ///
        ///     // Create a new HyperLogLog counter with precision 14 and 5 bits per register.
        ///     let mut hll = LogLogBeta::<
        ///         Precision6,
        ///         Bits5,
        ///         <Precision6 as ArrayRegister<Bits5>>::ArrayRegister,
        ///     >::default();
        ///
        ///     // Add some elements to the counter.
        ///     hll.insert(&1);
        ///     hll.insert(&2);
        ///     hll.insert(&3);
        ///
        ///     // Get the number of zero registers.
        ///     let number_of_zero_registers = hll.get_number_of_zero_registers();
        ///
        ///     assert_eq!(number_of_zero_registers, 61);
        /// }
        /// ```
        fn get_number_of_zero_registers(&self) -> P::NumberOfRegisters;
        #[inline]
        /// Returns whether the provided [`HyperLogLog`] counter may be fully contained in the current [`HyperLogLog`] counter.
        ///
        /// # Arguments
        /// * `rhs` - The [`HyperLogLog`] counter to check.
        ///
        /// # Implementative details
        /// We define a counter that fully contains another counter when all of the registers
        /// of the first counter are greater than or equal to the corresponding registers of the second counter.
        ///
        /// # Examples
        ///
        /// ```rust
        /// # use hyperloglog_rs::prelude::*;
        ///
        /// let mut hll1: PlusPlus<Precision8, Bits6, <Precision8 as ArrayRegister<Bits6>>::ArrayRegister> =
        ///     Default::default();
        /// let mut hll2: PlusPlus<Precision8, Bits6, <Precision8 as ArrayRegister<Bits6>>::ArrayRegister> =
        ///     Default::default();
        ///
        /// hll1.insert(&42);
        /// hll1.insert(&43);
        /// hll1.insert(&44);
        ///
        /// hll2.insert(&42);
        /// hll2.insert(&43);
        ///
        /// assert_eq!(hll1.may_contain_all(&hll2), true);
        /// assert_eq!(hll2.may_contain_all(&hll1), false);
        ///
        /// hll2.insert(&44);
        ///
        /// assert_eq!(hll1.may_contain_all(&hll2), true);
        /// assert_eq!(hll2.may_contain_all(&hll1), true);
        /// ```
        fn may_contain_all(&self, rhs: &Self) -> bool {
            self.registers()
                .iter_registers_zipped(rhs.registers())
                .all(|(left_register, right_register)| left_register >= right_register)
        }
        #[must_use]
        #[inline]
        /// Slits the hash into two parts: the register value and the index of the register.
        fn split_hash(hash: u64) -> (u8, P::NumberOfRegisters) {
            let index: P::NumberOfRegisters = P::NumberOfRegisters::try_from_u64(
                    hash & (P::NUMBER_OF_REGISTERS - P::NumberOfRegisters::ONE).into(),
                )
                .unwrap();
            let mut censored_hash: u64 = hash >> P::EXPONENT;
            if true {
                if !(index < P::NUMBER_OF_REGISTERS) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "The index {0} must be less than the number of registers {1}.",
                                index,
                                P::NUMBER_OF_REGISTERS,
                            ),
                        );
                    }
                }
            }
            if B::NUMBER_OF_BITS < 6_u8 {
                censored_hash
                    |= 1 << (64_u8 - ((u8::ONE << B::NUMBER_OF_BITS) - u8::ONE));
            }
            let register_value = u8::try_from(censored_hash.leading_zeros() + 1).unwrap()
                - P::EXPONENT;
            (register_value, index)
        }
        #[inline]
        /// Hashes the element and returns the register value and the index of the register.
        fn hash_and_index<T: Hash>(element: &T) -> (u8, P::NumberOfRegisters) {
            let mut hasher = HS::default();
            element.hash(&mut hasher);
            let hash = hasher.finish();
            Self::split_hash(hash)
        }
        /// Return the value of the register at the given index.
        fn get_register(&self, index: P::NumberOfRegisters) -> u8;
        /// Create a new [`HyperLogLog`] counter from an array of registers.
        fn from_registers(registers: Self::Registers) -> Self;
    }
}
mod hyperloglog_macro {
    //! This module contains the macro used to implement the [`HyperLogLog`] trait for a given counter.
}
#[cfg(feature = "beta")]
mod loglogbeta {
    //! Submodule implementing [`LogLogBeta`].
    use crate::basicloglog::BasicLogLog;
    use crate::hll_impl;
    use crate::prelude::*;
    use core::any::type_name;
    #[cfg(feature = "std")]
    use crate::utils::Named;
    /// A struct implementing the [`LogLogBeta`] algorithm.
    pub struct LogLogBeta<
        P: Precision,
        B: Bits,
        R: Registers<P, B>,
        Hasher: HasherType = twox_hash::XxHash64,
    > {
        /// The underlying `BasicLogLog` counter.
        counter: BasicLogLog<P, B, R, Hasher>,
    }
    #[automatically_derived]
    impl<
        P: Precision,
        B: Bits,
        R: Registers<P, B>,
        Hasher: HasherType,
    > mem_dbg::MemDbgImpl for LogLogBeta<P, B, R, Hasher>
    where
        BasicLogLog<P, B, R, Hasher>: mem_dbg::MemDbgImpl,
    {
        #[inline(always)]
        fn _mem_dbg_rec_on(
            &self,
            _memdbg_writer: &mut impl core::fmt::Write,
            _memdbg_total_size: usize,
            _memdbg_max_depth: usize,
            _memdbg_prefix: &mut String,
            _memdbg_is_last: bool,
            _memdbg_flags: mem_dbg::DbgFlags,
        ) -> core::fmt::Result {
            let mut id_sizes: Vec<(usize, usize)> = ::alloc::vec::Vec::new();
            id_sizes
                .push((
                    0usize,
                    { builtin # offset_of(LogLogBeta < P, B, R, Hasher >, counter) },
                ));
            let n = id_sizes.len();
            id_sizes.push((n, core::mem::size_of::<Self>()));
            id_sizes.sort_by_key(|x| x.1);
            for i in 0..n {
                id_sizes[i].1 = id_sizes[i + 1].1 - id_sizes[i].1;
            }
            if !_memdbg_flags.contains(mem_dbg::DbgFlags::RUST_LAYOUT) {
                id_sizes.sort_by_key(|x| x.0);
            }
            for (i, (field_idx, padded_size)) in id_sizes.into_iter().enumerate().take(n)
            {
                match field_idx {
                    0usize => {
                        <BasicLogLog<
                            P,
                            B,
                            R,
                            Hasher,
                        > as mem_dbg::MemDbgImpl>::_mem_dbg_depth_on(
                            &self.counter,
                            _memdbg_writer,
                            _memdbg_total_size,
                            _memdbg_max_depth,
                            _memdbg_prefix,
                            Some("counter"),
                            i == n - 1,
                            padded_size,
                            _memdbg_flags,
                        )?
                    }
                    _ => {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                }
            }
            Ok(())
        }
    }
    #[automatically_derived]
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> mem_dbg::CopyType
    for LogLogBeta<P, B, R, Hasher>
    where
        BasicLogLog<P, B, R, Hasher>: mem_dbg::MemSize,
    {
        type Copy = mem_dbg::False;
    }
    #[automatically_derived]
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> mem_dbg::MemSize
    for LogLogBeta<P, B, R, Hasher>
    where
        BasicLogLog<P, B, R, Hasher>: mem_dbg::MemSize,
    {
        fn mem_size(&self, _memsize_flags: mem_dbg::SizeFlags) -> usize {
            let mut bytes = core::mem::size_of::<Self>();
            bytes
                += <BasicLogLog<
                    P,
                    B,
                    R,
                    Hasher,
                > as mem_dbg::MemSize>::mem_size(&self.counter, _memsize_flags)
                    - core::mem::size_of::<BasicLogLog<P, B, R, Hasher>>();
            bytes
        }
    }
    #[automatically_derived]
    impl<
        P: ::core::fmt::Debug + Precision,
        B: ::core::fmt::Debug + Bits,
        R: ::core::fmt::Debug + Registers<P, B>,
        Hasher: ::core::fmt::Debug + HasherType,
    > ::core::fmt::Debug for LogLogBeta<P, B, R, Hasher> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "LogLogBeta",
                "counter",
                &&self.counter,
            )
        }
    }
    #[automatically_derived]
    impl<
        P: ::core::clone::Clone + Precision,
        B: ::core::clone::Clone + Bits,
        R: ::core::clone::Clone + Registers<P, B>,
        Hasher: ::core::clone::Clone + HasherType,
    > ::core::clone::Clone for LogLogBeta<P, B, R, Hasher> {
        #[inline]
        fn clone(&self) -> LogLogBeta<P, B, R, Hasher> {
            LogLogBeta {
                counter: ::core::clone::Clone::clone(&self.counter),
            }
        }
    }
    #[automatically_derived]
    impl<
        P: ::core::marker::Copy + Precision,
        B: ::core::marker::Copy + Bits,
        R: ::core::marker::Copy + Registers<P, B>,
        Hasher: ::core::marker::Copy + HasherType,
    > ::core::marker::Copy for LogLogBeta<P, B, R, Hasher> {}
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> Default
    for LogLogBeta<P, B, R, Hasher> {
        #[inline]
        fn default() -> Self {
            Self {
                counter: Default::default(),
            }
        }
    }
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> PartialEq
    for LogLogBeta<P, B, R, Hasher> {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.counter == other.counter
        }
    }
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> Eq
    for LogLogBeta<P, B, R, Hasher> {}
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> BitOrAssign
    for LogLogBeta<P, B, R, Hasher> {
        #[inline]
        fn bitor_assign(&mut self, rhs: Self) {
            self.counter |= rhs.counter;
        }
    }
    #[cfg(feature = "serde")]
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> serde::Serialize
    for LogLogBeta<P, B, R, Hasher> {
        #[inline(always)]
        fn serialize<S: serde::Serializer>(
            &self,
            serializer: S,
        ) -> Result<S::Ok, S::Error> {
            use serde::ser::SerializeSeq;
            let mut seq = serializer.serialize_seq(Some(1 << P::EXPONENT))?;
            for register in self.registers().iter_registers() {
                seq.serialize_element(&register)?;
            }
            seq.end()
        }
    }
    #[cfg(feature = "serde")]
    impl<
        'de,
        P: Precision,
        B: Bits,
        R: Registers<P, B>,
        Hasher: HasherType,
    > serde::Deserialize<'de> for LogLogBeta<P, B, R, Hasher> {
        #[inline]
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            let mut registers: R = R::zeroed();
            let visitor = crate::serde::RegisterVisitor::<u8>::new(1 << P::EXPONENT);
            let mut iter = deserializer.deserialize_seq(visitor)?.into_iter();
            registers.apply(|_| iter.next().unwrap());
            if true {
                match (&iter.next(), &None) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                };
            }
            Ok(Self::from_registers(registers))
        }
    }
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> BitOr
    for LogLogBeta<P, B, R, Hasher> {
        type Output = Self;
        #[inline]
        fn bitor(self, rhs: Self) -> Self::Output {
            Self {
                counter: self.counter | rhs.counter,
            }
        }
    }
    impl<
        P: Precision,
        B: Bits,
        R: Registers<P, B>,
        Hasher: HasherType,
    > HyperLogLog<P, B, Hasher> for LogLogBeta<P, B, R, Hasher> {
        type Registers = R;
        #[inline]
        fn registers(&self) -> &Self::Registers {
            self.counter.registers()
        }
        #[inline]
        fn get_number_of_zero_registers(&self) -> <P as Precision>::NumberOfRegisters {
            self.counter.get_number_of_zero_registers()
        }
        #[inline]
        fn get_register(&self, index: P::NumberOfRegisters) -> u8 {
            self.counter.get_register(index)
        }
        #[inline]
        fn harmonic_sum(&self) -> f64 {
            self.counter.harmonic_sum()
        }
        #[inline]
        fn from_registers(registers: R) -> Self {
            Self {
                counter: HyperLogLog::from_registers(registers),
            }
        }
    }
    impl<P: Precision, B: Bits, Hasher: HasherType, R: Registers<P, B>> SetProperties
    for LogLogBeta<P, B, R, Hasher> {
        #[inline(always)]
        fn is_empty(&self) -> bool {
            self.counter.is_empty()
        }
        #[inline(always)]
        fn is_full(&self) -> bool {
            self.counter.is_full()
        }
    }
    impl<P: Precision, B: Bits, Hasher: HasherType, R: Registers<P, B>> MutableSet
    for LogLogBeta<P, B, R, Hasher> {
        #[inline(always)]
        fn clear(&mut self) {
            self.counter.clear()
        }
    }
    impl<
        P: Precision,
        B: Bits,
        Hasher: HasherType,
        R: Registers<P, B>,
        T: core::hash::Hash,
    > ApproximatedSet<T> for LogLogBeta<P, B, R, Hasher> {
        #[inline(always)]
        fn may_contain(&self, element: &T) -> bool {
            self.counter.may_contain(element)
        }
    }
    impl<
        P: Precision,
        B: Bits,
        Hasher: HasherType,
        R: Registers<P, B>,
        T: core::hash::Hash,
    > ExtendableApproximatedSet<T> for LogLogBeta<P, B, R, Hasher> {
        #[inline(always)]
        fn insert(&mut self, element: &T) -> bool {
            self.counter.insert(element)
        }
    }
    impl<
        P: Precision,
        B: Bits,
        Hasher: HasherType,
        R: Registers<P, B> + Words,
    > Hybridazable for LogLogBeta<P, B, R, Hasher> {
        type IterSortedHashes<'words> = core::iter::Take<R::WordIter<'words>>
        where
            Self: 'words;
        #[inline]
        fn is_hybrid(&self) -> bool {
            self.counter.is_hybrid()
        }
        #[inline]
        fn dehybridize(&mut self) {
            self.counter.dehybridize()
        }
        #[inline]
        fn new_hybrid() -> Self {
            Self {
                counter: Hybridazable::new_hybrid(),
            }
        }
        #[inline]
        fn number_of_hashes(&self) -> usize {
            self.counter.number_of_hashes()
        }
        #[inline]
        fn capacity(&self) -> usize {
            self.counter.capacity()
        }
        #[inline]
        fn contains<T: core::hash::Hash>(&self, element: &T) -> bool {
            Hybridazable::contains(&self.counter, element)
        }
        #[inline]
        fn clear_words(&mut self) {
            self.counter.clear_words()
        }
        #[inline]
        fn iter_sorted_hashes(&self) -> Self::IterSortedHashes<'_> {
            self.counter.iter_sorted_hashes()
        }
        #[inline]
        fn hybrid_insert<T: core::hash::Hash>(&mut self, element: &T) -> bool {
            self.counter.hybrid_insert(element)
        }
    }
    impl<
        P: Precision,
        B: Bits,
        R: Registers<P, B>,
        Hasher: HasherType,
    > From<BasicLogLog<P, B, R, Hasher>> for LogLogBeta<P, B, R, Hasher> {
        #[inline]
        fn from(counter: BasicLogLog<P, B, R, Hasher>) -> Self {
            Self { counter }
        }
    }
    #[cfg(feature = "std")]
    impl<
        P: Precision + Named,
        B: Bits + Named,
        R: Registers<P, B> + Named,
        Hasher: HasherType,
    > Named for LogLogBeta<P, B, R, Hasher> {
        #[inline]
        fn name(&self) -> String {
            #[cfg(not(feature = "precomputed_beta"))]
            let model_name = "LLB";
            ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!(
                        "{4}<{0}, {1}, {2}> + {3}",
                        P::default().name(),
                        B::default().name(),
                        self.registers().name(),
                        type_name::<Hasher>().split("::").last().unwrap(),
                        model_name,
                    ),
                );
                res
            })
        }
    }
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> Estimator<f64>
    for LogLogBeta<P, B, R, Hasher>
    where
        Self: HyperLogLog<P, B, Hasher>,
    {
        #[inline]
        fn estimate_cardinality(&self) -> f64 {
            P::beta_estimate(self.harmonic_sum(), self.get_number_of_zero_registers())
        }
        #[inline]
        fn estimate_union_cardinality(&self, other: &Self) -> f64 {
            let (harmonic_sum, number_of_zero_registers) = self
                .registers()
                .get_harmonic_sum_and_zeros(other.registers());
            correct_union_estimate(
                P::beta_estimate(
                    self.harmonic_sum(),
                    self.get_number_of_zero_registers(),
                ),
                P::beta_estimate(
                    other.harmonic_sum(),
                    other.get_number_of_zero_registers(),
                ),
                P::beta_estimate(harmonic_sum, number_of_zero_registers),
            )
        }
        #[inline]
        fn is_union_estimate_non_deterministic(&self, _other: &Self) -> bool {
            false
        }
    }
}
#[cfg(feature = "mle")]
mod mle {
    //! Struct marker MLE.
    use crate::hll_impl;
    use crate::prelude::*;
    use core::cmp::Ordering;
    use core::f64;
    /// A struct representing the Maximum Likelihood Estimation.
    pub struct MLE<H, const ERROR: i32 = 2> {
        /// The underlying counter.
        counter: H,
    }
    #[automatically_derived]
    impl<H, const ERROR: i32> mem_dbg::MemDbgImpl for MLE<H, ERROR>
    where
        H: mem_dbg::MemDbgImpl,
    {
        #[inline(always)]
        fn _mem_dbg_rec_on(
            &self,
            _memdbg_writer: &mut impl core::fmt::Write,
            _memdbg_total_size: usize,
            _memdbg_max_depth: usize,
            _memdbg_prefix: &mut String,
            _memdbg_is_last: bool,
            _memdbg_flags: mem_dbg::DbgFlags,
        ) -> core::fmt::Result {
            let mut id_sizes: Vec<(usize, usize)> = ::alloc::vec::Vec::new();
            id_sizes.push((0usize, { builtin # offset_of(MLE < H, ERROR >, counter) }));
            let n = id_sizes.len();
            id_sizes.push((n, core::mem::size_of::<Self>()));
            id_sizes.sort_by_key(|x| x.1);
            for i in 0..n {
                id_sizes[i].1 = id_sizes[i + 1].1 - id_sizes[i].1;
            }
            if !_memdbg_flags.contains(mem_dbg::DbgFlags::RUST_LAYOUT) {
                id_sizes.sort_by_key(|x| x.0);
            }
            for (i, (field_idx, padded_size)) in id_sizes.into_iter().enumerate().take(n)
            {
                match field_idx {
                    0usize => {
                        <H as mem_dbg::MemDbgImpl>::_mem_dbg_depth_on(
                            &self.counter,
                            _memdbg_writer,
                            _memdbg_total_size,
                            _memdbg_max_depth,
                            _memdbg_prefix,
                            Some("counter"),
                            i == n - 1,
                            padded_size,
                            _memdbg_flags,
                        )?
                    }
                    _ => {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                }
            }
            Ok(())
        }
    }
    #[automatically_derived]
    impl<H, const ERROR: i32> mem_dbg::CopyType for MLE<H, ERROR>
    where
        H: mem_dbg::MemSize,
    {
        type Copy = mem_dbg::False;
    }
    #[automatically_derived]
    impl<H, const ERROR: i32> mem_dbg::MemSize for MLE<H, ERROR>
    where
        H: mem_dbg::MemSize,
    {
        fn mem_size(&self, _memsize_flags: mem_dbg::SizeFlags) -> usize {
            let mut bytes = core::mem::size_of::<Self>();
            bytes
                += <H as mem_dbg::MemSize>::mem_size(&self.counter, _memsize_flags)
                    - core::mem::size_of::<H>();
            bytes
        }
    }
    #[automatically_derived]
    impl<H: ::core::fmt::Debug, const ERROR: i32> ::core::fmt::Debug for MLE<H, ERROR> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "MLE",
                "counter",
                &&self.counter,
            )
        }
    }
    #[automatically_derived]
    impl<H: ::core::clone::Clone, const ERROR: i32> ::core::clone::Clone
    for MLE<H, ERROR> {
        #[inline]
        fn clone(&self) -> MLE<H, ERROR> {
            MLE {
                counter: ::core::clone::Clone::clone(&self.counter),
            }
        }
    }
    #[automatically_derived]
    impl<H: ::core::marker::Copy, const ERROR: i32> ::core::marker::Copy
    for MLE<H, ERROR> {}
    #[automatically_derived]
    impl<H: ::core::hash::Hash, const ERROR: i32> ::core::hash::Hash for MLE<H, ERROR> {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.counter, state)
        }
    }
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> Default
    for MLE<LogLogBeta<P, B, R, Hasher>, 2> {
        #[inline]
        fn default() -> Self {
            Self {
                counter: Default::default(),
            }
        }
    }
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> PartialEq
    for MLE<LogLogBeta<P, B, R, Hasher>, 2> {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.counter == other.counter
        }
    }
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> Eq
    for MLE<LogLogBeta<P, B, R, Hasher>, 2> {}
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> BitOrAssign
    for MLE<LogLogBeta<P, B, R, Hasher>, 2> {
        #[inline]
        fn bitor_assign(&mut self, rhs: Self) {
            self.counter |= rhs.counter;
        }
    }
    #[cfg(feature = "serde")]
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> serde::Serialize
    for MLE<LogLogBeta<P, B, R, Hasher>, 2> {
        #[inline(always)]
        fn serialize<S: serde::Serializer>(
            &self,
            serializer: S,
        ) -> Result<S::Ok, S::Error> {
            use serde::ser::SerializeSeq;
            let mut seq = serializer.serialize_seq(Some(1 << P::EXPONENT))?;
            for register in self.registers().iter_registers() {
                seq.serialize_element(&register)?;
            }
            seq.end()
        }
    }
    #[cfg(feature = "serde")]
    impl<
        'de,
        P: Precision,
        B: Bits,
        R: Registers<P, B>,
        Hasher: HasherType,
    > serde::Deserialize<'de> for MLE<LogLogBeta<P, B, R, Hasher>, 2> {
        #[inline]
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            let mut registers: R = R::zeroed();
            let visitor = crate::serde::RegisterVisitor::<u8>::new(1 << P::EXPONENT);
            let mut iter = deserializer.deserialize_seq(visitor)?.into_iter();
            registers.apply(|_| iter.next().unwrap());
            if true {
                match (&iter.next(), &None) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                };
            }
            Ok(Self::from_registers(registers))
        }
    }
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> BitOr
    for MLE<LogLogBeta<P, B, R, Hasher>, 2> {
        type Output = Self;
        #[inline]
        fn bitor(self, rhs: Self) -> Self::Output {
            Self {
                counter: self.counter | rhs.counter,
            }
        }
    }
    impl<
        P: Precision,
        B: Bits,
        R: Registers<P, B>,
        Hasher: HasherType,
    > HyperLogLog<P, B, Hasher> for MLE<LogLogBeta<P, B, R, Hasher>, 2> {
        type Registers = R;
        #[inline]
        fn registers(&self) -> &Self::Registers {
            self.counter.registers()
        }
        #[inline]
        fn get_number_of_zero_registers(&self) -> <P as Precision>::NumberOfRegisters {
            self.counter.get_number_of_zero_registers()
        }
        #[inline]
        fn get_register(&self, index: P::NumberOfRegisters) -> u8 {
            self.counter.get_register(index)
        }
        #[inline]
        fn harmonic_sum(&self) -> f64 {
            self.counter.harmonic_sum()
        }
        #[inline]
        fn from_registers(registers: R) -> Self {
            Self {
                counter: HyperLogLog::from_registers(registers),
            }
        }
    }
    impl<P: Precision, B: Bits, Hasher: HasherType, R: Registers<P, B>> SetProperties
    for MLE<LogLogBeta<P, B, R, Hasher>, 2> {
        #[inline(always)]
        fn is_empty(&self) -> bool {
            self.counter.is_empty()
        }
        #[inline(always)]
        fn is_full(&self) -> bool {
            self.counter.is_full()
        }
    }
    impl<P: Precision, B: Bits, Hasher: HasherType, R: Registers<P, B>> MutableSet
    for MLE<LogLogBeta<P, B, R, Hasher>, 2> {
        #[inline(always)]
        fn clear(&mut self) {
            self.counter.clear()
        }
    }
    impl<
        P: Precision,
        B: Bits,
        Hasher: HasherType,
        R: Registers<P, B>,
        T: core::hash::Hash,
    > ApproximatedSet<T> for MLE<LogLogBeta<P, B, R, Hasher>, 2> {
        #[inline(always)]
        fn may_contain(&self, element: &T) -> bool {
            self.counter.may_contain(element)
        }
    }
    impl<
        P: Precision,
        B: Bits,
        Hasher: HasherType,
        R: Registers<P, B>,
        T: core::hash::Hash,
    > ExtendableApproximatedSet<T> for MLE<LogLogBeta<P, B, R, Hasher>, 2> {
        #[inline(always)]
        fn insert(&mut self, element: &T) -> bool {
            self.counter.insert(element)
        }
    }
    impl<
        P: Precision,
        B: Bits,
        Hasher: HasherType,
        R: Registers<P, B> + Words,
    > Hybridazable for MLE<LogLogBeta<P, B, R, Hasher>, 2> {
        type IterSortedHashes<'words> = core::iter::Take<R::WordIter<'words>>
        where
            Self: 'words;
        #[inline]
        fn is_hybrid(&self) -> bool {
            self.counter.is_hybrid()
        }
        #[inline]
        fn dehybridize(&mut self) {
            self.counter.dehybridize()
        }
        #[inline]
        fn new_hybrid() -> Self {
            Self {
                counter: Hybridazable::new_hybrid(),
            }
        }
        #[inline]
        fn number_of_hashes(&self) -> usize {
            self.counter.number_of_hashes()
        }
        #[inline]
        fn capacity(&self) -> usize {
            self.counter.capacity()
        }
        #[inline]
        fn contains<T: core::hash::Hash>(&self, element: &T) -> bool {
            Hybridazable::contains(&self.counter, element)
        }
        #[inline]
        fn clear_words(&mut self) {
            self.counter.clear_words()
        }
        #[inline]
        fn iter_sorted_hashes(&self) -> Self::IterSortedHashes<'_> {
            self.counter.iter_sorted_hashes()
        }
        #[inline]
        fn hybrid_insert<T: core::hash::Hash>(&mut self, element: &T) -> bool {
            self.counter.hybrid_insert(element)
        }
    }
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> Default
    for MLE<LogLogBeta<P, B, R, Hasher>, 3> {
        #[inline]
        fn default() -> Self {
            Self {
                counter: Default::default(),
            }
        }
    }
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> PartialEq
    for MLE<LogLogBeta<P, B, R, Hasher>, 3> {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.counter == other.counter
        }
    }
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> Eq
    for MLE<LogLogBeta<P, B, R, Hasher>, 3> {}
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> BitOrAssign
    for MLE<LogLogBeta<P, B, R, Hasher>, 3> {
        #[inline]
        fn bitor_assign(&mut self, rhs: Self) {
            self.counter |= rhs.counter;
        }
    }
    #[cfg(feature = "serde")]
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> serde::Serialize
    for MLE<LogLogBeta<P, B, R, Hasher>, 3> {
        #[inline(always)]
        fn serialize<S: serde::Serializer>(
            &self,
            serializer: S,
        ) -> Result<S::Ok, S::Error> {
            use serde::ser::SerializeSeq;
            let mut seq = serializer.serialize_seq(Some(1 << P::EXPONENT))?;
            for register in self.registers().iter_registers() {
                seq.serialize_element(&register)?;
            }
            seq.end()
        }
    }
    #[cfg(feature = "serde")]
    impl<
        'de,
        P: Precision,
        B: Bits,
        R: Registers<P, B>,
        Hasher: HasherType,
    > serde::Deserialize<'de> for MLE<LogLogBeta<P, B, R, Hasher>, 3> {
        #[inline]
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            let mut registers: R = R::zeroed();
            let visitor = crate::serde::RegisterVisitor::<u8>::new(1 << P::EXPONENT);
            let mut iter = deserializer.deserialize_seq(visitor)?.into_iter();
            registers.apply(|_| iter.next().unwrap());
            if true {
                match (&iter.next(), &None) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                };
            }
            Ok(Self::from_registers(registers))
        }
    }
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> BitOr
    for MLE<LogLogBeta<P, B, R, Hasher>, 3> {
        type Output = Self;
        #[inline]
        fn bitor(self, rhs: Self) -> Self::Output {
            Self {
                counter: self.counter | rhs.counter,
            }
        }
    }
    impl<
        P: Precision,
        B: Bits,
        R: Registers<P, B>,
        Hasher: HasherType,
    > HyperLogLog<P, B, Hasher> for MLE<LogLogBeta<P, B, R, Hasher>, 3> {
        type Registers = R;
        #[inline]
        fn registers(&self) -> &Self::Registers {
            self.counter.registers()
        }
        #[inline]
        fn get_number_of_zero_registers(&self) -> <P as Precision>::NumberOfRegisters {
            self.counter.get_number_of_zero_registers()
        }
        #[inline]
        fn get_register(&self, index: P::NumberOfRegisters) -> u8 {
            self.counter.get_register(index)
        }
        #[inline]
        fn harmonic_sum(&self) -> f64 {
            self.counter.harmonic_sum()
        }
        #[inline]
        fn from_registers(registers: R) -> Self {
            Self {
                counter: HyperLogLog::from_registers(registers),
            }
        }
    }
    impl<P: Precision, B: Bits, Hasher: HasherType, R: Registers<P, B>> SetProperties
    for MLE<LogLogBeta<P, B, R, Hasher>, 3> {
        #[inline(always)]
        fn is_empty(&self) -> bool {
            self.counter.is_empty()
        }
        #[inline(always)]
        fn is_full(&self) -> bool {
            self.counter.is_full()
        }
    }
    impl<P: Precision, B: Bits, Hasher: HasherType, R: Registers<P, B>> MutableSet
    for MLE<LogLogBeta<P, B, R, Hasher>, 3> {
        #[inline(always)]
        fn clear(&mut self) {
            self.counter.clear()
        }
    }
    impl<
        P: Precision,
        B: Bits,
        Hasher: HasherType,
        R: Registers<P, B>,
        T: core::hash::Hash,
    > ApproximatedSet<T> for MLE<LogLogBeta<P, B, R, Hasher>, 3> {
        #[inline(always)]
        fn may_contain(&self, element: &T) -> bool {
            self.counter.may_contain(element)
        }
    }
    impl<
        P: Precision,
        B: Bits,
        Hasher: HasherType,
        R: Registers<P, B>,
        T: core::hash::Hash,
    > ExtendableApproximatedSet<T> for MLE<LogLogBeta<P, B, R, Hasher>, 3> {
        #[inline(always)]
        fn insert(&mut self, element: &T) -> bool {
            self.counter.insert(element)
        }
    }
    impl<
        P: Precision,
        B: Bits,
        Hasher: HasherType,
        R: Registers<P, B> + Words,
    > Hybridazable for MLE<LogLogBeta<P, B, R, Hasher>, 3> {
        type IterSortedHashes<'words> = core::iter::Take<R::WordIter<'words>>
        where
            Self: 'words;
        #[inline]
        fn is_hybrid(&self) -> bool {
            self.counter.is_hybrid()
        }
        #[inline]
        fn dehybridize(&mut self) {
            self.counter.dehybridize()
        }
        #[inline]
        fn new_hybrid() -> Self {
            Self {
                counter: Hybridazable::new_hybrid(),
            }
        }
        #[inline]
        fn number_of_hashes(&self) -> usize {
            self.counter.number_of_hashes()
        }
        #[inline]
        fn capacity(&self) -> usize {
            self.counter.capacity()
        }
        #[inline]
        fn contains<T: core::hash::Hash>(&self, element: &T) -> bool {
            Hybridazable::contains(&self.counter, element)
        }
        #[inline]
        fn clear_words(&mut self) {
            self.counter.clear_words()
        }
        #[inline]
        fn iter_sorted_hashes(&self) -> Self::IterSortedHashes<'_> {
            self.counter.iter_sorted_hashes()
        }
        #[inline]
        fn hybrid_insert<T: core::hash::Hash>(&mut self, element: &T) -> bool {
            self.counter.hybrid_insert(element)
        }
    }
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> Default
    for MLE<PlusPlus<P, B, R, Hasher>, 2> {
        #[inline]
        fn default() -> Self {
            Self {
                counter: Default::default(),
            }
        }
    }
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> PartialEq
    for MLE<PlusPlus<P, B, R, Hasher>, 2> {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.counter == other.counter
        }
    }
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> Eq
    for MLE<PlusPlus<P, B, R, Hasher>, 2> {}
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> BitOrAssign
    for MLE<PlusPlus<P, B, R, Hasher>, 2> {
        #[inline]
        fn bitor_assign(&mut self, rhs: Self) {
            self.counter |= rhs.counter;
        }
    }
    #[cfg(feature = "serde")]
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> serde::Serialize
    for MLE<PlusPlus<P, B, R, Hasher>, 2> {
        #[inline(always)]
        fn serialize<S: serde::Serializer>(
            &self,
            serializer: S,
        ) -> Result<S::Ok, S::Error> {
            use serde::ser::SerializeSeq;
            let mut seq = serializer.serialize_seq(Some(1 << P::EXPONENT))?;
            for register in self.registers().iter_registers() {
                seq.serialize_element(&register)?;
            }
            seq.end()
        }
    }
    #[cfg(feature = "serde")]
    impl<
        'de,
        P: Precision,
        B: Bits,
        R: Registers<P, B>,
        Hasher: HasherType,
    > serde::Deserialize<'de> for MLE<PlusPlus<P, B, R, Hasher>, 2> {
        #[inline]
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            let mut registers: R = R::zeroed();
            let visitor = crate::serde::RegisterVisitor::<u8>::new(1 << P::EXPONENT);
            let mut iter = deserializer.deserialize_seq(visitor)?.into_iter();
            registers.apply(|_| iter.next().unwrap());
            if true {
                match (&iter.next(), &None) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                };
            }
            Ok(Self::from_registers(registers))
        }
    }
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> BitOr
    for MLE<PlusPlus<P, B, R, Hasher>, 2> {
        type Output = Self;
        #[inline]
        fn bitor(self, rhs: Self) -> Self::Output {
            Self {
                counter: self.counter | rhs.counter,
            }
        }
    }
    impl<
        P: Precision,
        B: Bits,
        R: Registers<P, B>,
        Hasher: HasherType,
    > HyperLogLog<P, B, Hasher> for MLE<PlusPlus<P, B, R, Hasher>, 2> {
        type Registers = R;
        #[inline]
        fn registers(&self) -> &Self::Registers {
            self.counter.registers()
        }
        #[inline]
        fn get_number_of_zero_registers(&self) -> <P as Precision>::NumberOfRegisters {
            self.counter.get_number_of_zero_registers()
        }
        #[inline]
        fn get_register(&self, index: P::NumberOfRegisters) -> u8 {
            self.counter.get_register(index)
        }
        #[inline]
        fn harmonic_sum(&self) -> f64 {
            self.counter.harmonic_sum()
        }
        #[inline]
        fn from_registers(registers: R) -> Self {
            Self {
                counter: HyperLogLog::from_registers(registers),
            }
        }
    }
    impl<P: Precision, B: Bits, Hasher: HasherType, R: Registers<P, B>> SetProperties
    for MLE<PlusPlus<P, B, R, Hasher>, 2> {
        #[inline(always)]
        fn is_empty(&self) -> bool {
            self.counter.is_empty()
        }
        #[inline(always)]
        fn is_full(&self) -> bool {
            self.counter.is_full()
        }
    }
    impl<P: Precision, B: Bits, Hasher: HasherType, R: Registers<P, B>> MutableSet
    for MLE<PlusPlus<P, B, R, Hasher>, 2> {
        #[inline(always)]
        fn clear(&mut self) {
            self.counter.clear()
        }
    }
    impl<
        P: Precision,
        B: Bits,
        Hasher: HasherType,
        R: Registers<P, B>,
        T: core::hash::Hash,
    > ApproximatedSet<T> for MLE<PlusPlus<P, B, R, Hasher>, 2> {
        #[inline(always)]
        fn may_contain(&self, element: &T) -> bool {
            self.counter.may_contain(element)
        }
    }
    impl<
        P: Precision,
        B: Bits,
        Hasher: HasherType,
        R: Registers<P, B>,
        T: core::hash::Hash,
    > ExtendableApproximatedSet<T> for MLE<PlusPlus<P, B, R, Hasher>, 2> {
        #[inline(always)]
        fn insert(&mut self, element: &T) -> bool {
            self.counter.insert(element)
        }
    }
    impl<
        P: Precision,
        B: Bits,
        Hasher: HasherType,
        R: Registers<P, B> + Words,
    > Hybridazable for MLE<PlusPlus<P, B, R, Hasher>, 2> {
        type IterSortedHashes<'words> = core::iter::Take<R::WordIter<'words>>
        where
            Self: 'words;
        #[inline]
        fn is_hybrid(&self) -> bool {
            self.counter.is_hybrid()
        }
        #[inline]
        fn dehybridize(&mut self) {
            self.counter.dehybridize()
        }
        #[inline]
        fn new_hybrid() -> Self {
            Self {
                counter: Hybridazable::new_hybrid(),
            }
        }
        #[inline]
        fn number_of_hashes(&self) -> usize {
            self.counter.number_of_hashes()
        }
        #[inline]
        fn capacity(&self) -> usize {
            self.counter.capacity()
        }
        #[inline]
        fn contains<T: core::hash::Hash>(&self, element: &T) -> bool {
            Hybridazable::contains(&self.counter, element)
        }
        #[inline]
        fn clear_words(&mut self) {
            self.counter.clear_words()
        }
        #[inline]
        fn iter_sorted_hashes(&self) -> Self::IterSortedHashes<'_> {
            self.counter.iter_sorted_hashes()
        }
        #[inline]
        fn hybrid_insert<T: core::hash::Hash>(&mut self, element: &T) -> bool {
            self.counter.hybrid_insert(element)
        }
    }
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> Default
    for MLE<PlusPlus<P, B, R, Hasher>, 3> {
        #[inline]
        fn default() -> Self {
            Self {
                counter: Default::default(),
            }
        }
    }
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> PartialEq
    for MLE<PlusPlus<P, B, R, Hasher>, 3> {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.counter == other.counter
        }
    }
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> Eq
    for MLE<PlusPlus<P, B, R, Hasher>, 3> {}
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> BitOrAssign
    for MLE<PlusPlus<P, B, R, Hasher>, 3> {
        #[inline]
        fn bitor_assign(&mut self, rhs: Self) {
            self.counter |= rhs.counter;
        }
    }
    #[cfg(feature = "serde")]
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> serde::Serialize
    for MLE<PlusPlus<P, B, R, Hasher>, 3> {
        #[inline(always)]
        fn serialize<S: serde::Serializer>(
            &self,
            serializer: S,
        ) -> Result<S::Ok, S::Error> {
            use serde::ser::SerializeSeq;
            let mut seq = serializer.serialize_seq(Some(1 << P::EXPONENT))?;
            for register in self.registers().iter_registers() {
                seq.serialize_element(&register)?;
            }
            seq.end()
        }
    }
    #[cfg(feature = "serde")]
    impl<
        'de,
        P: Precision,
        B: Bits,
        R: Registers<P, B>,
        Hasher: HasherType,
    > serde::Deserialize<'de> for MLE<PlusPlus<P, B, R, Hasher>, 3> {
        #[inline]
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            let mut registers: R = R::zeroed();
            let visitor = crate::serde::RegisterVisitor::<u8>::new(1 << P::EXPONENT);
            let mut iter = deserializer.deserialize_seq(visitor)?.into_iter();
            registers.apply(|_| iter.next().unwrap());
            if true {
                match (&iter.next(), &None) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                };
            }
            Ok(Self::from_registers(registers))
        }
    }
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> BitOr
    for MLE<PlusPlus<P, B, R, Hasher>, 3> {
        type Output = Self;
        #[inline]
        fn bitor(self, rhs: Self) -> Self::Output {
            Self {
                counter: self.counter | rhs.counter,
            }
        }
    }
    impl<
        P: Precision,
        B: Bits,
        R: Registers<P, B>,
        Hasher: HasherType,
    > HyperLogLog<P, B, Hasher> for MLE<PlusPlus<P, B, R, Hasher>, 3> {
        type Registers = R;
        #[inline]
        fn registers(&self) -> &Self::Registers {
            self.counter.registers()
        }
        #[inline]
        fn get_number_of_zero_registers(&self) -> <P as Precision>::NumberOfRegisters {
            self.counter.get_number_of_zero_registers()
        }
        #[inline]
        fn get_register(&self, index: P::NumberOfRegisters) -> u8 {
            self.counter.get_register(index)
        }
        #[inline]
        fn harmonic_sum(&self) -> f64 {
            self.counter.harmonic_sum()
        }
        #[inline]
        fn from_registers(registers: R) -> Self {
            Self {
                counter: HyperLogLog::from_registers(registers),
            }
        }
    }
    impl<P: Precision, B: Bits, Hasher: HasherType, R: Registers<P, B>> SetProperties
    for MLE<PlusPlus<P, B, R, Hasher>, 3> {
        #[inline(always)]
        fn is_empty(&self) -> bool {
            self.counter.is_empty()
        }
        #[inline(always)]
        fn is_full(&self) -> bool {
            self.counter.is_full()
        }
    }
    impl<P: Precision, B: Bits, Hasher: HasherType, R: Registers<P, B>> MutableSet
    for MLE<PlusPlus<P, B, R, Hasher>, 3> {
        #[inline(always)]
        fn clear(&mut self) {
            self.counter.clear()
        }
    }
    impl<
        P: Precision,
        B: Bits,
        Hasher: HasherType,
        R: Registers<P, B>,
        T: core::hash::Hash,
    > ApproximatedSet<T> for MLE<PlusPlus<P, B, R, Hasher>, 3> {
        #[inline(always)]
        fn may_contain(&self, element: &T) -> bool {
            self.counter.may_contain(element)
        }
    }
    impl<
        P: Precision,
        B: Bits,
        Hasher: HasherType,
        R: Registers<P, B>,
        T: core::hash::Hash,
    > ExtendableApproximatedSet<T> for MLE<PlusPlus<P, B, R, Hasher>, 3> {
        #[inline(always)]
        fn insert(&mut self, element: &T) -> bool {
            self.counter.insert(element)
        }
    }
    impl<
        P: Precision,
        B: Bits,
        Hasher: HasherType,
        R: Registers<P, B> + Words,
    > Hybridazable for MLE<PlusPlus<P, B, R, Hasher>, 3> {
        type IterSortedHashes<'words> = core::iter::Take<R::WordIter<'words>>
        where
            Self: 'words;
        #[inline]
        fn is_hybrid(&self) -> bool {
            self.counter.is_hybrid()
        }
        #[inline]
        fn dehybridize(&mut self) {
            self.counter.dehybridize()
        }
        #[inline]
        fn new_hybrid() -> Self {
            Self {
                counter: Hybridazable::new_hybrid(),
            }
        }
        #[inline]
        fn number_of_hashes(&self) -> usize {
            self.counter.number_of_hashes()
        }
        #[inline]
        fn capacity(&self) -> usize {
            self.counter.capacity()
        }
        #[inline]
        fn contains<T: core::hash::Hash>(&self, element: &T) -> bool {
            Hybridazable::contains(&self.counter, element)
        }
        #[inline]
        fn clear_words(&mut self) {
            self.counter.clear_words()
        }
        #[inline]
        fn iter_sorted_hashes(&self) -> Self::IterSortedHashes<'_> {
            self.counter.iter_sorted_hashes()
        }
        #[inline]
        fn hybrid_insert<T: core::hash::Hash>(&mut self, element: &T) -> bool {
            self.counter.hybrid_insert(element)
        }
    }
    impl<H, const ERROR: i32> From<H> for MLE<H, ERROR> {
        #[inline]
        fn from(counter: H) -> Self {
            Self { counter }
        }
    }
    #[cfg(feature = "std")]
    impl<const ERROR: i32, H: Named> Named for MLE<H, ERROR> {
        #[inline]
        fn name(&self) -> String {
            ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("MLE{0}{1}", ERROR, self.counter.name()),
                );
                res
            })
        }
    }
    /// Compute the union cardinality using the Maximum Likelihood Estimation.
    fn mle_union_cardinality<
        P: Precision,
        B: Bits,
        Hasher: HasherType,
        H: HyperLogLog<P, B, Hasher> + Estimator<f64>,
        const ERROR: i32,
    >(left: &H, right: &H, estimate: fn(f64, P::NumberOfRegisters) -> f64) -> f64 {
        let mut left_multiplicities_larger = ::alloc::vec::from_elem(
            f64::ZERO,
            usize::from(maximal_multeplicity(P::EXPONENT, B::NUMBER_OF_BITS)),
        );
        let mut left_multiplicities_smaller = ::alloc::vec::from_elem(
            f64::ZERO,
            usize::from(maximal_multeplicity(P::EXPONENT, B::NUMBER_OF_BITS)),
        );
        let mut right_multiplicities_larger = ::alloc::vec::from_elem(
            f64::ZERO,
            usize::from(maximal_multeplicity(P::EXPONENT, B::NUMBER_OF_BITS)),
        );
        let mut right_multiplicities_smaller = ::alloc::vec::from_elem(
            f64::ZERO,
            usize::from(maximal_multeplicity(P::EXPONENT, B::NUMBER_OF_BITS)),
        );
        let mut joint_multiplicities = ::alloc::vec::from_elem(
            f64::ZERO,
            usize::from(maximal_multeplicity(P::EXPONENT, B::NUMBER_OF_BITS)),
        );
        let mut union_harmonic_sum = f64::ZERO;
        let mut union_zeros = P::NumberOfRegisters::ZERO;
        for (left_register, right_register) in left
            .registers()
            .iter_registers_zipped(right.registers())
        {
            let larger_register = match left_register.cmp(&right_register) {
                Ordering::Less => {
                    left_multiplicities_smaller[usize::from(left_register)] += f64::ONE;
                    right_multiplicities_larger[usize::from(right_register)] += f64::ONE;
                    right_register
                }
                Ordering::Greater => {
                    left_multiplicities_larger[usize::from(left_register)] += f64::ONE;
                    right_multiplicities_smaller[usize::from(right_register)]
                        += f64::ONE;
                    left_register
                }
                Ordering::Equal => {
                    joint_multiplicities[usize::from(left_register)] += f64::ONE;
                    left_register
                }
            };
            union_harmonic_sum += f64::integer_exp2_minus(larger_register);
            union_zeros += P::NumberOfRegisters::from_bool(larger_register.is_zero());
        }
        let union_cardinality_estimate = estimate(union_harmonic_sum, union_zeros);
        let left_cardinality_estimate = left.estimate_cardinality();
        let right_cardinality_estimate = right.estimate_cardinality();
        if union_zeros == P::NUMBER_OF_REGISTERS {
            return f64::ZERO;
        }
        let intersection: f64 = (left_cardinality_estimate + right_cardinality_estimate
            - union_cardinality_estimate)
            .max(f64::EPSILON);
        let left_difference: f64 = (union_cardinality_estimate
            - right_cardinality_estimate)
            .max(f64::EPSILON);
        let right_difference: f64 = (union_cardinality_estimate
            - left_cardinality_estimate)
            .max(f64::EPSILON);
        let relative_error_limit = 10.0_f64.powi(-ERROR)
            / f64::integer_exp2(P::EXPONENT).sqrt();
        let x = |phi: f64, two_to_minus_register: f64| -> f64 {
            phi.exp() * two_to_minus_register
        };
        let yz = |x: f64| -> (f64, f64) {
            let exp_m1 = (-x).exp_m1();
            (f64::ONE + exp_m1, -exp_m1)
        };
        let q_plus_one: u8 = maximal_multeplicity(P::EXPONENT, B::NUMBER_OF_BITS) - 1;
        let q: u8 = q_plus_one - 1;
        let mut phis = [left_difference.ln(), right_difference.ln(), intersection.ln()];
        let mut gradients: [f64; 3] = [f64::ZERO, f64::ZERO, f64::ZERO];
        let mut optimizer: Adam<3> = Adam::default();
        let left_number_of_zeros = left_multiplicities_smaller[0]
            + left_multiplicities_larger[0] + joint_multiplicities[0];
        let right_number_of_zeros = right_multiplicities_smaller[0]
            + right_multiplicities_larger[0] + joint_multiplicities[0];
        let intersection_number_of_zeros = right_multiplicities_smaller[0]
            + left_multiplicities_smaller[0] + joint_multiplicities[0];
        let left_number_of_saturated_registers = left_multiplicities_larger[left_multiplicities_larger
            .len() - 1];
        let right_number_of_saturated_registers = right_multiplicities_larger[right_multiplicities_larger
            .len() - 1];
        let intersection_number_of_saturated_registers = joint_multiplicities[joint_multiplicities
            .len() - 1];
        let two_to_zero: f64 = f64::integer_exp2_minus(P::EXPONENT);
        let two_to_minus_q: f64 = f64::integer_exp2_minus(P::EXPONENT + q);
        for _ in 0_u16..10_000_u16 {
            let x_left_0 = x(phis[0], two_to_zero);
            let x_right_0 = x(phis[1], two_to_zero);
            let x_joint_0 = x(phis[2], two_to_zero);
            let x_left_q = x(phis[0], two_to_minus_q);
            let (y_left_q, z_left_q) = yz(x_left_q);
            let x_right_q = x(phis[1], two_to_minus_q);
            let (y_right_q, z_right_q) = yz(x_right_q);
            let x_joint_q = x(phis[2], two_to_minus_q);
            let (y_joint_q, z_joint_q) = yz(x_joint_q);
            let denominator = f64::ONE / (z_joint_q + y_joint_q * z_left_q * z_right_q);
            let xl_yl_q = x_left_q * y_left_q;
            let xr_yr_q = x_right_q * y_right_q;
            let xj_yjoint_q = x_joint_q * y_joint_q;
            let shared_factor = if intersection_number_of_saturated_registers > f64::ZERO
                && y_joint_q > f64::EPSILON
            {
                intersection_number_of_saturated_registers * y_joint_q * denominator
            } else {
                f64::ZERO
            };
            gradients[0] = if xl_yl_q > f64::EPSILON {
                xl_yl_q
                    * (shared_factor * z_right_q
                        + left_number_of_saturated_registers / z_left_q)
            } else {
                f64::ZERO
            };
            gradients[0] -= left_number_of_zeros * x_left_0;
            gradients[1] = if xr_yr_q > f64::EPSILON {
                xr_yr_q
                    * (shared_factor * z_left_q
                        + right_number_of_saturated_registers / z_right_q)
            } else {
                f64::ZERO
            };
            gradients[1] -= right_number_of_zeros * x_right_0;
            gradients[2] = if intersection_number_of_saturated_registers > f64::ZERO
                && xj_yjoint_q > f64::EPSILON && denominator.is_finite()
            {
                intersection_number_of_saturated_registers * xj_yjoint_q
                    * (y_left_q + z_left_q * y_right_q) * denominator
            } else {
                f64::ZERO
            };
            gradients[2] -= intersection_number_of_zeros * x_joint_0;
            (1..q_plus_one)
                .for_each(|register_value| {
                    let two_to_minus_register = f64::integer_exp2_minus(
                        P::EXPONENT + register_value,
                    );
                    let x_left = x(phis[0], two_to_minus_register);
                    let x_right = x(phis[1], two_to_minus_register);
                    let x_joint = x(phis[2], two_to_minus_register);
                    let (y_left, z_left) = yz(x_left);
                    let (y_right, z_right) = yz(x_right);
                    let (y_joint, z_joint) = yz(x_joint);
                    let joint_k = joint_multiplicities[usize::from(register_value)];
                    let left_smaller_k = left_multiplicities_smaller[usize::from(
                        register_value,
                    )];
                    let left_larger_k = left_multiplicities_larger[usize::from(
                        register_value,
                    )];
                    let right_smaller_k = right_multiplicities_smaller[usize::from(
                        register_value,
                    )];
                    let right_larger_k = right_multiplicities_larger[usize::from(
                        register_value,
                    )];
                    let yjoint_zleft = y_joint * z_left;
                    let yjoint_right_zleft = yjoint_zleft * y_right;
                    let yjoint_zright = y_joint * z_right;
                    let yjointleft_zright = yjoint_zright * y_left;
                    let yjointleft = y_joint * y_left;
                    let yjointright = y_joint * y_right;
                    let yjoint_zlr = yjoint_zleft * z_right;
                    let mut zj_plus_yjoint_zleft = z_joint + yjoint_zleft;
                    if zj_plus_yjoint_zleft < f64::EPSILON {
                        zj_plus_yjoint_zleft = f64::EPSILON;
                    }
                    let reciprocal_zj_plus_yjoint_zleft = f64::ONE
                        / zj_plus_yjoint_zleft;
                    let mut zj_plus_yjoint_zright = z_joint + yjoint_zright;
                    if zj_plus_yjoint_zright < f64::EPSILON {
                        zj_plus_yjoint_zright = f64::EPSILON;
                    }
                    let reciprocal_zj_plus_yjoint_zright = f64::ONE
                        / zj_plus_yjoint_zright;
                    let mut zj_plus_yjoint_zlr = z_joint + yjoint_zlr;
                    if zj_plus_yjoint_zlr < f64::EPSILON {
                        zj_plus_yjoint_zlr = f64::EPSILON;
                    }
                    let reciprocal_zj_plus_yjoint_zlr = f64::ONE / zj_plus_yjoint_zlr;
                    let left_reciprocal = left_smaller_k
                        * (reciprocal_zj_plus_yjoint_zleft * yjointleft - f64::ONE);
                    let right_reciprocal = right_smaller_k
                        * (reciprocal_zj_plus_yjoint_zright * yjointright - f64::ONE);
                    if x_left > f64::EPSILON {
                        gradients[0]
                            += x_left
                                * (left_reciprocal
                                    + joint_k
                                        * (yjointleft_zright * reciprocal_zj_plus_yjoint_zlr
                                            - f64::ONE) + left_larger_k * (y_left / z_left - f64::ONE));
                    }
                    if x_right > f64::EPSILON {
                        gradients[1]
                            += x_right
                                * (right_reciprocal
                                    + joint_k
                                        * (yjoint_right_zleft * reciprocal_zj_plus_yjoint_zlr
                                            - f64::ONE)
                                    + right_larger_k * (y_right / z_right - f64::ONE));
                    }
                    if x_joint > f64::EPSILON {
                        gradients[2]
                            += x_joint
                                * (left_reciprocal + right_reciprocal
                                    + joint_k
                                        * ((yjointleft + yjoint_right_zleft)
                                            * reciprocal_zj_plus_yjoint_zlr - f64::ONE));
                    }
                });
            optimizer.apply(&mut gradients, &mut phis);
            if gradients.iter().all(|gradient| gradient.abs() <= relative_error_limit) {
                break;
            }
        }
        phis[0].exp() + phis[1].exp() + phis[2].exp()
    }
    impl<
        const ERROR: i32,
        P: Precision,
        B: Bits,
        R: Registers<P, B>,
        Hasher: HasherType,
    > Estimator<f64> for MLE<LogLogBeta<P, B, R, Hasher>, ERROR>
    where
        Self: HyperLogLog<P, B, Hasher>,
    {
        #[inline]
        fn estimate_cardinality(&self) -> f64 {
            self.counter.estimate_cardinality()
        }
        #[inline]
        fn is_union_estimate_non_deterministic(&self, _other: &Self) -> bool {
            true
        }
        #[inline]
        fn estimate_union_cardinality(&self, other: &Self) -> f64 {
            mle_union_cardinality::<
                P,
                B,
                Hasher,
                LogLogBeta<P, B, R, Hasher>,
                ERROR,
            >(&self.counter, &other.counter, P::beta_estimate)
        }
    }
    impl<
        const ERROR: i32,
        P: Precision,
        B: Bits,
        R: Registers<P, B>,
        Hasher: HasherType,
    > Estimator<f64> for MLE<PlusPlus<P, B, R, Hasher>, ERROR>
    where
        Self: HyperLogLog<P, B, Hasher>,
    {
        #[inline]
        fn estimate_cardinality(&self) -> f64 {
            self.counter.estimate_cardinality()
        }
        #[inline]
        fn is_union_estimate_non_deterministic(&self, _other: &Self) -> bool {
            true
        }
        #[inline]
        fn estimate_union_cardinality(&self, other: &Self) -> f64 {
            mle_union_cardinality::<
                P,
                B,
                Hasher,
                PlusPlus<P, B, R, Hasher>,
                ERROR,
            >(&self.counter, &other.counter, P::plusplus_estimate)
        }
    }
    /// Adam optimizer for the Maximum Likelihood Estimation.
    struct Adam<const N: usize> {
        /// First moments.
        first_moments: [f64; N],
        /// Second moments.
        second_moments: [f64; N],
        /// Current time.
        time: i32,
        /// Learning rate.
        learning_rate: f64,
        /// First order decay factor.
        first_order_decay_factor: f64,
        /// Second order decay factor.
        second_order_decay_factor: f64,
    }
    impl<const N: usize> Default for Adam<N> {
        fn default() -> Self {
            Adam {
                first_moments: [0.0; N],
                second_moments: [0.0; N],
                time: 0,
                learning_rate: 0.01,
                first_order_decay_factor: 0.9,
                second_order_decay_factor: 0.999,
            }
        }
    }
    impl<const N: usize> Adam<N> {
        /// Apply the Adam optimizer to the gradients and weights.
        fn apply(&mut self, gradients: &mut [f64; N], phis: &mut [f64; N]) {
            self.time += 1_i32;
            self.first_moments
                .iter_mut()
                .zip(self.second_moments.iter_mut())
                .zip(gradients.iter_mut().zip(phis.iter_mut()))
                .for_each(|((first_moment, second_moment), (gradient, phi))| {
                    *first_moment = self.first_order_decay_factor * *first_moment
                        + (f64::ONE - self.first_order_decay_factor) * *gradient;
                    *second_moment = self.second_order_decay_factor * *second_moment
                        + (f64::ONE - self.second_order_decay_factor)
                            * (*gradient).powi(2);
                    let adaptative_learning_rate = self.learning_rate
                        * (f64::ONE - self.second_order_decay_factor.powi(self.time))
                            .sqrt()
                        / (f64::ONE - self.first_order_decay_factor.powi(self.time));
                    let second_moment_root = (*second_moment).sqrt();
                    *gradient = adaptative_learning_rate * (*first_moment)
                        / if second_moment_root > f64::EPSILON {
                            second_moment_root
                        } else {
                            f64::EPSILON
                        };
                    *phi += *gradient;
                });
        }
    }
}
#[cfg(feature = "plusplus")]
mod plusplus {
    //! Submodule implementing `HyperLogLog++`.
    use crate::basicloglog::BasicLogLog;
    use crate::hll_impl;
    use crate::prelude::*;
    use core::any::type_name;
    /// A struct implementing the `HyperLogLog++` algorithm.
    pub struct PlusPlus<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> {
        /// The underlying `BasicLogLog` counter.
        counter: BasicLogLog<P, B, R, Hasher>,
    }
    #[automatically_derived]
    impl<
        P: Precision,
        B: Bits,
        R: Registers<P, B>,
        Hasher: HasherType,
    > mem_dbg::MemDbgImpl for PlusPlus<P, B, R, Hasher>
    where
        BasicLogLog<P, B, R, Hasher>: mem_dbg::MemDbgImpl,
    {
        #[inline(always)]
        fn _mem_dbg_rec_on(
            &self,
            _memdbg_writer: &mut impl core::fmt::Write,
            _memdbg_total_size: usize,
            _memdbg_max_depth: usize,
            _memdbg_prefix: &mut String,
            _memdbg_is_last: bool,
            _memdbg_flags: mem_dbg::DbgFlags,
        ) -> core::fmt::Result {
            let mut id_sizes: Vec<(usize, usize)> = ::alloc::vec::Vec::new();
            id_sizes
                .push((
                    0usize,
                    { builtin # offset_of(PlusPlus < P, B, R, Hasher >, counter) },
                ));
            let n = id_sizes.len();
            id_sizes.push((n, core::mem::size_of::<Self>()));
            id_sizes.sort_by_key(|x| x.1);
            for i in 0..n {
                id_sizes[i].1 = id_sizes[i + 1].1 - id_sizes[i].1;
            }
            if !_memdbg_flags.contains(mem_dbg::DbgFlags::RUST_LAYOUT) {
                id_sizes.sort_by_key(|x| x.0);
            }
            for (i, (field_idx, padded_size)) in id_sizes.into_iter().enumerate().take(n)
            {
                match field_idx {
                    0usize => {
                        <BasicLogLog<
                            P,
                            B,
                            R,
                            Hasher,
                        > as mem_dbg::MemDbgImpl>::_mem_dbg_depth_on(
                            &self.counter,
                            _memdbg_writer,
                            _memdbg_total_size,
                            _memdbg_max_depth,
                            _memdbg_prefix,
                            Some("counter"),
                            i == n - 1,
                            padded_size,
                            _memdbg_flags,
                        )?
                    }
                    _ => {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                }
            }
            Ok(())
        }
    }
    #[automatically_derived]
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> mem_dbg::CopyType
    for PlusPlus<P, B, R, Hasher>
    where
        BasicLogLog<P, B, R, Hasher>: mem_dbg::MemSize,
    {
        type Copy = mem_dbg::False;
    }
    #[automatically_derived]
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> mem_dbg::MemSize
    for PlusPlus<P, B, R, Hasher>
    where
        BasicLogLog<P, B, R, Hasher>: mem_dbg::MemSize,
    {
        fn mem_size(&self, _memsize_flags: mem_dbg::SizeFlags) -> usize {
            let mut bytes = core::mem::size_of::<Self>();
            bytes
                += <BasicLogLog<
                    P,
                    B,
                    R,
                    Hasher,
                > as mem_dbg::MemSize>::mem_size(&self.counter, _memsize_flags)
                    - core::mem::size_of::<BasicLogLog<P, B, R, Hasher>>();
            bytes
        }
    }
    #[automatically_derived]
    impl<
        P: ::core::fmt::Debug + Precision,
        B: ::core::fmt::Debug + Bits,
        R: ::core::fmt::Debug + Registers<P, B>,
        Hasher: ::core::fmt::Debug + HasherType,
    > ::core::fmt::Debug for PlusPlus<P, B, R, Hasher> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field1_finish(
                f,
                "PlusPlus",
                "counter",
                &&self.counter,
            )
        }
    }
    #[automatically_derived]
    impl<
        P: ::core::clone::Clone + Precision,
        B: ::core::clone::Clone + Bits,
        R: ::core::clone::Clone + Registers<P, B>,
        Hasher: ::core::clone::Clone + HasherType,
    > ::core::clone::Clone for PlusPlus<P, B, R, Hasher> {
        #[inline]
        fn clone(&self) -> PlusPlus<P, B, R, Hasher> {
            PlusPlus {
                counter: ::core::clone::Clone::clone(&self.counter),
            }
        }
    }
    #[automatically_derived]
    impl<
        P: ::core::marker::Copy + Precision,
        B: ::core::marker::Copy + Bits,
        R: ::core::marker::Copy + Registers<P, B>,
        Hasher: ::core::marker::Copy + HasherType,
    > ::core::marker::Copy for PlusPlus<P, B, R, Hasher> {}
    #[cfg(feature = "std")]
    impl<
        P: Precision + Named,
        B: Bits + Named,
        R: Registers<P, B> + Named,
        Hasher: HasherType,
    > Named for PlusPlus<P, B, R, Hasher> {
        #[inline]
        fn name(&self) -> String {
            #[cfg(
                all(not(feature = "integer_plusplus"), not(feature = "plusplus_kmeans"))
            )]
            let model_name = "PP";
            ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!(
                        "{4}<{0}, {1}, {2}> + {3}",
                        P::default().name(),
                        B::default().name(),
                        self.registers().name(),
                        type_name::<Hasher>().split("::").last().unwrap(),
                        model_name,
                    ),
                );
                res
            })
        }
    }
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> Default
    for PlusPlus<P, B, R, Hasher> {
        #[inline]
        fn default() -> Self {
            Self {
                counter: Default::default(),
            }
        }
    }
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> PartialEq
    for PlusPlus<P, B, R, Hasher> {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.counter == other.counter
        }
    }
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> Eq
    for PlusPlus<P, B, R, Hasher> {}
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> BitOrAssign
    for PlusPlus<P, B, R, Hasher> {
        #[inline]
        fn bitor_assign(&mut self, rhs: Self) {
            self.counter |= rhs.counter;
        }
    }
    #[cfg(feature = "serde")]
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> serde::Serialize
    for PlusPlus<P, B, R, Hasher> {
        #[inline(always)]
        fn serialize<S: serde::Serializer>(
            &self,
            serializer: S,
        ) -> Result<S::Ok, S::Error> {
            use serde::ser::SerializeSeq;
            let mut seq = serializer.serialize_seq(Some(1 << P::EXPONENT))?;
            for register in self.registers().iter_registers() {
                seq.serialize_element(&register)?;
            }
            seq.end()
        }
    }
    #[cfg(feature = "serde")]
    impl<
        'de,
        P: Precision,
        B: Bits,
        R: Registers<P, B>,
        Hasher: HasherType,
    > serde::Deserialize<'de> for PlusPlus<P, B, R, Hasher> {
        #[inline]
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            let mut registers: R = R::zeroed();
            let visitor = crate::serde::RegisterVisitor::<u8>::new(1 << P::EXPONENT);
            let mut iter = deserializer.deserialize_seq(visitor)?.into_iter();
            registers.apply(|_| iter.next().unwrap());
            if true {
                match (&iter.next(), &None) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                };
            }
            Ok(Self::from_registers(registers))
        }
    }
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> BitOr
    for PlusPlus<P, B, R, Hasher> {
        type Output = Self;
        #[inline]
        fn bitor(self, rhs: Self) -> Self::Output {
            Self {
                counter: self.counter | rhs.counter,
            }
        }
    }
    impl<
        P: Precision,
        B: Bits,
        R: Registers<P, B>,
        Hasher: HasherType,
    > HyperLogLog<P, B, Hasher> for PlusPlus<P, B, R, Hasher> {
        type Registers = R;
        #[inline]
        fn registers(&self) -> &Self::Registers {
            self.counter.registers()
        }
        #[inline]
        fn get_number_of_zero_registers(&self) -> <P as Precision>::NumberOfRegisters {
            self.counter.get_number_of_zero_registers()
        }
        #[inline]
        fn get_register(&self, index: P::NumberOfRegisters) -> u8 {
            self.counter.get_register(index)
        }
        #[inline]
        fn harmonic_sum(&self) -> f64 {
            self.counter.harmonic_sum()
        }
        #[inline]
        fn from_registers(registers: R) -> Self {
            Self {
                counter: HyperLogLog::from_registers(registers),
            }
        }
    }
    impl<P: Precision, B: Bits, Hasher: HasherType, R: Registers<P, B>> SetProperties
    for PlusPlus<P, B, R, Hasher> {
        #[inline(always)]
        fn is_empty(&self) -> bool {
            self.counter.is_empty()
        }
        #[inline(always)]
        fn is_full(&self) -> bool {
            self.counter.is_full()
        }
    }
    impl<P: Precision, B: Bits, Hasher: HasherType, R: Registers<P, B>> MutableSet
    for PlusPlus<P, B, R, Hasher> {
        #[inline(always)]
        fn clear(&mut self) {
            self.counter.clear()
        }
    }
    impl<
        P: Precision,
        B: Bits,
        Hasher: HasherType,
        R: Registers<P, B>,
        T: core::hash::Hash,
    > ApproximatedSet<T> for PlusPlus<P, B, R, Hasher> {
        #[inline(always)]
        fn may_contain(&self, element: &T) -> bool {
            self.counter.may_contain(element)
        }
    }
    impl<
        P: Precision,
        B: Bits,
        Hasher: HasherType,
        R: Registers<P, B>,
        T: core::hash::Hash,
    > ExtendableApproximatedSet<T> for PlusPlus<P, B, R, Hasher> {
        #[inline(always)]
        fn insert(&mut self, element: &T) -> bool {
            self.counter.insert(element)
        }
    }
    impl<
        P: Precision,
        B: Bits,
        Hasher: HasherType,
        R: Registers<P, B> + Words,
    > Hybridazable for PlusPlus<P, B, R, Hasher> {
        type IterSortedHashes<'words> = core::iter::Take<R::WordIter<'words>>
        where
            Self: 'words;
        #[inline]
        fn is_hybrid(&self) -> bool {
            self.counter.is_hybrid()
        }
        #[inline]
        fn dehybridize(&mut self) {
            self.counter.dehybridize()
        }
        #[inline]
        fn new_hybrid() -> Self {
            Self {
                counter: Hybridazable::new_hybrid(),
            }
        }
        #[inline]
        fn number_of_hashes(&self) -> usize {
            self.counter.number_of_hashes()
        }
        #[inline]
        fn capacity(&self) -> usize {
            self.counter.capacity()
        }
        #[inline]
        fn contains<T: core::hash::Hash>(&self, element: &T) -> bool {
            Hybridazable::contains(&self.counter, element)
        }
        #[inline]
        fn clear_words(&mut self) {
            self.counter.clear_words()
        }
        #[inline]
        fn iter_sorted_hashes(&self) -> Self::IterSortedHashes<'_> {
            self.counter.iter_sorted_hashes()
        }
        #[inline]
        fn hybrid_insert<T: core::hash::Hash>(&mut self, element: &T) -> bool {
            self.counter.hybrid_insert(element)
        }
    }
    impl<
        P: Precision,
        B: Bits,
        R: Registers<P, B>,
        Hasher: HasherType,
    > From<BasicLogLog<P, B, R, Hasher>> for PlusPlus<P, B, R, Hasher> {
        #[inline]
        fn from(counter: BasicLogLog<P, B, R, Hasher>) -> Self {
            Self { counter }
        }
    }
    impl<P: Precision, B: Bits, R: Registers<P, B>, Hasher: HasherType> Estimator<f64>
    for PlusPlus<P, B, R, Hasher>
    where
        Self: HyperLogLog<P, B, Hasher>,
    {
        #[inline]
        fn estimate_cardinality(&self) -> f64 {
            P::plusplus_estimate(
                self.harmonic_sum(),
                self.get_number_of_zero_registers(),
            )
        }
        #[inline]
        fn estimate_union_cardinality(&self, other: &Self) -> f64 {
            let (harmonic_sum, number_of_zero_registers) = self
                .registers()
                .get_harmonic_sum_and_zeros(other.registers());
            correct_union_estimate(
                P::plusplus_estimate(
                    self.harmonic_sum(),
                    self.get_number_of_zero_registers(),
                ),
                P::plusplus_estimate(
                    other.harmonic_sum(),
                    other.get_number_of_zero_registers(),
                ),
                P::plusplus_estimate(harmonic_sum, number_of_zero_registers),
            )
        }
        #[inline]
        fn is_union_estimate_non_deterministic(&self, _other: &Self) -> bool {
            false
        }
    }
}
mod precisions {
    //! In this document, we define the precisions as a trait and we implement it for structs
    //! ranging from Precision4 to Precision16. This is necessary so that the compiler can
    //! know the size necessary to store the number of zeros, and allows us the save when using
    //! a number of registers equal of inferior to 256 a Byte, compared to what is possible when
    //! using a number of registers equal or inferior to 65536, which would make us waste another byte.
    use core::fmt::Debug;
    use crate::utils::{FloatOps, Number, One, PositiveInteger};
    #[cfg(feature = "plusplus")]
    use crate::utils::Two;
    #[cfg(all(feature = "beta", not(feature = "precomputed_beta")))]
    use crate::utils::Zero;
    /// Alpha constants for precision 4 used in [`HyperLogLog`].
    const ALPHA_4: f64 = 0.673;
    /// Alpha constants for precision 5 used in [`HyperLogLog`].
    const ALPHA_5: f64 = 0.697;
    /// Alpha constants for precision 6 used in [`HyperLogLog`].
    const ALPHA_6: f64 = 0.709;
    /// Alpha constants for precision 7 used in [`HyperLogLog`].
    const ALPHA_7: f64 = 0.715_270_493_264;
    /// Alpha constants for precision 8 used in [`HyperLogLog`].
    const ALPHA_8: f64 = 0.718_272_593_25;
    /// Alpha constants for precision 9 used in [`HyperLogLog`].
    const ALPHA_9: f64 = 0.719_783_113_322;
    /// Alpha constants for precision 10 used in [`HyperLogLog`].
    const ALPHA_10: f64 = 0.720_540_758_322;
    /// Smallest word-like data-type for the number of register used in [`Precision`] trait implementations.
    type NumberOfRegisters4 = u8;
    /// Smallest word-like data-type for the number of register used in [`Precision`] trait implementations.
    type NumberOfRegisters5 = u8;
    /// Smallest word-like data-type for the number of register used in [`Precision`] trait implementations.
    type NumberOfRegisters6 = u8;
    /// Smallest word-like data-type for the number of register used in [`Precision`] trait implementations.
    type NumberOfRegisters7 = u8;
    /// Smallest word-like data-type for the number of register used in [`Precision`] trait implementations.
    type NumberOfRegisters8 = u16;
    /// Smallest word-like data-type for the number of register used in [`Precision`] trait implementations.
    type NumberOfRegisters9 = u16;
    /// Smallest word-like data-type for the number of register used in [`Precision`] trait implementations.
    type NumberOfRegisters10 = u16;
    /// Estimates centroid type for precision 4 for [`PlusPlus`].
    type Estimates4 = [f64; 79];
    /// Bias centroid type for precision 4 for [`PlusPlus`].
    type Bias4 = [f64; 79];
    /// Estimates centroid type for precision 5 for [`PlusPlus`].
    type Estimates5 = [f64; 159];
    /// Bias centroid type for precision 5 for [`PlusPlus`].
    type Bias5 = [f64; 159];
    /// Estimates centroid type for precision 6 for [`PlusPlus`].
    type Estimates6 = [f64; 200];
    /// Bias centroid type for precision 6 for [`PlusPlus`].
    type Bias6 = [f64; 200];
    /// Estimates centroid type for precision 7 for [`PlusPlus`].
    type Estimates7 = [f64; 200];
    /// Bias centroid type for precision 7 for [`PlusPlus`].
    type Bias7 = [f64; 200];
    /// Estimates centroid type for precision 8 for [`PlusPlus`].
    type Estimates8 = [f64; 189];
    /// Bias centroid type for precision 8 for [`PlusPlus`].
    type Bias8 = [f64; 189];
    /// Estimates centroid type for precision 9 for [`PlusPlus`].
    type Estimates9 = [f64; 196];
    /// Bias centroid type for precision 9 for [`PlusPlus`].
    type Bias9 = [f64; 196];
    /// Estimates centroid type for precision 10 for [`PlusPlus`].
    type Estimates10 = [f64; 187];
    /// Bias centroid type for precision 10 for [`PlusPlus`].
    type Bias10 = [f64; 187];
    /// Biases aligned with estimates centroids for precision 4 for [`PlusPlus`].
    const BIAS_4: Bias4 = [
        10.0,
        9.717,
        9.207,
        8.79,
        8.288,
        7.82,
        7.377,
        6.934,
        6.52,
        6.161,
        5.772,
        5.464,
        5.04,
        4.677,
        4.357,
        4.045,
        3.794,
        3.486,
        3.267,
        2.995,
        2.766,
        2.469,
        2.364,
        2.076,
        1.786,
        1.76,
        1.481,
        1.433,
        1.293,
        1.066,
        1.0,
        0.796,
        0.537,
        0.589,
        0.574,
        0.27,
        0.368,
        0.054,
        0.234,
        0.011,
        -0.203,
        -0.07,
        -0.13,
        -0.364,
        -0.481,
        -0.227,
        -0.323,
        -0.383,
        -0.511,
        -0.67,
        -0.749,
        -0.5,
        -0.618,
        -0.692,
        -0.602,
        -0.416,
        -0.338,
        -0.783,
        -0.649,
        -0.92,
        -0.852,
        -0.962,
        -0.64,
        -1.192,
        -1.026,
        -1.086,
        -1.219,
        -0.819,
        -0.941,
        -1.155,
        -1.207,
        -1.175,
        -1.168,
        -1.14,
        -1.375,
        -1.299,
        -1.607,
        -1.329,
        -1.761,
    ];
    /// Biases aligned with estimates centroids for precision 5 for [`PlusPlus`].
    const BIAS_5: Bias5 = [
        22.0,
        21.119,
        20.821,
        20.232,
        19.77,
        19.244,
        18.777,
        18.285,
        17.822,
        17.374,
        16.934,
        16.503,
        16.049,
        15.629,
        15.212,
        14.798,
        14.367,
        13.973,
        13.594,
        13.217,
        12.844,
        12.37,
        12.096,
        11.704,
        11.324,
        11.067,
        10.67,
        10.364,
        10.049,
        9.692,
        9.415,
        9.082,
        8.687,
        8.54,
        8.246,
        7.857,
        7.661,
        7.417,
        7.125,
        6.922,
        6.68,
        6.447,
        6.345,
        5.959,
        5.764,
        5.578,
        5.331,
        5.19,
        4.968,
        4.756,
        4.531,
        4.444,
        4.371,
        3.977,
        3.962,
        3.88,
        3.755,
        3.472,
        3.208,
        3.102,
        2.891,
        2.734,
        2.773,
        2.629,
        2.413,
        2.327,
        2.152,
        2.264,
        2.181,
        2.057,
        1.919,
        1.76,
        1.352,
        1.58,
        1.439,
        1.492,
        1.152,
        1.189,
        0.841,
        0.88,
        0.838,
        0.47,
        0.766,
        0.331,
        0.591,
        0.601,
        0.702,
        0.558,
        0.339,
        0.354,
        0.491,
        0.308,
        0.355,
        -0.025,
        0.205,
        -0.273,
        0.132,
        0.394,
        -0.241,
        0.242,
        0.191,
        0.254,
        -0.122,
        -0.371,
        0.193,
        -0.085,
        0.087,
        -0.327,
        -0.286,
        0.311,
        -0.128,
        -0.755,
        -0.209,
        -0.294,
        -0.364,
        -0.254,
        -0.821,
        -0.254,
        -0.51,
        -0.383,
        -0.492,
        -0.22,
        -0.097,
        -0.557,
        -0.115,
        -0.295,
        -0.535,
        -0.654,
        0.346,
        0.04,
        -0.996,
        0.034,
        -0.523,
        -0.489,
        -0.275,
        -0.575,
        -0.483,
        0.057,
        -0.331,
        -0.629,
        -0.14,
        -0.541,
        -0.446,
        -0.599,
        -0.263,
        0.163,
        -0.101,
        -0.395,
        -1.07,
        -0.836,
        -0.753,
        -0.412,
        -0.79,
        -0.297,
        -0.285,
        -0.193,
        -0.077,
        -0.963,
        -0.415,
    ];
    /// Biases aligned with estimates centroids for precision 6 for [`PlusPlus`].
    const BIAS_6: Bias6 = [
        45.0,
        44.19,
        43.271,
        42.836,
        41.814,
        41.285,
        40.317,
        39.354,
        38.892,
        37.944,
        37.46,
        36.526,
        35.625,
        35.157,
        34.282,
        33.837,
        32.964,
        32.074,
        31.704,
        30.798,
        30.477,
        29.656,
        28.794,
        28.5,
        27.686,
        27.291,
        26.567,
        25.856,
        25.498,
        24.82,
        24.425,
        23.774,
        23.079,
        22.834,
        22.029,
        21.81,
        21.079,
        20.573,
        20.188,
        19.565,
        19.29,
        18.678,
        18.335,
        17.895,
        17.371,
        17.085,
        16.499,
        16.269,
        15.684,
        15.223,
        14.973,
        14.336,
        14.229,
        13.726,
        13.328,
        13.105,
        12.596,
        12.356,
        12.127,
        11.418,
        11.497,
        11.082,
        10.856,
        10.48,
        10.283,
        10.021,
        9.637,
        9.517,
        9.058,
        8.748,
        8.427,
        8.133,
        8.237,
        8.279,
        7.678,
        7.793,
        7.195,
        6.956,
        6.645,
        6.87,
        6.543,
        6.2,
        6.029,
        5.628,
        5.678,
        5.792,
        5.352,
        5.283,
        5.039,
        5.075,
        4.491,
        4.849,
        4.696,
        4.54,
        4.073,
        4.371,
        3.722,
        3.733,
        3.421,
        3.418,
        3.942,
        3.277,
        3.411,
        3.131,
        2.769,
        2.926,
        2.683,
        2.75,
        2.706,
        2.389,
        3.019,
        2.452,
        2.927,
        2.417,
        2.411,
        2.033,
        2.512,
        2.556,
        2.601,
        2.417,
        1.804,
        1.997,
        2.455,
        1.895,
        2.235,
        2.309,
        2.155,
        1.884,
        1.651,
        0.677,
        1.725,
        1.475,
        1.723,
        1.661,
        1.168,
        1.793,
        1.001,
        0.905,
        0.66,
        1.559,
        1.164,
        0.688,
        0.713,
        0.45,
        1.198,
        0.976,
        0.165,
        1.727,
        -0.253,
        1.197,
        1.135,
        1.305,
        1.195,
        0.313,
        0.879,
        1.12,
        0.853,
        1.679,
        0.857,
        0.449,
        1.236,
        0.953,
        1.029,
        0.563,
        0.663,
        0.723,
        0.757,
        -0.838,
        0.257,
        0.62,
        0.822,
        0.217,
        0.206,
        0.22,
        0.373,
        0.334,
        0.928,
        0.973,
        0.192,
        0.487,
        -0.413,
        0.807,
        0.121,
        0.769,
        0.871,
        0.665,
        0.118,
        0.401,
        0.635,
        0.135,
        0.176,
        1.161,
        0.346,
        0.521,
        -0.587,
        -1.165,
        0.968,
        0.837,
        0.78,
        0.986,
    ];
    /// Biases aligned with estimates centroids for precision 7 for [`PlusPlus`].
    const BIAS_7: Bias7 = [
        91.0,
        89.493,
        87.976,
        86.457,
        84.972,
        83.495,
        81.53,
        80.076,
        78.637,
        77.178,
        75.789,
        73.952,
        72.592,
        71.253,
        69.909,
        68.594,
        66.947,
        65.68,
        64.439,
        63.218,
        61.977,
        60.421,
        59.253,
        58.01,
        56.866,
        55.728,
        54.304,
        53.132,
        52.093,
        51.003,
        49.909,
        48.631,
        47.529,
        46.576,
        45.651,
        44.662,
        43.552,
        42.372,
        41.617,
        40.575,
        39.787,
        38.844,
        37.799,
        36.861,
        36.212,
        35.357,
        34.448,
        33.588,
        32.682,
        32.082,
        31.026,
        30.605,
        29.444,
        28.727,
        27.957,
        27.147,
        26.436,
        25.759,
        25.339,
        24.781,
        23.803,
        23.656,
        22.654,
        21.996,
        21.472,
        21.154,
        20.61,
        19.596,
        19.062,
        18.576,
        18.488,
        17.524,
        17.215,
        16.724,
        15.872,
        15.52,
        15.041,
        14.941,
        14.905,
        13.87,
        13.43,
        13.028,
        12.471,
        12.37,
        12.062,
        11.467,
        11.553,
        11.435,
        11.256,
        10.274,
        10.212,
        9.747,
        10.146,
        9.293,
        8.75,
        8.553,
        8.979,
        8.21,
        8.183,
        7.349,
        7.325,
        7.661,
        6.903,
        7.254,
        6.904,
        7.215,
        6.286,
        6.081,
        6.676,
        6.301,
        5.139,
        5.658,
        5.173,
        4.59,
        4.954,
        5.083,
        4.922,
        4.99,
        4.733,
        5.454,
        4.114,
        4.223,
        4.088,
        3.708,
        4.156,
        4.185,
        3.637,
        3.682,
        3.78,
        3.608,
        2.492,
        3.131,
        2.538,
        3.199,
        3.211,
        2.45,
        3.528,
        2.912,
        3.045,
        2.743,
        2.852,
        2.799,
        2.786,
        1.887,
        2.989,
        2.506,
        1.912,
        2.662,
        2.468,
        1.582,
        1.304,
        2.274,
        2.689,
        1.329,
        3.106,
        1.691,
        2.137,
        2.532,
        1.885,
        1.332,
        1.451,
        1.179,
        2.441,
        1.607,
        2.167,
        0.779,
        2.379,
        2.067,
        1.46,
        2.912,
        1.692,
        0.955,
        2.493,
        2.272,
        1.335,
        2.449,
        1.201,
        3.074,
        2.097,
        2.856,
        2.3,
        2.409,
        1.97,
        0.81,
        1.653,
        2.6,
        0.958,
        2.068,
        2.328,
        4.202,
        1.963,
        1.864,
        1.43,
        3.779,
        1.272,
        1.864,
        2.206,
        3.219,
        1.515,
        2.61,
    ];
    /// Biases aligned with estimates centroids for precision 8 for [`PlusPlus`].
    const BIAS_8: Bias8 = [
        149.27,
        146.518,
        143.441,
        140.803,
        138.163,
        135.169,
        132.607,
        129.695,
        127.266,
        124.823,
        122.043,
        119.682,
        116.946,
        114.627,
        112.263,
        109.838,
        107.403,
        104.896,
        102.852,
        100.764,
        98.355,
        96.356,
        93.753,
        91.929,
        89.895,
        87.82,
        85.767,
        83.298,
        81.669,
        79.947,
        77.975,
        76.167,
        74.347,
        72.303,
        70.891,
        69.114,
        67.465,
        65.974,
        64.409,
        62.602,
        60.843,
        59.568,
        58.165,
        56.543,
        55.415,
        53.539,
        52.359,
        51.137,
        49.486,
        48.392,
        46.508,
        45.509,
        44.383,
        43.35,
        42.067,
        40.735,
        40.123,
        38.453,
        37.7,
        36.644,
        36.052,
        34.577,
        33.907,
        32.432,
        32.167,
        30.434,
        29.664,
        28.489,
        27.631,
        26.38,
        26.292,
        25.55,
        25.023,
        24.821,
        22.615,
        22.419,
        22.117,
        20.676,
        20.658,
        19.786,
        19.509,
        18.533,
        17.92,
        17.772,
        16.292,
        16.865,
        15.184,
        15.745,
        15.132,
        15.039,
        14.014,
        13.634,
        12.62,
        12.187,
        12.428,
        11.332,
        10.479,
        11.504,
        10.129,
        9.528,
        10.32,
        9.463,
        9.793,
        9.123,
        8.742,
        9.219,
        7.51,
        7.607,
        7.018,
        7.222,
        7.401,
        6.762,
        7.144,
        5.651,
        5.638,
        5.766,
        6.751,
        5.578,
        3.732,
        5.805,
        5.63,
        4.934,
        3.48,
        4.339,
        3.989,
        3.82,
        3.314,
        3.231,
        3.459,
        3.082,
        3.408,
        3.006,
        2.388,
        2.619,
        1.998,
        3.348,
        2.951,
        0.991,
        2.114,
        2.203,
        2.822,
        2.732,
        2.783,
        3.767,
        2.265,
        2.313,
        2.408,
        2.754,
        3.338,
        2.716,
        1.748,
        1.429,
        2.393,
        2.228,
        2.343,
        0.873,
        3.884,
        1.806,
        1.918,
        1.168,
        1.503,
        2.525,
        0.226,
        2.315,
        0.93,
        1.252,
        2.15,
        0.041,
        2.545,
        1.33,
        0.197,
        2.526,
        3.333,
        -1.343,
        0.422,
        0.917,
        1.129,
        1.461,
        1.458,
        2.873,
        3.334,
        -1.341,
        1.577,
        0.363,
        1.407,
        0.657,
        0.801,
        -0.455,
        1.519,
    ];
    /// Biases aligned with estimates centroids for precision 9 for [`PlusPlus`].
    const BIAS_9: Bias9 = [
        336.202,
        329.878,
        323.66,
        317.462,
        311.283,
        305.71,
        299.742,
        293.937,
        288.105,
        282.285,
        277.067,
        271.306,
        265.845,
        260.301,
        254.989,
        250.242,
        244.814,
        239.707,
        234.743,
        229.84,
        225.166,
        220.353,
        215.594,
        210.689,
        205.788,
        201.65,
        197.228,
        192.804,
        188.167,
        184.082,
        180.082,
        176.257,
        172.302,
        168.164,
        164.006,
        160.38,
        156.719,
        152.523,
        149.208,
        145.831,
        142.485,
        139.111,
        135.476,
        131.76,
        129.337,
        126.554,
        122.506,
        119.265,
        116.59,
        113.382,
        110.9,
        107.953,
        105.206,
        102.28,
        99.473,
        96.958,
        94.329,
        92.171,
        89.781,
        87.572,
        84.705,
        82.532,
        79.875,
        78.397,
        75.346,
        73.727,
        71.283,
        70.144,
        68.426,
        66.017,
        64.018,
        62.044,
        60.34,
        58.686,
        57.984,
        55.031,
        54.677,
        52.319,
        51.485,
        49.442,
        47.739,
        46.149,
        44.92,
        43.406,
        42.534,
        41.283,
        38.895,
        38.329,
        36.215,
        36.668,
        35.995,
        33.123,
        33.434,
        31.738,
        29.076,
        28.969,
        27.496,
        27.1,
        25.986,
        26.775,
        24.321,
        23.484,
        22.739,
        24.076,
        21.91,
        20.973,
        19.923,
        19.929,
        16.617,
        17.05,
        18.3,
        15.613,
        15.739,
        14.517,
        13.632,
        12.258,
        13.377,
        11.423,
        13.123,
        9.516,
        10.594,
        9.597,
        8.122,
        9.767,
        7.504,
        7.57,
        6.704,
        6.414,
        6.71,
        5.609,
        4.652,
        6.841,
        3.407,
        3.979,
        3.328,
        5.522,
        3.319,
        2.069,
        4.354,
        1.575,
        0.281,
        2.129,
        -0.215,
        -0.038,
        -0.658,
        0.655,
        -0.07,
        0.858,
        -2.527,
        -2.175,
        -3.355,
        -1.04,
        -0.651,
        -2.144,
        -1.967,
        -3.979,
        -0.604,
        -3.083,
        -3.392,
        -5.296,
        -5.389,
        -5.088,
        -4.699,
        -5.237,
        -3.158,
        -4.979,
        -4.899,
        -7.489,
        -5.948,
        -5.681,
        -6.672,
        -4.705,
        -7.278,
        -4.658,
        -4.436,
        -4.321,
        -5.189,
        -6.669,
        -6.484,
        -5.126,
        -4.403,
        -6.135,
        -5.808,
        -4.167,
        -4.15,
        -7.456,
        -7.241,
        -9.832,
        -5.804,
        -8.656,
        -6.999,
        -10.547,
        -7.341,
        -6.81,
        -6.297,
        -6.232,
    ];
    /// Biases aligned with estimates centroids for precision 10 for [`PlusPlus`].
    const BIAS_10: Bias10 = [
        577.172,
        565.775,
        554.899,
        543.613,
        532.649,
        521.947,
        511.521,
        501.106,
        490.636,
        480.247,
        470.459,
        460.383,
        451.058,
        440.861,
        431.387,
        422.506,
        413.186,
        404.463,
        395.339,
        386.194,
        378.129,
        369.185,
        361.291,
        353.332,
        344.852,
        337.52,
        329.485,
        321.932,
        314.552,
        306.466,
        299.426,
        292.849,
        286.152,
        278.896,
        271.879,
        265.118,
        258.62,
        252.513,
        245.932,
        239.773,
        233.609,
        227.533,
        222.592,
        216.429,
        210.766,
        205.411,
        199.734,
        194.901,
        188.449,
        183.156,
        178.634,
        173.731,
        169.626,
        163.953,
        159.874,
        155.833,
        151.197,
        147.559,
        143.07,
        140.037,
        134.18,
        131.071,
        127.488,
        124.085,
        120.294,
        117.333,
        112.963,
        110.29,
        107.081,
        103.033,
        99.483,
        96.39,
        93.72,
        90.171,
        87.236,
        85.935,
        82.891,
        80.026,
        78.383,
        75.154,
        73.868,
        70.99,
        69.437,
        64.87,
        65.041,
        61.674,
        59.521,
        57.016,
        54.23,
        53.096,
        50.499,
        52.259,
        47.391,
        45.624,
        42.838,
        43.007,
        40.652,
        40.245,
        35.214,
        36.455,
        33.785,
        33.229,
        32.468,
        30.867,
        28.651,
        28.91,
        27.598,
        26.162,
        24.556,
        23.233,
        21.948,
        21.59,
        21.335,
        17.703,
        20.611,
        19.555,
        15.738,
        17.072,
        16.952,
        15.326,
        13.182,
        14.693,
        13.086,
        13.275,
        10.87,
        11.248,
        7.377,
        4.723,
        7.979,
        8.75,
        7.681,
        9.72,
        7.739,
        5.622,
        7.446,
        6.66,
        5.906,
        4.002,
        4.517,
        4.682,
        3.862,
        5.136,
        5.985,
        2.477,
        2.62,
        1.628,
        4.65,
        0.226,
        0.831,
        -0.359,
        1.276,
        -2.926,
        -0.03,
        2.371,
        -2.003,
        0.805,
        0.302,
        1.125,
        -2.688,
        0.032,
        -1.181,
        -3.94,
        -1.479,
        -0.188,
        -2.107,
        -2.042,
        -3.129,
        -4.162,
        -0.613,
        -3.487,
        -8.179,
        -5.378,
        -4.014,
        -5.583,
        -5.737,
        -7.668,
        -5.695,
        -1.125,
        -5.585,
        -8.046,
        -4.648,
        -11.647,
        -7.975,
        -5.783,
        -7.674,
        -10.633,
        -9.817,
    ];
    /// Sorted estimates centroids for precision 4 for [`PlusPlus`].
    const ESTIMATES_4: Estimates4 = [
        11.0,
        11.717,
        12.207,
        12.79,
        13.288,
        13.82,
        14.377,
        14.934,
        15.52,
        16.161,
        16.772,
        17.464,
        18.04,
        18.677,
        19.357,
        20.045,
        20.794,
        21.486,
        22.267,
        22.995,
        23.766,
        24.469,
        25.364,
        26.076,
        26.786,
        27.76,
        28.481,
        29.433,
        30.293,
        31.066,
        32.0,
        32.796,
        33.537,
        34.589,
        35.574,
        36.27,
        37.368,
        38.054,
        39.234,
        40.011,
        40.797,
        41.93,
        42.87,
        43.636,
        44.519,
        45.773,
        46.677,
        47.617,
        48.489,
        49.33,
        50.251,
        51.5,
        52.382,
        53.308,
        54.398,
        55.584,
        56.662,
        57.217,
        58.351,
        59.08,
        60.148,
        61.038,
        62.36,
        62.808,
        63.974,
        64.914,
        65.781,
        67.181,
        68.059,
        68.845,
        69.793,
        70.825,
        71.832,
        72.86,
        73.625,
        74.701,
        75.393,
        76.671,
        77.239,
    ];
    /// Sorted estimates centroids for precision 5 for [`PlusPlus`].
    const ESTIMATES_5: Estimates5 = [
        23.0,
        23.119,
        23.821,
        24.232,
        24.77,
        25.244,
        25.777,
        26.285,
        26.822,
        27.374,
        27.934,
        28.503,
        29.049,
        29.629,
        30.212,
        30.798,
        31.367,
        31.973,
        32.594,
        33.217,
        33.844,
        34.37,
        35.096,
        35.704,
        36.324,
        37.067,
        37.67,
        38.364,
        39.049,
        39.692,
        40.415,
        41.082,
        41.687,
        42.54,
        43.246,
        43.857,
        44.661,
        45.417,
        46.125,
        46.922,
        47.68,
        48.447,
        49.345,
        49.959,
        50.764,
        51.578,
        52.331,
        53.19,
        53.968,
        54.756,
        55.531,
        56.444,
        57.371,
        57.977,
        58.962,
        59.88,
        60.755,
        61.472,
        62.208,
        63.102,
        63.891,
        64.734,
        65.773,
        66.629,
        67.413,
        68.327,
        69.152,
        70.264,
        71.181,
        72.057,
        72.919,
        73.76,
        74.352,
        75.58,
        76.439,
        77.492,
        78.152,
        79.189,
        79.841,
        80.88,
        81.838,
        82.47,
        83.766,
        84.331,
        85.591,
        86.601,
        87.702,
        88.558,
        89.339,
        90.354,
        91.491,
        92.308,
        93.355,
        93.975,
        95.205,
        95.727,
        97.132,
        98.394,
        98.759,
        100.242,
        101.191,
        102.254,
        102.878,
        103.629,
        105.193,
        105.915,
        107.087,
        107.673,
        108.714,
        110.311,
        110.872,
        111.245,
        112.791,
        113.706,
        114.636,
        115.746,
        116.179,
        117.746,
        118.49,
        119.617,
        120.508,
        121.78,
        122.903,
        123.443,
        124.885,
        125.705,
        126.465,
        128.346,
        128.346,
        130.04,
        131.004,
        131.034,
        132.477,
        133.511,
        134.725,
        135.425,
        136.517,
        138.057,
        138.669,
        139.371,
        140.86,
        141.459,
        142.554,
        143.401,
        144.737,
        146.163,
        146.899,
        147.605,
        147.93,
        149.164,
        150.247,
        151.588,
        152.21,
        153.703,
        154.715,
        155.807,
        156.923,
        157.037,
        158.585,
    ];
    /// Sorted estimates centroids for precision 6 for [`PlusPlus`].
    const ESTIMATES_6: Estimates6 = [
        46.0,
        46.19,
        47.271,
        47.836,
        48.814,
        49.285,
        50.317,
        51.354,
        51.892,
        52.944,
        53.46,
        54.526,
        55.625,
        56.157,
        57.282,
        57.837,
        58.964,
        60.074,
        60.704,
        61.798,
        62.477,
        63.656,
        64.794,
        65.5,
        66.686,
        67.291,
        68.567,
        69.856,
        70.498,
        71.82,
        72.425,
        73.774,
        75.079,
        75.834,
        77.029,
        77.81,
        79.079,
        80.573,
        81.188,
        82.565,
        83.29,
        84.678,
        85.335,
        86.895,
        88.371,
        89.085,
        90.499,
        91.269,
        92.684,
        94.223,
        94.973,
        96.336,
        97.229,
        98.726,
        100.328,
        101.105,
        102.596,
        103.356,
        105.127,
        106.418,
        107.497,
        109.082,
        109.856,
        111.48,
        113.283,
        114.021,
        115.637,
        116.517,
        118.058,
        119.748,
        120.427,
        122.133,
        123.237,
        125.279,
        126.678,
        127.793,
        129.195,
        129.956,
        131.645,
        133.87,
        134.543,
        136.2,
        137.029,
        138.628,
        139.678,
        141.792,
        143.352,
        144.283,
        146.039,
        147.075,
        148.491,
        150.849,
        151.696,
        153.54,
        154.073,
        156.371,
        157.722,
        158.733,
        160.421,
        161.418,
        163.942,
        165.277,
        166.411,
        168.131,
        168.769,
        170.926,
        172.683,
        173.75,
        175.706,
        176.389,
        179.019,
        180.452,
        181.927,
        183.417,
        184.411,
        186.033,
        188.512,
        189.556,
        191.601,
        192.417,
        193.804,
        194.997,
        197.455,
        198.895,
        200.235,
        202.309,
        203.155,
        204.884,
        206.651,
        206.677,
        209.725,
        210.475,
        212.723,
        214.661,
        215.168,
        217.793,
        218.001,
        219.905,
        221.66,
        223.559,
        225.164,
        225.688,
        227.713,
        229.45,
        231.198,
        232.976,
        233.165,
        236.727,
        237.747,
        238.197,
        241.135,
        242.305,
        244.195,
        245.313,
        246.879,
        249.12,
        249.853,
        252.679,
        253.857,
        254.449,
        257.236,
        257.953,
        260.029,
        260.563,
        262.663,
        264.723,
        265.757,
        267.162,
        267.257,
        270.62,
        272.822,
        273.217,
        275.206,
        276.22,
        278.373,
        280.334,
        281.928,
        283.973,
        284.192,
        286.487,
        287.587,
        289.807,
        291.121,
        292.769,
        294.871,
        296.665,
        297.118,
        299.401,
        300.635,
        302.135,
        304.176,
        306.161,
        307.346,
        308.521,
        309.413,
        310.835,
        313.968,
        315.837,
        316.78,
        318.986,
    ];
    /// Sorted estimates centroids for precision 7 for [`PlusPlus`].
    const ESTIMATES_7: Estimates7 = [
        92.0,
        93.493,
        94.976,
        96.457,
        97.972,
        99.495,
        101.53,
        103.076,
        104.637,
        106.178,
        107.789,
        109.952,
        111.592,
        113.253,
        114.909,
        116.594,
        118.947,
        120.68,
        122.439,
        124.218,
        125.977,
        128.421,
        130.253,
        132.01,
        133.866,
        135.728,
        138.304,
        140.132,
        142.093,
        144.003,
        145.909,
        148.631,
        150.529,
        152.576,
        154.651,
        156.662,
        159.552,
        161.372,
        163.617,
        165.575,
        167.787,
        169.844,
        172.799,
        174.861,
        177.212,
        179.357,
        181.448,
        184.588,
        186.682,
        189.082,
        191.026,
        193.605,
        196.444,
        198.727,
        200.957,
        203.147,
        205.436,
        208.759,
        211.339,
        213.781,
        215.803,
        218.656,
        221.654,
        223.996,
        226.472,
        229.154,
        231.61,
        234.596,
        237.062,
        239.576,
        242.488,
        244.524,
        248.215,
        250.724,
        252.872,
        255.52,
        258.041,
        261.941,
        264.905,
        266.87,
        269.43,
        272.028,
        274.471,
        278.37,
        281.062,
        283.467,
        286.553,
        289.435,
        293.256,
        295.274,
        298.212,
        300.747,
        304.146,
        307.293,
        309.75,
        312.553,
        315.979,
        318.21,
        322.183,
        324.349,
        327.325,
        330.661,
        332.903,
        337.254,
        339.904,
        343.215,
        345.286,
        348.081,
        352.676,
        355.301,
        357.139,
        360.658,
        363.173,
        366.59,
        369.954,
        373.083,
        375.922,
        378.99,
        382.733,
        386.454,
        388.114,
        391.223,
        394.088,
        396.708,
        401.156,
        404.185,
        406.637,
        409.682,
        412.78,
        416.608,
        418.492,
        422.131,
        424.538,
        428.199,
        432.211,
        434.45,
        438.528,
        440.912,
        444.045,
        447.743,
        450.852,
        453.799,
        456.786,
        458.887,
        463.989,
        466.506,
        468.912,
        472.662,
        475.468,
        478.582,
        481.304,
        485.274,
        488.689,
        490.329,
        496.106,
        497.691,
        501.137,
        504.532,
        506.885,
        510.332,
        513.451,
        516.179,
        520.441,
        522.607,
        526.167,
        528.779,
        533.379,
        536.067,
        538.46,
        542.912,
        545.692,
        547.955,
        552.493,
        555.272,
        557.335,
        562.449,
        564.201,
        569.074,
        571.097,
        574.856,
        578.3,
        581.409,
        583.97,
        585.81,
        589.653,
        594.6,
        595.958,
        600.068,
        603.328,
        608.202,
        609.963,
        612.864,
        615.43,
        620.779,
        621.272,
        625.864,
        629.206,
        633.219,
        634.515,
        638.61,
    ];
    /// Sorted estimates centroids for precision 8 for [`PlusPlus`].
    const ESTIMATES_8: Estimates8 = [
        220.27,
        223.518,
        227.441,
        230.803,
        234.163,
        238.169,
        241.607,
        245.695,
        249.266,
        252.823,
        257.043,
        260.682,
        264.946,
        268.627,
        272.263,
        276.838,
        280.403,
        284.896,
        288.852,
        292.764,
        297.355,
        301.356,
        305.753,
        309.929,
        313.895,
        318.82,
        322.767,
        327.298,
        331.669,
        335.947,
        340.975,
        345.167,
        349.347,
        354.303,
        358.891,
        364.114,
        368.465,
        372.974,
        378.409,
        382.602,
        387.843,
        392.568,
        397.165,
        402.543,
        407.415,
        412.539,
        417.359,
        422.137,
        427.486,
        432.392,
        437.508,
        442.509,
        447.383,
        453.35,
        458.067,
        463.735,
        469.123,
        473.453,
        479.7,
        484.644,
        491.052,
        495.577,
        500.907,
        506.432,
        512.167,
        517.434,
        522.664,
        527.489,
        533.631,
        538.38,
        544.292,
        550.55,
        556.023,
        562.821,
        566.615,
        572.419,
        579.117,
        583.676,
        590.658,
        595.786,
        601.509,
        607.533,
        612.92,
        619.772,
        624.292,
        630.865,
        636.184,
        642.745,
        649.132,
        655.039,
        660.014,
        666.634,
        671.62,
        678.187,
        684.428,
        689.332,
        695.479,
        702.504,
        708.129,
        713.528,
        720.32,
        726.463,
        732.793,
        739.123,
        744.742,
        751.219,
        756.51,
        762.607,
        769.018,
        775.222,
        781.401,
        787.762,
        794.144,
        798.651,
        805.638,
        811.766,
        819.751,
        824.578,
        828.732,
        837.805,
        843.63,
        849.934,
        854.48,
        861.339,
        867.989,
        873.82,
        880.314,
        886.231,
        892.459,
        899.082,
        905.408,
        912.006,
        917.388,
        923.619,
        929.998,
        937.348,
        943.951,
        947.991,
        955.114,
        962.203,
        968.822,
        975.732,
        981.783,
        988.767,
        994.265,
        1_000.313,
        1_007.408,
        1_013.754,
        1_020.338,
        1_026.716,
        1_031.748,
        1_037.429,
        1_045.393,
        1_051.228,
        1_058.343,
        1_062.873,
        1_071.884,
        1_076.806,
        1_082.918,
        1_089.168,
        1_095.503,
        1_102.525,
        1_107.226,
        1_115.315,
        1_120.93,
        1_127.252,
        1_134.15,
        1_139.041,
        1_147.545,
        1_153.33,
        1_158.197,
        1_166.526,
        1_174.333,
        1_175.657,
        1_184.422,
        1_190.917,
        1_197.129,
        1_204.461,
        1_210.458,
        1_218.873,
        1_225.334,
        1_226.659,
        1_236.577,
        1_241.363,
        1_249.407,
        1_254.657,
        1_260.801,
        1_266.545,
        1_274.519,
    ];
    /// Sorted estimates centroids for precision 9 for [`PlusPlus`].
    const ESTIMATES_9: Estimates9 = [
        400.202,
        406.878,
        413.66,
        420.462,
        427.283,
        433.71,
        440.742,
        447.937,
        455.105,
        462.285,
        469.067,
        476.306,
        483.845,
        491.301,
        498.989,
        506.242,
        513.814,
        521.707,
        529.743,
        537.84,
        545.166,
        553.353,
        561.594,
        569.689,
        577.788,
        585.65,
        594.228,
        602.804,
        611.167,
        620.082,
        628.082,
        637.257,
        646.302,
        655.164,
        664.006,
        672.38,
        681.719,
        690.523,
        700.208,
        708.831,
        718.485,
        728.111,
        737.476,
        746.76,
        756.337,
        766.554,
        775.506,
        785.265,
        795.59,
        804.382,
        814.9,
        824.953,
        835.206,
        845.28,
        854.473,
        864.958,
        875.329,
        886.171,
        896.781,
        906.572,
        916.705,
        927.532,
        937.875,
        949.397,
        958.346,
        969.727,
        980.283,
        992.144,
        1_003.426,
        1_013.017,
        1_024.018,
        1_035.044,
        1_046.34,
        1_057.686,
        1_068.984,
        1_079.031,
        1_091.677,
        1_102.319,
        1_113.485,
        1_124.442,
        1_135.739,
        1_147.149,
        1_158.92,
        1_169.406,
        1_181.534,
        1_193.283,
        1_203.895,
        1_216.329,
        1_226.215,
        1_239.668,
        1_251.995,
        1_262.123,
        1_275.434,
        1_285.738,
        1_296.076,
        1_308.969,
        1_320.496,
        1_333.1,
        1_343.986,
        1_357.775,
        1_368.321,
        1_380.484,
        1_392.739,
        1_406.076,
        1_416.91,
        1_428.973,
        1_440.923,
        1_453.929,
        1_462.617,
        1_476.05,
        1_490.3,
        1_500.613,
        1_513.739,
        1_524.517,
        1_536.632,
        1_548.258,
        1_562.377,
        1_572.423,
        1_587.123,
        1_596.516,
        1_610.594,
        1_622.597,
        1_633.122,
        1_647.767,
        1_658.504,
        1_671.57,
        1_683.704,
        1_695.414,
        1_708.71,
        1_720.609,
        1_732.652,
        1_747.841,
        1_756.407,
        1_769.979,
        1_782.328,
        1_797.522,
        1_808.319,
        1_819.069,
        1_834.354,
        1_844.575,
        1_856.281,
        1_871.129,
        1_880.785,
        1_893.962,
        1_906.342,
        1_920.655,
        1_932.93,
        1_945.858,
        1_955.473,
        1_968.825,
        1_980.645,
        1_995.96,
        2_008.349,
        2_019.856,
        2_033.033,
        2_044.021,
        2_059.396,
        2_069.917,
        2_082.608,
        2_093.704,
        2_106.611,
        2_118.912,
        2_132.301,
        2_144.763,
        2_159.842,
        2_171.021,
        2_183.101,
        2_193.511,
        2_208.052,
        2_221.319,
        2_233.328,
        2_247.295,
        2_257.722,
        2_273.342,
        2_286.564,
        2_299.679,
        2_310.811,
        2_322.331,
        2_335.516,
        2_349.874,
        2_363.597,
        2_373.865,
        2_387.192,
        2_401.833,
        2_414.85,
        2_424.544,
        2_436.759,
        2_447.168,
        2_464.196,
        2_474.344,
        2_489.001,
        2_497.453,
        2_513.659,
        2_527.19,
        2_540.703,
        2_553.768,
    ];
    /// Sorted estimates centroids for precision 10 for [`PlusPlus`].
    const ESTIMATES_10: Estimates10 = [
        910.172,
        924.775,
        938.899,
        953.613,
        968.649,
        982.947,
        998.521,
        1_013.106,
        1_028.636,
        1_044.247,
        1_059.459,
        1_075.383,
        1_091.058,
        1_106.861,
        1_123.387,
        1_139.506,
        1_156.186,
        1_172.463,
        1_189.339,
        1_206.194,
        1_223.129,
        1_240.185,
        1_257.291,
        1_275.332,
        1_292.852,
        1_310.52,
        1_328.485,
        1_345.932,
        1_364.552,
        1_381.466,
        1_400.426,
        1_419.849,
        1_438.152,
        1_456.896,
        1_474.879,
        1_494.118,
        1_513.62,
        1_532.513,
        1_551.932,
        1_570.773,
        1_590.609,
        1_610.533,
        1_630.592,
        1_650.429,
        1_669.766,
        1_690.411,
        1_710.734,
        1_730.901,
        1_750.449,
        1_770.156,
        1_791.634,
        1_812.731,
        1_833.626,
        1_853.953,
        1_874.874,
        1_896.833,
        1_918.197,
        1_939.559,
        1_961.07,
        1_983.037,
        2_003.18,
        2_026.071,
        2_047.488,
        2_070.085,
        2_091.294,
        2_114.333,
        2_135.963,
        2_158.29,
        2_181.081,
        2_202.033,
        2_224.483,
        2_246.39,
        2_269.72,
        2_292.171,
        2_314.236,
        2_338.935,
        2_360.891,
        2_384.026,
        2_408.383,
        2_430.154,
        2_454.868,
        2_476.99,
        2_501.437,
        2_522.87,
        2_548.041,
        2_570.674,
        2_593.521,
        2_617.016,
        2_640.23,
        2_664.096,
        2_687.499,
        2_714.259,
        2_735.391,
        2_759.624,
        2_781.838,
        2_808.007,
        2_830.652,
        2_856.245,
        2_877.214,
        2_903.455,
        2_926.785,
        2_951.229,
        2_976.468,
        3_000.867,
        3_023.651,
        3_049.91,
        3_073.598,
        3_098.162,
        3_121.556,
        3_146.233,
        3_170.948,
        3_195.59,
        3_221.335,
        3_242.703,
        3_271.611,
        3_296.555,
        3_317.738,
        3_345.072,
        3_369.952,
        3_394.326,
        3_418.182,
        3_444.693,
        3_469.086,
        3_494.275,
        3_517.87,
        3_544.248,
        3_565.377,
        3_588.723,
        3_616.979,
        3_643.75,
        3_668.681,
        3_695.72,
        3_719.739,
        3_742.622,
        3_770.446,
        3_795.66,
        3_819.906,
        3_844.002,
        3_869.517,
        3_895.682,
        3_920.862,
        3_947.136,
        3_973.985,
        3_995.477,
        4_021.62,
        4_046.628,
        4_074.65,
        4_096.226,
        4_121.831,
        4_146.641,
        4_173.276,
        4_195.074,
        4_223.97,
        4_251.371,
        4_272.997,
        4_300.805,
        4_326.302,
        4_353.125,
        4_374.312,
        4_403.032,
        4_426.819,
        4_450.06,
        4_478.521,
        4_504.812,
        4_528.893,
        4_553.958,
        4_578.871,
        4_603.838,
        4_632.387,
        4_655.513,
        4_675.821,
        4_704.622,
        4_731.986,
        4_755.417,
        4_781.263,
        4_804.332,
        4_832.305,
        4_862.875,
        4_883.415,
        4_906.954,
        4_935.352,
        4_954.353,
        4_984.025,
        5_011.217,
        5_035.326,
        5_057.367,
        5_084.183,
    ];
    /// Number of zeros for linear count threshold for precision 4 used in [`HyperLogLog`].
    const LINEAR_COUNT_ZEROS_4: u8 = 9;
    /// Number of zeros for linear count threshold for precision 5 used in [`HyperLogLog`].
    const LINEAR_COUNT_ZEROS_5: u8 = 17;
    /// Number of zeros for linear count threshold for precision 6 used in [`HyperLogLog`].
    const LINEAR_COUNT_ZEROS_6: u8 = 34;
    /// Number of zeros for linear count threshold for precision 7 used in [`HyperLogLog`].
    const LINEAR_COUNT_ZEROS_7: u8 = 69;
    /// Number of zeros for linear count threshold for precision 8 used in [`HyperLogLog`].
    const LINEAR_COUNT_ZEROS_8: u16 = 108;
    /// Number of zeros for linear count threshold for precision 9 used in [`HyperLogLog`].
    const LINEAR_COUNT_ZEROS_9: u16 = 234;
    /// Number of zeros for linear count threshold for precision 10 used in [`HyperLogLog`].
    const LINEAR_COUNT_ZEROS_10: u16 = 425;
    use core::f64::consts::{LN_2, LN_10};
    /// Precomputed natural log values for no-std log computations.
    static LN_VALUES: [f64; 1_025] = [
        f64::NEG_INFINITY,
        0.0,
        LN_2,
        1.098_612_288_668,
        1.386_294_361_12,
        1.609_437_912_434,
        1.791_759_469_228,
        1.945_910_149_055,
        2.079_441_541_68,
        2.197_224_577_336,
        LN_10,
        2.397_895_272_798,
        2.484_906_649_788,
        2.564_949_357_462,
        2.639_057_329_615,
        2.708_050_201_102,
        2.772_588_722_24,
        2.833_213_344_056,
        2.890_371_757_896,
        2.944_438_979_166,
        2.995_732_273_554,
        3.044_522_437_723,
        3.091_042_453_358,
        3.135_494_215_929,
        3.178_053_830_348,
        3.218_875_824_868,
        3.258_096_538_021,
        3.295_836_866_004,
        3.332_204_510_175,
        3.367_295_829_986,
        3.401_197_381_662,
        3.433_987_204_485,
        3.465_735_902_8,
        3.496_507_561_466,
        3.526_360_524_616,
        3.555_348_061_489,
        3.583_518_938_456,
        3.610_917_912_644,
        3.637_586_159_726,
        3.663_561_646_13,
        3.688_879_454_114,
        3.713_572_066_704,
        3.737_669_618_283,
        3.761_200_115_694,
        3.784_189_633_918,
        3.806_662_489_77,
        3.828_641_396_489,
        3.850_147_601_71,
        3.871_201_010_908,
        3.891_820_298_111,
        3.912_023_005_428,
        3.931_825_632_724,
        3.951_243_718_581,
        3.970_291_913_552,
        3.988_984_046_564,
        4.007_333_185_232,
        4.025_351_690_735,
        4.043_051_267_835,
        4.060_443_010_546,
        4.077_537_443_906,
        4.094_344_562_222,
        4.110_873_864_173,
        4.127_134_385_045,
        4.143_134_726_392,
        4.158_883_083_36,
        4.174_387_269_896,
        4.189_654_742_026,
        4.204_692_619_391,
        4.219_507_705_176,
        4.234_106_504_597,
        4.248_495_242_049,
        4.262_679_877_041,
        4.276_666_119_016,
        4.290_459_441_148,
        4.304_065_093_204,
        4.317_488_113_536,
        4.330_733_340_286,
        4.343_805_421_854,
        4.356_708_826_69,
        4.369_447_852_467,
        4.382_026_634_674,
        4.394_449_154_672,
        4.406_719_247_264,
        4.418_840_607_797,
        4.430_816_798_843,
        4.442_651_256_49,
        4.454_347_296_254,
        4.465_908_118_655,
        4.477_336_814_478,
        4.488_636_369_732,
        4.499_809_670_33,
        4.510_859_506_517,
        4.521_788_577_049,
        4.532_599_493_153,
        4.543_294_782_27,
        4.553_876_891_601,
        4.564_348_191_468,
        4.574_710_978_503,
        4.584_967_478_671,
        4.595_119_850_135,
        4.605_170_185_988,
        4.615_120_516_841,
        4.624_972_813_284,
        4.634_728_988_23,
        4.644_390_899_141,
        4.653_960_350_158,
        4.663_439_094_112,
        4.672_828_834_462,
        4.682_131_227_124,
        4.691_347_882_229,
        4.700_480_365_792,
        4.709_530_201_312,
        4.718_498_871_295,
        4.727_387_818_712,
        4.736_198_448_394,
        4.744_932_128_363,
        4.753_590_191_106,
        4.762_173_934_798,
        4.770_684_624_466,
        4.779_123_493_112,
        4.787_491_742_782,
        4.795_790_545_597,
        4.804_021_044_733,
        4.812_184_355_372,
        4.820_281_565_605,
        4.828_313_737_302,
        4.836_281_906_951,
        4.844_187_086_459,
        4.852_030_263_92,
        4.859_812_404_362,
        4.867_534_450_456,
        4.875_197_323_201,
        4.882_801_922_586,
        4.890_349_128_222,
        4.897_839_799_951,
        4.905_274_778_438,
        4.912_654_885_736,
        4.919_980_925_828,
        4.927_253_685_157,
        4.934_473_933_131,
        4.941_642_422_609,
        4.948_759_890_378,
        4.955_827_057_601,
        4.962_844_630_26,
        4.969_813_299_576,
        4.976_733_742_421,
        4.983_606_621_708,
        4.990_432_586_779,
        4.997_212_273_764,
        5.003_946_305_945,
        5.010_635_294_096,
        5.017_279_836_815,
        5.023_880_520_846,
        5.030_437_921_392,
        5.036_952_602_414,
        5.043_425_116_919,
        5.049_856_007_25,
        5.056_245_805_348,
        5.062_595_033_027,
        5.068_904_202_22,
        5.075_173_815_234,
        5.081_404_364_984,
        5.087_596_335_232,
        5.093_750_200_807,
        5.099_866_427_824,
        5.105_945_473_901,
        5.111_987_788_357,
        5.117_993_812_417,
        5.123_963_979_403,
        5.129_898_714_923,
        5.135_798_437_05,
        5.141_663_556_503,
        5.147_494_476_813,
        5.153_291_594_498,
        5.159_055_299_215,
        5.164_785_973_924,
        5.170_483_995_038,
        5.176_149_732_574,
        5.181_783_550_292,
        5.187_385_805_841,
        5.192_956_850_89,
        5.198_497_031_266,
        5.204_006_687_077,
        5.209_486_152_841,
        5.214_935_757_609,
        5.220_355_825_078,
        5.225_746_673_713,
        5.231_108_616_855,
        5.236_441_962_83,
        5.241_747_015_06,
        5.247_024_072_16,
        5.252_273_428_047,
        5.257_495_372_028,
        5.262_690_188_905,
        5.267_858_159_063,
        5.272_999_558_564,
        5.278_114_659_231,
        5.283_203_728_738,
        5.288_267_030_695,
        5.293_304_824_724,
        5.298_317_366_548,
        5.303_304_908_059,
        5.308_267_697_401,
        5.313_205_979_042,
        5.318_119_993_844,
        5.323_009_979_138,
        5.327_876_168_79,
        5.332_718_793_265,
        5.337_538_079_701,
        5.342_334_251_965,
        5.347_107_530_717,
        5.351_858_133_476,
        5.356_586_274_672,
        5.361_292_165_709,
        5.365_976_015_022,
        5.370_638_028_128,
        5.375_278_407_684,
        5.379_897_353_54,
        5.384_495_062_789,
        5.389_071_729_817,
        5.393_627_546_352,
        5.398_162_701_518,
        5.402_677_381_872,
        5.407_171_771_46,
        5.411_646_051_855,
        5.416_100_402_204,
        5.420_534_999_272,
        5.424_950_017_481,
        5.429_345_628_954,
        5.433_722_003_554,
        5.438_079_308_923,
        5.442_417_710_522,
        5.446_737_371_666,
        5.451_038_453_566,
        5.455_321_115_358,
        5.459_585_514_144,
        5.463_831_805_026,
        5.468_060_141_135,
        5.472_270_673_671,
        5.476_463_551_932,
        5.480_638_923_342,
        5.484_796_933_491,
        5.488_937_726_157,
        5.493_061_443_341,
        5.497_168_225_293,
        5.501_258_210_545,
        5.505_331_535_932,
        5.509_388_336_628,
        5.513_428_746_165,
        5.517_452_896_465,
        5.521_460_917_862,
        5.525_452_939_132,
        5.529_429_087_511,
        5.533_389_488_728,
        5.537_334_267_019,
        5.541_263_545_158,
        5.545_177_444_48,
        5.549_076_084_895,
        5.552_959_584_922,
        5.556_828_061_7,
        5.560_681_631_016,
        5.564_520_407_323,
        5.568_344_503_761,
        5.572_154_032_178,
        5.575_949_103_146,
        5.579_729_825_986,
        5.583_496_308_782,
        5.587_248_658_4,
        5.590_986_980_511,
        5.594_711_379_602,
        5.598_421_958_998,
        5.602_118_820_88,
        5.605_802_066_296,
        5.609_471_795_185,
        5.613_128_106_388,
        5.616_771_097_667,
        5.620_400_865_717,
        5.624_017_506_187,
        5.627_621_113_691,
        5.631_211_781_821,
        5.634_789_603_169,
        5.638_354_669_334,
        5.641_907_070_938,
        5.645_446_897_643,
        5.648_974_238_161,
        5.652_489_180_269,
        5.655_991_810_82,
        5.659_482_215_76,
        5.662_960_480_136,
        5.666_426_688_112,
        5.669_880_922_981,
        5.673_323_267_171,
        5.676_753_802_268,
        5.680_172_609_017,
        5.683_579_767_339,
        5.686_975_356_34,
        5.690_359_454_324,
        5.693_732_138_803,
        5.697_093_486_505,
        5.700_443_573_391,
        5.703_782_474_656,
        5.707_110_264_749,
        5.710_427_017_375,
        5.713_732_805_509,
        5.717_027_701_406,
        5.720_311_776_607,
        5.723_585_101_952,
        5.726_847_747_587,
        5.730_099_782_974,
        5.733_341_276_898,
        5.736_572_297_479,
        5.739_792_912_179,
        5.743_003_187_809,
        5.746_203_190_54,
        5.749_392_985_908,
        5.752_572_638_826,
        5.755_742_213_587,
        5.758_901_773_877,
        5.762_051_382_78,
        5.765_191_102_785,
        5.768_320_995_794,
        5.771_441_123_13,
        5.774_551_545_544,
        5.777_652_323_223,
        5.780_743_515_792,
        5.783_825_182_33,
        5.786_897_381_367,
        5.789_960_170_897,
        5.793_013_608_384,
        5.796_057_750_765,
        5.799_092_654_461,
        5.802_118_375_377,
        5.805_134_968_916,
        5.808_142_489_98,
        5.811_140_992_977,
        5.814_130_531_825,
        5.817_111_159_963,
        5.820_082_930_352,
        5.823_045_895_483,
        5.826_000_107_38,
        5.828_945_617_61,
        5.831_882_477_284,
        5.834_810_737_063,
        5.837_730_447_166,
        5.840_641_657_373,
        5.843_544_417_031,
        5.846_438_775_058,
        5.849_324_779_947,
        5.852_202_479_774,
        5.855_071_922_202,
        5.857_933_154_483,
        5.860_786_223_466,
        5.863_631_175_598,
        5.866_468_056_933,
        5.869_296_913_134,
        5.872_117_789_475,
        5.874_930_730_852,
        5.877_735_781_78,
        5.880_532_986_401,
        5.883_322_388_488,
        5.886_104_031_45,
        5.888_877_958_333,
        5.891_644_211_826,
        5.894_402_834_265,
        5.897_153_867_637,
        5.899_897_353_582,
        5.902_633_333_401,
        5.905_361_848_055,
        5.908_082_938_169,
        5.910_796_644_041,
        5.913_503_005_638,
        5.916_202_062_607,
        5.918_893_854_273,
        5.921_578_419_644,
        5.924_255_797_415,
        5.926_926_025_97,
        5.929_589_143_39,
        5.932_245_187_448,
        5.934_894_195_62,
        5.937_536_205_082,
        5.940_171_252_72,
        5.942_799_375_127,
        5.945_420_608_607,
        5.948_034_989_181,
        5.950_642_552_588,
        5.953_243_334_288,
        5.955_837_369_465,
        5.958_424_693_03,
        5.961_005_339_623,
        5.963_579_343_618,
        5.966_146_739_124,
        5.968_707_559_985,
        5.971_261_839_79,
        5.973_809_611_869,
        5.976_350_909_298,
        5.978_885_764_901,
        5.981_414_211_254,
        5.983_936_280_687,
        5.986_452_005_284,
        5.988_961_416_89,
        5.991_464_547_108,
        5.993_961_427_307,
        5.996_452_088_619,
        5.998_936_561_947,
        6.001_414_877_961,
        6.003_887_067_107,
        6.006_353_159_602,
        6.008_813_185_443,
        6.011_267_174_404,
        6.013_715_156_043,
        6.016_157_159_698,
        6.018_593_214_496,
        6.021_023_349_35,
        6.023_447_592_961,
        6.025_865_973_825,
        6.028_278_520_231,
        6.030_685_260_261,
        6.033_086_221_799,
        6.035_481_432_525,
        6.037_870_919_922,
        6.040_254_711_277,
        6.042_632_833_682,
        6.045_005_314_036,
        6.047_372_179_046,
        6.049_733_455_232,
        6.052_089_168_924,
        6.054_439_346_269,
        6.056_784_013_229,
        6.059_123_195_582,
        6.061_456_918_928,
        6.063_785_208_688,
        6.066_108_090_104,
        6.068_425_588_244,
        6.070_737_728_002,
        6.073_044_534_1,
        6.075_346_031_089,
        6.077_642_243_349,
        6.079_933_195_096,
        6.082_218_910_376,
        6.084_499_413_075,
        6.086_774_726_912,
        6.089_044_875_447,
        6.091_309_882_078,
        6.093_569_770_045,
        6.095_824_562_432,
        6.098_074_282_166,
        6.100_318_952_02,
        6.102_558_594_614,
        6.104_793_232_415,
        6.107_022_887_742,
        6.109_247_582_764,
        6.111_467_339_503,
        6.113_682_179_832,
        6.115_892_125_483,
        6.118_097_198_041,
        6.120_297_418_951,
        6.122_492_809_514,
        6.124_683_390_894,
        6.126_869_184_114,
        6.129_050_210_061,
        6.131_226_489_483,
        6.133_398_042_997,
        6.135_564_891_082,
        6.137_727_054_086,
        6.139_884_552_226,
        6.142_037_405_587,
        6.144_185_634_126,
        6.146_329_257_669,
        6.148_468_295_918,
        6.150_602_768_446,
        6.152_732_694_704,
        6.154_858_094_016,
        6.156_978_985_586,
        6.159_095_388_492,
        6.161_207_321_695,
        6.163_314_804_035,
        6.165_417_854_231,
        6.167_516_490_888,
        6.169_610_732_491,
        6.171_700_597_411,
        6.173_786_103_902,
        6.175_867_270_106,
        6.177_944_114_051,
        6.180_016_653_653,
        6.182_084_906_717,
        6.184_148_890_937,
        6.186_208_623_9,
        6.188_264_123_083,
        6.190_315_405_853,
        6.192_362_489_475,
        6.194_405_391_105,
        6.196_444_127_795,
        6.198_478_716_492,
        6.200_509_174_043,
        6.202_535_517_188,
        6.204_557_762_569,
        6.206_575_926_725,
        6.208_590_026_097,
        6.210_600_077_025,
        6.212_606_095_752,
        6.214_608_098_422,
        6.216_606_101_085,
        6.218_600_119_692,
        6.220_590_170_1,
        6.222_576_268_071,
        6.224_558_429_275,
        6.226_536_669_287,
        6.228_511_003_591,
        6.230_481_447_578,
        6.232_448_016_551,
        6.234_410_725_718,
        6.236_369_590_204,
        6.238_324_625_04,
        6.240_275_845_171,
        6.242_223_265_455,
        6.244_166_900_664,
        6.246_106_765_482,
        6.248_042_874_508,
        6.249_975_242_259,
        6.251_903_883_166,
        6.253_828_811_575,
        6.255_750_041_753,
        6.257_667_587_883,
        6.259_581_464_065,
        6.261_491_684_321,
        6.263_398_262_592,
        6.265_301_212_738,
        6.267_200_548_541,
        6.269_096_283_706,
        6.270_988_431_858,
        6.272_877_006_546,
        6.274_762_021_242,
        6.276_643_489_342,
        6.278_521_424_166,
        6.280_395_838_96,
        6.282_266_746_896,
        6.284_134_161_071,
        6.285_998_094_509,
        6.287_858_560_162,
        6.289_715_570_909,
        6.291_569_139_558,
        6.293_419_278_846,
        6.295_266_001_44,
        6.297_109_319_934,
        6.298_949_246_856,
        6.300_785_794_663,
        6.302_618_975_745,
        6.304_448_802_422,
        6.306_275_286_948,
        6.308_098_441_51,
        6.309_918_278_227,
        6.311_734_809_153,
        6.313_548_046_277,
        6.315_358_001_522,
        6.317_164_686_747,
        6.318_968_113_746,
        6.320_768_294_251,
        6.322_565_239_927,
        6.324_358_962_381,
        6.326_149_473_155,
        6.327_936_783_729,
        6.329_720_905_523,
        6.331_501_849_894,
        6.333_279_628_14,
        6.335_054_251_498,
        6.336_825_731_146,
        6.338_594_078_203,
        6.340_359_303_728,
        6.342_121_418_721,
        6.343_880_434_126,
        6.345_636_360_829,
        6.347_389_209_656,
        6.349_138_991_38,
        6.350_885_716_715,
        6.352_629_396_32,
        6.354_370_040_797,
        6.356_107_660_696,
        6.357_842_266_508,
        6.359_573_868_672,
        6.361_302_477_573,
        6.363_028_103_54,
        6.364_750_756_852,
        6.366_470_447_731,
        6.368_187_186_35,
        6.369_900_982_828,
        6.371_611_847_232,
        6.373_319_789_577,
        6.375_024_819_828,
        6.376_726_947_899,
        6.378_426_183_652,
        6.380_122_536_9,
        6.381_816_017_406,
        6.383_506_634_884,
        6.385_194_398_998,
        6.386_879_319_363,
        6.388_561_405_546,
        6.390_240_667_065,
        6.391_917_113_393,
        6.393_590_753_951,
        6.395_261_598_115,
        6.396_929_655_216,
        6.398_594_934_535,
        6.400_257_445_309,
        6.401_917_196_727,
        6.403_574_197_935,
        6.405_228_458_031,
        6.406_879_986_069,
        6.408_528_791_059,
        6.410_174_881_966,
        6.411_818_267_71,
        6.413_458_957_167,
        6.415_096_959_172,
        6.416_732_282_512,
        6.418_364_935_936,
        6.419_994_928_147,
        6.421_622_267_807,
        6.423_246_963_534,
        6.424_869_023_905,
        6.426_488_457_458,
        6.428_105_272_685,
        6.429_719_478_039,
        6.431_331_081_933,
        6.432_940_092_739,
        6.434_546_518_787,
        6.436_150_368_369,
        6.437_751_649_736,
        6.439_350_371_1,
        6.440_946_540_633,
        6.442_540_166_468,
        6.444_131_256_7,
        6.445_719_819_386,
        6.447_305_862_541,
        6.448_889_394_147,
        6.450_470_422_144,
        6.452_048_954_437,
        6.453_624_998_893,
        6.455_198_563_34,
        6.456_769_655_572,
        6.458_338_283_345,
        6.459_904_454_378,
        6.461_468_176_354,
        6.463_029_456_921,
        6.464_588_303_69,
        6.466_144_724_238,
        6.467_698_726_104,
        6.469_250_316_796,
        6.470_799_503_783,
        6.472_346_294_501,
        6.473_890_696_352,
        6.475_432_716_704,
        6.476_972_362_89,
        6.478_509_642_209,
        6.480_044_561_927,
        6.481_577_129_276,
        6.483_107_351_457,
        6.484_635_235_635,
        6.486_160_788_944,
        6.487_684_018_485,
        6.489_204_931_325,
        6.490_723_534_503,
        6.492_239_835_02,
        6.493_753_839_852,
        6.495_265_555_937,
        6.496_774_990_186,
        6.498_282_149_476,
        6.499_787_040_656,
        6.501_289_670_54,
        6.502_790_045_916,
        6.504_288_173_537,
        6.505_784_060_128,
        6.507_277_712_385,
        6.508_769_136_972,
        6.510_258_340_523,
        6.511_745_329_645,
        6.513_230_110_912,
        6.514_712_690_873,
        6.516_193_076_043,
        6.517_671_272_912,
        6.519_147_287_94,
        6.520_621_127_559,
        6.522_092_798_17,
        6.523_562_306_15,
        6.525_029_657_843,
        6.526_494_859_571,
        6.527_957_917_623,
        6.529_418_838_262,
        6.530_877_627_726,
        6.532_334_292_222,
        6.533_788_837_933,
        6.535_241_271_014,
        6.536_691_597_591,
        6.538_139_823_768,
        6.539_585_955_618,
        6.541_029_999_19,
        6.542_471_960_507,
        6.543_911_845_565,
        6.545_349_660_334,
        6.546_785_410_761,
        6.548_219_102_762,
        6.549_650_742_234,
        6.551_080_335_043,
        6.552_507_887_035,
        6.553_933_404_026,
        6.555_356_891_811,
        6.556_778_356_158,
        6.558_197_802_812,
        6.559_615_237_493,
        6.561_030_665_897,
        6.562_444_093_694,
        6.563_855_526_532,
        6.565_264_970_035,
        6.566_672_429_803,
        6.568_077_911_412,
        6.569_481_420_414,
        6.570_882_962_34,
        6.572_282_542_694,
        6.573_680_166_961,
        6.575_075_840_6,
        6.576_469_569_048,
        6.577_861_357_721,
        6.579_251_212_01,
        6.580_639_137_285,
        6.582_025_138_893,
        6.583_409_222_159,
        6.584_791_392_386,
        6.586_171_654_855,
        6.587_550_014_825,
        6.588_926_477_534,
        6.590_301_048_197,
        6.591_673_732_009,
        6.593_044_534_142,
        6.594_413_459_75,
        6.595_780_513_961,
        6.597_145_701_887,
        6.598_509_028_615,
        6.599_870_499_213,
        6.601_230_118_729,
        6.602_587_892_189,
        6.603_943_824_6,
        6.605_297_920_948,
        6.606_650_186_198,
        6.608_000_625_296,
        6.609_349_243_167,
        6.610_696_044_718,
        6.612_041_034_833,
        6.613_384_218_38,
        6.614_725_600_204,
        6.616_065_185_133,
        6.617_402_977_974,
        6.618_738_983_517,
        6.620_073_206_53,
        6.621_405_651_764,
        6.622_736_323_95,
        6.624_065_227_8,
        6.625_392_368_008,
        6.626_717_749_249,
        6.628_041_376_18,
        6.629_363_253_437,
        6.630_683_385_642,
        6.632_001_777_396,
        6.633_318_433_28,
        6.634_633_357_862,
        6.635_946_555_687,
        6.637_258_031_284,
        6.638_567_789_167,
        6.639_875_833_827,
        6.641_182_169_741,
        6.642_486_801_367,
        6.643_789_733_148,
        6.645_090_969_506,
        6.646_390_514_848,
        6.647_688_373_563,
        6.648_984_550_025,
        6.650_279_048_587,
        6.651_571_873_59,
        6.652_863_029_353,
        6.654_152_520_183,
        6.655_440_350_368,
        6.656_726_524_178,
        6.658_011_045_871,
        6.659_293_919_684,
        6.660_575_149_84,
        6.661_854_740_545,
        6.663_132_695_991,
        6.664_409_020_35,
        6.665_683_717_782,
        6.666_956_792_429,
        6.668_228_248_417,
        6.669_498_089_858,
        6.670_766_320_846,
        6.672_032_945_461,
        6.673_297_967_768,
        6.674_561_391_814,
        6.675_823_221_635,
        6.677_083_461_247,
        6.678_342_114_654,
        6.679_599_185_844,
        6.680_854_678_79,
        6.682_108_597_45,
        6.683_360_945_766,
        6.684_611_727_668,
        6.685_860_947_068,
        6.687_108_607_867,
        6.688_354_713_947,
        6.689_599_269_179,
        6.690_842_277_419,
        6.692_083_742_507,
        6.693_323_668_27,
        6.694_562_058_521,
        6.695_798_917_058,
        6.697_034_247_666,
        6.698_268_054_115,
        6.699_500_340_162,
        6.700_731_109_548,
        6.701_960_366_003,
        6.703_188_113_241,
        6.704_414_354_964,
        6.705_639_094_86,
        6.706_862_336_603,
        6.708_084_083_853,
        6.709_304_340_258,
        6.710_523_109_452,
        6.711_740_395_056,
        6.712_956_200_677,
        6.714_170_529_909,
        6.715_383_386_335,
        6.716_594_773_521,
        6.717_804_695_024,
        6.719_013_154_385,
        6.720_220_155_135,
        6.721_425_700_791,
        6.722_629_794_855,
        6.723_832_440_821,
        6.725_033_642_167,
        6.726_233_402_359,
        6.727_431_724_851,
        6.728_628_613_085,
        6.729_824_070_489,
        6.731_018_100_482,
        6.732_210_706_467,
        6.733_401_891_837,
        6.734_591_659_973,
        6.735_780_014_242,
        6.736_966_958_002,
        6.738_152_494_596,
        6.739_336_627_357,
        6.740_519_359_606,
        6.741_700_694_652,
        6.742_880_635_792,
        6.744_059_186_311,
        6.745_236_349_484,
        6.746_412_128_573,
        6.747_586_526_829,
        6.748_759_547_492,
        6.749_931_193_789,
        6.751_101_468_937,
        6.752_270_376_142,
        6.753_437_918_598,
        6.754_604_099_488,
        6.755_768_921_984,
        6.756_932_389_248,
        6.758_094_504_428,
        6.759_255_270_664,
        6.760_414_691_083,
        6.761_572_768_804,
        6.762_729_506_932,
        6.763_884_908_562,
        6.765_038_976_781,
        6.766_191_714_66,
        6.767_343_125_265,
        6.768_493_211_649,
        6.769_641_976_853,
        6.770_789_423_909,
        6.771_935_555_84,
        6.773_080_375_656,
        6.774_223_886_358,
        6.775_366_090_936,
        6.776_506_992_372,
        6.777_646_593_635,
        6.778_784_897_685,
        6.779_921_907_472,
        6.781_057_625_936,
        6.782_192_056_007,
        6.783_325_200_604,
        6.784_457_062_638,
        6.785_587_645_008,
        6.786_716_950_605,
        6.787_844_982_31,
        6.788_971_742_992,
        6.790_097_235_514,
        6.791_221_462_726,
        6.792_344_427_471,
        6.793_466_132_58,
        6.794_586_580_876,
        6.795_705_775_174,
        6.796_823_718_275,
        6.797_940_412_975,
        6.799_055_862_059,
        6.800_170_068_302,
        6.801_283_034_472,
        6.802_394_763_324,
        6.803_505_257_608,
        6.804_614_520_063,
        6.805_722_553_417,
        6.806_829_360_392,
        6.807_934_943_7,
        6.809_039_306_043,
        6.810_142_450_115,
        6.811_244_378_601,
        6.812_345_094_177,
        6.813_444_599_511,
        6.814_542_897_26,
        6.815_639_990_074,
        6.816_735_880_595,
        6.817_830_571_454,
        6.818_924_065_276,
        6.820_016_364_674,
        6.821_107_472_256,
        6.822_197_390_62,
        6.823_286_122_356,
        6.824_373_670_043,
        6.825_460_036_255,
        6.826_545_223_557,
        6.827_629_234_503,
        6.828_712_071_642,
        6.829_793_737_512,
        6.830_874_234_646,
        6.831_953_565_566,
        6.833_031_732_786,
        6.834_108_738_814,
        6.835_184_586_147,
        6.836_259_277_277,
        6.837_332_814_686,
        6.838_405_200_847,
        6.839_476_438_229,
        6.840_546_529_289,
        6.841_615_476_478,
        6.842_683_282_238,
        6.843_749_949_006,
        6.844_815_479_208,
        6.845_879_875_264,
        6.846_943_139_585,
        6.848_005_274_576,
        6.849_066_282_633,
        6.850_126_166_146,
        6.851_184_927_494,
        6.852_242_569_052,
        6.853_299_093_186,
        6.854_354_502_255,
        6.855_408_798_61,
        6.856_461_984_595,
        6.857_514_062_545,
        6.858_565_034_791,
        6.859_614_903_654,
        6.860_663_671_448,
        6.861_711_340_481,
        6.862_757_913_051,
        6.863_803_391_453,
        6.864_847_777_971,
        6.865_891_074_883,
        6.866_933_284_462,
        6.867_974_408_97,
        6.869_014_450_666,
        6.870_053_411_798,
        6.871_091_294_611,
        6.872_128_101_339,
        6.873_163_834_213,
        6.874_198_495_453,
        6.875_232_087_277,
        6.876_264_611_891,
        6.877_296_071_497,
        6.878_326_468_291,
        6.879_355_804_46,
        6.880_384_082_186,
        6.881_411_303_643,
        6.882_437_470_998,
        6.883_462_586_413,
        6.884_486_652_043,
        6.885_509_670_035,
        6.886_531_642_531,
        6.887_552_571_665,
        6.888_572_459_565,
        6.889_591_308_354,
        6.890_609_120_147,
        6.891_625_897_052,
        6.892_641_641_172,
        6.893_656_354_603,
        6.894_670_039_433,
        6.895_682_697_748,
        6.896_694_331_623,
        6.897_704_943_129,
        6.898_714_534_33,
        6.899_723_107_285,
        6.900_730_664_045,
        6.901_737_206_657,
        6.902_742_737_159,
        6.903_747_257_585,
        6.904_750_769_962,
        6.905_753_276_311,
        6.906_754_778_649,
        6.907_755_278_982,
        6.908_754_779_315,
        6.909_753_281_645,
        6.910_750_787_962,
        6.911_747_300_252,
        6.912_742_820_493,
        6.913_737_350_66,
        6.914_730_892_719,
        6.915_723_448_631,
        6.916_715_020_354,
        6.917_705_609_835,
        6.918_695_219_02,
        6.919_683_849_847,
        6.920_671_504_249,
        6.921_658_184_151,
        6.922_643_891_476,
        6.923_628_628_138,
        6.924_612_396_049,
        6.925_595_197_11,
        6.926_577_033_223,
        6.927_557_906_278,
        6.928_537_818_165,
        6.929_516_770_764,
        6.930_494_765_952,
        6.931_471_805_599,
    ];
    /// Beta factors for the [`LogLogBeta`] approach.
    const BETA_4: [f64; 8] = [
        -0.582_581_414,
        -1.935_300_358,
        11.079_323_758,
        -22.131_357_446,
        22.505_391_847,
        -12.000_723_835,
        3.220_579_408,
        -0.342_225_302,
    ];
    /// Beta factors for the [`LogLogBeta`] approach.
    const BETA_5: [f64; 8] = [
        -0.751_899_946,
        -0.959_003_008,
        5.599_737_132,
        -8.209_763_7,
        6.509_125_489,
        -2.683_029_373,
        0.561_289_111,
        -0.046_333_162,
    ];
    /// Beta factors for the [`LogLogBeta`] approach.
    const BETA_6: [f64; 8] = [
        29.825_790_097,
        -31.328_708_334,
        -10.594_252_304,
        -11.572_012_569,
        3.818_875_437,
        -2.416_013_033,
        0.454_220_894,
        -0.057_515_545,
    ];
    /// Beta factors for the [`LogLogBeta`] approach.
    const BETA_7: [f64; 8] = [
        2.810_292_129,
        -3.978_049_852,
        1.316_268_004,
        -3.925_248_634,
        2.008_083_575,
        -0.752_715_194,
        0.126_556_989,
        -0.010_994_644,
    ];
    /// Beta factors for the [`LogLogBeta`] approach.
    const BETA_8: [f64; 8] = [
        1.006_335_449,
        -2.005_806_664,
        1.643_697_494,
        -2.705_608_099,
        1.392_099_802,
        -0.464_703_743,
        0.073_842_824,
        -0.005_785_549,
    ];
    /// Beta factors for the [`LogLogBeta`] approach.
    const BETA_9: [f64; 8] = [
        -0.094_156_575,
        -0.781_309_759,
        1.715_149_468,
        -1.737_112_504,
        0.864_415_085,
        -0.238_190_275,
        0.033_434_484,
        -0.002_078_585,
    ];
    /// Beta factors for the [`LogLogBeta`] approach.
    const BETA_10: [f64; 8] = [
        -0.259_354_007,
        -0.525_983_02,
        1.489_330_349,
        -1.296_427_141,
        0.622_847_562,
        -0.156_723_268,
        0.020_544_159,
        -0.001_124_885,
    ];
    #[cfg(feature = "plusplus")]
    /// Computes the bias correction factor for the estimate using either
    /// the k-means algorithm or the simpler linear interpolation.
    fn bias<const N: usize, V: PartialOrd + Two + Number, W: Number>(
        estimates: &'static [V; N],
        biases: &'static [W; N],
        estimate: V,
    ) -> f64
    where
        f64: From<V> + From<W>,
    {
        #[cfg(not(feature = "plusplus_kmeans"))]
        return {
            let index = estimates
                .partition_point(|estimate_centroid| estimate_centroid <= &estimate);
            if index == 0 {
                return f64::from(biases[0]);
            }
            if index == N {
                return f64::from(biases[N - 1]);
            }
            let x0 = f64::from(estimates[index - 1]);
            let x1 = f64::from(estimates[index]);
            let y0 = f64::from(biases[index - 1]);
            let y1 = f64::from(biases[index]);
            y0 + (y1 - y0) * (f64::from(estimate) - x0) / (x1 - x0)
        };
    }
    /// The precision of the [`HyperLogLog`] counter.
    pub trait Precision: Default + Copy + Eq + Debug + Send + Sync {
        /// The data type to use for the number of zeros registers counter.
        /// This should be the smallest possinle data type that allows us to count
        /// all the registers without overflowing. We can tollerate a one-off error
        /// when counting the number of zeros, as it will be corrected when computing
        /// the cardinality as it is known before hand whether this can happen at all.
        type NumberOfRegisters: PositiveInteger;
        /// The exponent of the number of registers, meaning the number of registers
        /// that will be used is 2^EXPONENT. This is the p parameter in the [`HyperLogLog`].
        const EXPONENT: u8;
        /// The number of registers that will be used.
        const NUMBER_OF_REGISTERS: Self::NumberOfRegisters;
        #[must_use]
        #[inline]
        /// The theoretical error rate of the precision.
        fn error_rate() -> f64 {
            1.04 / 2_f64.powf(f64::from(Self::EXPONENT) / 2.0)
        }
        /// The alpha constant for the precision, used in the estimation of the cardinality.
        const ALPHA: f64;
        #[cfg(feature = "plusplus")]
        /// The number of zero registers over which the counter should switch to the linear counting.
        const LINEAR_COUNT_ZEROS: Self::NumberOfRegisters;
        #[cfg(feature = "beta")]
        /// Computes LogLog-Beta estimate bias correction using Horner's method.
        ///
        /// Paper: <https://arxiv.org/pdf/1612.02284.pdf>
        /// Wikipedia: <https://en.wikipedia.org/wiki/Horner%27s_method>
        fn beta_estimate(
            harmonic_sum: f64,
            number_of_zero_registers: Self::NumberOfRegisters,
        ) -> f64;
        #[cfg(feature = "plusplus")]
        /// Computes the small correction factor for the estimate.
        fn small_correction(number_of_zero_registers: Self::NumberOfRegisters) -> f64;
        /// Computes the bias correction factor for the estimate.
        fn bias(estimate: f64) -> f64;
        #[cfg(feature = "plusplus")]
        #[inline]
        /// Computes the estimate of the cardinality using the `LogLog++` algorithm.
        fn plusplus_estimate(
            harmonic_sum: f64,
            number_of_zeros: Self::NumberOfRegisters,
        ) -> f64 {
            if number_of_zeros >= Self::LINEAR_COUNT_ZEROS {
                return Self::small_correction(number_of_zeros);
            }
            let estimate = Self::ALPHA
                * f64::integer_exp2(Self::EXPONENT + Self::EXPONENT) / harmonic_sum;
            if estimate <= 5.0_f64 * f64::integer_exp2(Self::EXPONENT) {
                estimate - Self::bias(estimate)
            } else {
                estimate
            }
        }
    }
    #[non_exhaustive]
    /// The precision of the HyperLogLog counter.
    pub struct Precision4;
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Precision4 {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_unit_struct(__serializer, "Precision4")
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Precision4 {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Precision4>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Precision4;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "unit struct Precision4",
                        )
                    }
                    #[inline]
                    fn visit_unit<__E>(
                        self,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(Precision4)
                    }
                }
                _serde::Deserializer::deserialize_unit_struct(
                    __deserializer,
                    "Precision4",
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Precision4>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for Precision4 {
        #[inline]
        fn default() -> Precision4 {
            Precision4 {}
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Precision4 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Precision4")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Precision4 {
        #[inline]
        fn clone(&self) -> Precision4 {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Precision4 {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Precision4 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Precision4 {
        #[inline]
        fn eq(&self, other: &Precision4) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Precision4 {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Precision4 {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[cfg(all(feature = "precision_4", feature = "std"))]
    impl crate::prelude::Named for Precision4 {
        #[inline]
        fn name(&self) -> String {
            ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("P{0}", 4));
                res
            })
        }
    }
    #[cfg(feature = "precision_4")]
    impl Precision for Precision4 {
        type NumberOfRegisters = NumberOfRegisters4;
        const EXPONENT: u8 = 4;
        const NUMBER_OF_REGISTERS: Self::NumberOfRegisters = NumberOfRegisters4::ONE
            << 4;
        const ALPHA: f64 = ALPHA_4;
        #[cfg(feature = "plusplus")]
        const LINEAR_COUNT_ZEROS: Self::NumberOfRegisters = LINEAR_COUNT_ZEROS_4;
        #[inline]
        #[cfg(feature = "plusplus")]
        fn bias(estimate: f64) -> f64 {
            #[cfg(not(feature = "integer_plusplus"))]
            return bias(&ESTIMATES_4, &BIAS_4, estimate);
        }
        /// Computes LogLog-Beta estimate bias correction using Horner's method.
        ///
        /// Paper: https://arxiv.org/pdf/1612.02284.pdf
        /// Wikipedia: https://en.wikipedia.org/wiki/Horner%27s_method
        #[inline]
        #[cfg(feature = "beta")]
        fn beta_estimate(
            harmonic_sum: f64,
            number_of_zero_registers: Self::NumberOfRegisters,
        ) -> f64 {
            if number_of_zero_registers >= LINEAR_COUNT_ZEROS_4 {
                return Self::small_correction(number_of_zero_registers);
            }
            #[cfg(not(feature = "precomputed_beta"))]
            let beta_horner = {
                let number_of_zero_registers_ln = LN_VALUES[1
                    + usize::try_from(number_of_zero_registers).unwrap()];
                let mut res = f64::ZERO;
                for i in (1..8).rev() {
                    res = res * number_of_zero_registers_ln + BETA_4[i];
                }
                res * number_of_zero_registers_ln
                    + BETA_4[0] * f64::from(number_of_zero_registers)
            };
            ALPHA_4 * f64::integer_exp2(Self::EXPONENT)
                * (f64::integer_exp2(Self::EXPONENT)
                    - f64::from(number_of_zero_registers)) / (harmonic_sum + beta_horner)
                + 0.5
        }
        #[inline(always)]
        #[cfg(feature = "plusplus")]
        fn small_correction(number_of_zero_registers: Self::NumberOfRegisters) -> f64 {
            f64::integer_exp2(Self::EXPONENT)
                * (f64::from(Self::EXPONENT) * core::f64::consts::LN_2
                    - LN_VALUES[usize::try_from(number_of_zero_registers).unwrap()])
        }
    }
    #[non_exhaustive]
    /// The precision of the HyperLogLog counter.
    pub struct Precision5;
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Precision5 {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_unit_struct(__serializer, "Precision5")
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Precision5 {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Precision5>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Precision5;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "unit struct Precision5",
                        )
                    }
                    #[inline]
                    fn visit_unit<__E>(
                        self,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(Precision5)
                    }
                }
                _serde::Deserializer::deserialize_unit_struct(
                    __deserializer,
                    "Precision5",
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Precision5>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for Precision5 {
        #[inline]
        fn default() -> Precision5 {
            Precision5 {}
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Precision5 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Precision5")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Precision5 {
        #[inline]
        fn clone(&self) -> Precision5 {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Precision5 {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Precision5 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Precision5 {
        #[inline]
        fn eq(&self, other: &Precision5) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Precision5 {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Precision5 {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[cfg(all(feature = "precision_5", feature = "std"))]
    impl crate::prelude::Named for Precision5 {
        #[inline]
        fn name(&self) -> String {
            ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("P{0}", 5));
                res
            })
        }
    }
    #[cfg(feature = "precision_5")]
    impl Precision for Precision5 {
        type NumberOfRegisters = NumberOfRegisters5;
        const EXPONENT: u8 = 5;
        const NUMBER_OF_REGISTERS: Self::NumberOfRegisters = NumberOfRegisters5::ONE
            << 5;
        const ALPHA: f64 = ALPHA_5;
        #[cfg(feature = "plusplus")]
        const LINEAR_COUNT_ZEROS: Self::NumberOfRegisters = LINEAR_COUNT_ZEROS_5;
        #[inline]
        #[cfg(feature = "plusplus")]
        fn bias(estimate: f64) -> f64 {
            #[cfg(not(feature = "integer_plusplus"))]
            return bias(&ESTIMATES_5, &BIAS_5, estimate);
        }
        /// Computes LogLog-Beta estimate bias correction using Horner's method.
        ///
        /// Paper: https://arxiv.org/pdf/1612.02284.pdf
        /// Wikipedia: https://en.wikipedia.org/wiki/Horner%27s_method
        #[inline]
        #[cfg(feature = "beta")]
        fn beta_estimate(
            harmonic_sum: f64,
            number_of_zero_registers: Self::NumberOfRegisters,
        ) -> f64 {
            if number_of_zero_registers >= LINEAR_COUNT_ZEROS_5 {
                return Self::small_correction(number_of_zero_registers);
            }
            #[cfg(not(feature = "precomputed_beta"))]
            let beta_horner = {
                let number_of_zero_registers_ln = LN_VALUES[1
                    + usize::try_from(number_of_zero_registers).unwrap()];
                let mut res = f64::ZERO;
                for i in (1..8).rev() {
                    res = res * number_of_zero_registers_ln + BETA_5[i];
                }
                res * number_of_zero_registers_ln
                    + BETA_5[0] * f64::from(number_of_zero_registers)
            };
            ALPHA_5 * f64::integer_exp2(Self::EXPONENT)
                * (f64::integer_exp2(Self::EXPONENT)
                    - f64::from(number_of_zero_registers)) / (harmonic_sum + beta_horner)
                + 0.5
        }
        #[inline(always)]
        #[cfg(feature = "plusplus")]
        fn small_correction(number_of_zero_registers: Self::NumberOfRegisters) -> f64 {
            f64::integer_exp2(Self::EXPONENT)
                * (f64::from(Self::EXPONENT) * core::f64::consts::LN_2
                    - LN_VALUES[usize::try_from(number_of_zero_registers).unwrap()])
        }
    }
    #[non_exhaustive]
    /// The precision of the HyperLogLog counter.
    pub struct Precision6;
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Precision6 {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_unit_struct(__serializer, "Precision6")
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Precision6 {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Precision6>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Precision6;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "unit struct Precision6",
                        )
                    }
                    #[inline]
                    fn visit_unit<__E>(
                        self,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(Precision6)
                    }
                }
                _serde::Deserializer::deserialize_unit_struct(
                    __deserializer,
                    "Precision6",
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Precision6>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for Precision6 {
        #[inline]
        fn default() -> Precision6 {
            Precision6 {}
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Precision6 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Precision6")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Precision6 {
        #[inline]
        fn clone(&self) -> Precision6 {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Precision6 {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Precision6 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Precision6 {
        #[inline]
        fn eq(&self, other: &Precision6) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Precision6 {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Precision6 {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[cfg(all(feature = "precision_6", feature = "std"))]
    impl crate::prelude::Named for Precision6 {
        #[inline]
        fn name(&self) -> String {
            ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("P{0}", 6));
                res
            })
        }
    }
    #[cfg(feature = "precision_6")]
    impl Precision for Precision6 {
        type NumberOfRegisters = NumberOfRegisters6;
        const EXPONENT: u8 = 6;
        const NUMBER_OF_REGISTERS: Self::NumberOfRegisters = NumberOfRegisters6::ONE
            << 6;
        const ALPHA: f64 = ALPHA_6;
        #[cfg(feature = "plusplus")]
        const LINEAR_COUNT_ZEROS: Self::NumberOfRegisters = LINEAR_COUNT_ZEROS_6;
        #[inline]
        #[cfg(feature = "plusplus")]
        fn bias(estimate: f64) -> f64 {
            #[cfg(not(feature = "integer_plusplus"))]
            return bias(&ESTIMATES_6, &BIAS_6, estimate);
        }
        /// Computes LogLog-Beta estimate bias correction using Horner's method.
        ///
        /// Paper: https://arxiv.org/pdf/1612.02284.pdf
        /// Wikipedia: https://en.wikipedia.org/wiki/Horner%27s_method
        #[inline]
        #[cfg(feature = "beta")]
        fn beta_estimate(
            harmonic_sum: f64,
            number_of_zero_registers: Self::NumberOfRegisters,
        ) -> f64 {
            if number_of_zero_registers >= LINEAR_COUNT_ZEROS_6 {
                return Self::small_correction(number_of_zero_registers);
            }
            #[cfg(not(feature = "precomputed_beta"))]
            let beta_horner = {
                let number_of_zero_registers_ln = LN_VALUES[1
                    + usize::try_from(number_of_zero_registers).unwrap()];
                let mut res = f64::ZERO;
                for i in (1..8).rev() {
                    res = res * number_of_zero_registers_ln + BETA_6[i];
                }
                res * number_of_zero_registers_ln
                    + BETA_6[0] * f64::from(number_of_zero_registers)
            };
            ALPHA_6 * f64::integer_exp2(Self::EXPONENT)
                * (f64::integer_exp2(Self::EXPONENT)
                    - f64::from(number_of_zero_registers)) / (harmonic_sum + beta_horner)
                + 0.5
        }
        #[inline(always)]
        #[cfg(feature = "plusplus")]
        fn small_correction(number_of_zero_registers: Self::NumberOfRegisters) -> f64 {
            f64::integer_exp2(Self::EXPONENT)
                * (f64::from(Self::EXPONENT) * core::f64::consts::LN_2
                    - LN_VALUES[usize::try_from(number_of_zero_registers).unwrap()])
        }
    }
    #[non_exhaustive]
    /// The precision of the HyperLogLog counter.
    pub struct Precision7;
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Precision7 {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_unit_struct(__serializer, "Precision7")
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Precision7 {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Precision7>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Precision7;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "unit struct Precision7",
                        )
                    }
                    #[inline]
                    fn visit_unit<__E>(
                        self,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(Precision7)
                    }
                }
                _serde::Deserializer::deserialize_unit_struct(
                    __deserializer,
                    "Precision7",
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Precision7>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for Precision7 {
        #[inline]
        fn default() -> Precision7 {
            Precision7 {}
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Precision7 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Precision7")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Precision7 {
        #[inline]
        fn clone(&self) -> Precision7 {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Precision7 {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Precision7 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Precision7 {
        #[inline]
        fn eq(&self, other: &Precision7) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Precision7 {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Precision7 {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[cfg(all(feature = "precision_7", feature = "std"))]
    impl crate::prelude::Named for Precision7 {
        #[inline]
        fn name(&self) -> String {
            ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("P{0}", 7));
                res
            })
        }
    }
    #[cfg(feature = "precision_7")]
    impl Precision for Precision7 {
        type NumberOfRegisters = NumberOfRegisters7;
        const EXPONENT: u8 = 7;
        const NUMBER_OF_REGISTERS: Self::NumberOfRegisters = NumberOfRegisters7::ONE
            << 7;
        const ALPHA: f64 = ALPHA_7;
        #[cfg(feature = "plusplus")]
        const LINEAR_COUNT_ZEROS: Self::NumberOfRegisters = LINEAR_COUNT_ZEROS_7;
        #[inline]
        #[cfg(feature = "plusplus")]
        fn bias(estimate: f64) -> f64 {
            #[cfg(not(feature = "integer_plusplus"))]
            return bias(&ESTIMATES_7, &BIAS_7, estimate);
        }
        /// Computes LogLog-Beta estimate bias correction using Horner's method.
        ///
        /// Paper: https://arxiv.org/pdf/1612.02284.pdf
        /// Wikipedia: https://en.wikipedia.org/wiki/Horner%27s_method
        #[inline]
        #[cfg(feature = "beta")]
        fn beta_estimate(
            harmonic_sum: f64,
            number_of_zero_registers: Self::NumberOfRegisters,
        ) -> f64 {
            if number_of_zero_registers >= LINEAR_COUNT_ZEROS_7 {
                return Self::small_correction(number_of_zero_registers);
            }
            #[cfg(not(feature = "precomputed_beta"))]
            let beta_horner = {
                let number_of_zero_registers_ln = LN_VALUES[1
                    + usize::try_from(number_of_zero_registers).unwrap()];
                let mut res = f64::ZERO;
                for i in (1..8).rev() {
                    res = res * number_of_zero_registers_ln + BETA_7[i];
                }
                res * number_of_zero_registers_ln
                    + BETA_7[0] * f64::from(number_of_zero_registers)
            };
            ALPHA_7 * f64::integer_exp2(Self::EXPONENT)
                * (f64::integer_exp2(Self::EXPONENT)
                    - f64::from(number_of_zero_registers)) / (harmonic_sum + beta_horner)
                + 0.5
        }
        #[inline(always)]
        #[cfg(feature = "plusplus")]
        fn small_correction(number_of_zero_registers: Self::NumberOfRegisters) -> f64 {
            f64::integer_exp2(Self::EXPONENT)
                * (f64::from(Self::EXPONENT) * core::f64::consts::LN_2
                    - LN_VALUES[usize::try_from(number_of_zero_registers).unwrap()])
        }
    }
    #[non_exhaustive]
    /// The precision of the HyperLogLog counter.
    pub struct Precision8;
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Precision8 {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_unit_struct(__serializer, "Precision8")
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Precision8 {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Precision8>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Precision8;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "unit struct Precision8",
                        )
                    }
                    #[inline]
                    fn visit_unit<__E>(
                        self,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(Precision8)
                    }
                }
                _serde::Deserializer::deserialize_unit_struct(
                    __deserializer,
                    "Precision8",
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Precision8>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for Precision8 {
        #[inline]
        fn default() -> Precision8 {
            Precision8 {}
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Precision8 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Precision8")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Precision8 {
        #[inline]
        fn clone(&self) -> Precision8 {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Precision8 {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Precision8 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Precision8 {
        #[inline]
        fn eq(&self, other: &Precision8) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Precision8 {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Precision8 {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[cfg(all(feature = "precision_8", feature = "std"))]
    impl crate::prelude::Named for Precision8 {
        #[inline]
        fn name(&self) -> String {
            ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("P{0}", 8));
                res
            })
        }
    }
    #[cfg(feature = "precision_8")]
    impl Precision for Precision8 {
        type NumberOfRegisters = NumberOfRegisters8;
        const EXPONENT: u8 = 8;
        const NUMBER_OF_REGISTERS: Self::NumberOfRegisters = NumberOfRegisters8::ONE
            << 8;
        const ALPHA: f64 = ALPHA_8;
        #[cfg(feature = "plusplus")]
        const LINEAR_COUNT_ZEROS: Self::NumberOfRegisters = LINEAR_COUNT_ZEROS_8;
        #[inline]
        #[cfg(feature = "plusplus")]
        fn bias(estimate: f64) -> f64 {
            #[cfg(not(feature = "integer_plusplus"))]
            return bias(&ESTIMATES_8, &BIAS_8, estimate);
        }
        /// Computes LogLog-Beta estimate bias correction using Horner's method.
        ///
        /// Paper: https://arxiv.org/pdf/1612.02284.pdf
        /// Wikipedia: https://en.wikipedia.org/wiki/Horner%27s_method
        #[inline]
        #[cfg(feature = "beta")]
        fn beta_estimate(
            harmonic_sum: f64,
            number_of_zero_registers: Self::NumberOfRegisters,
        ) -> f64 {
            if number_of_zero_registers >= LINEAR_COUNT_ZEROS_8 {
                return Self::small_correction(number_of_zero_registers);
            }
            #[cfg(not(feature = "precomputed_beta"))]
            let beta_horner = {
                let number_of_zero_registers_ln = LN_VALUES[1
                    + usize::try_from(number_of_zero_registers).unwrap()];
                let mut res = f64::ZERO;
                for i in (1..8).rev() {
                    res = res * number_of_zero_registers_ln + BETA_8[i];
                }
                res * number_of_zero_registers_ln
                    + BETA_8[0] * f64::from(number_of_zero_registers)
            };
            ALPHA_8 * f64::integer_exp2(Self::EXPONENT)
                * (f64::integer_exp2(Self::EXPONENT)
                    - f64::from(number_of_zero_registers)) / (harmonic_sum + beta_horner)
                + 0.5
        }
        #[inline(always)]
        #[cfg(feature = "plusplus")]
        fn small_correction(number_of_zero_registers: Self::NumberOfRegisters) -> f64 {
            f64::integer_exp2(Self::EXPONENT)
                * (f64::from(Self::EXPONENT) * core::f64::consts::LN_2
                    - LN_VALUES[usize::try_from(number_of_zero_registers).unwrap()])
        }
    }
    #[non_exhaustive]
    /// The precision of the HyperLogLog counter.
    pub struct Precision9;
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Precision9 {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_unit_struct(__serializer, "Precision9")
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Precision9 {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Precision9>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Precision9;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "unit struct Precision9",
                        )
                    }
                    #[inline]
                    fn visit_unit<__E>(
                        self,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(Precision9)
                    }
                }
                _serde::Deserializer::deserialize_unit_struct(
                    __deserializer,
                    "Precision9",
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Precision9>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for Precision9 {
        #[inline]
        fn default() -> Precision9 {
            Precision9 {}
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Precision9 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Precision9")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Precision9 {
        #[inline]
        fn clone(&self) -> Precision9 {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Precision9 {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Precision9 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Precision9 {
        #[inline]
        fn eq(&self, other: &Precision9) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Precision9 {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Precision9 {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[cfg(all(feature = "precision_9", feature = "std"))]
    impl crate::prelude::Named for Precision9 {
        #[inline]
        fn name(&self) -> String {
            ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("P{0}", 9));
                res
            })
        }
    }
    #[cfg(feature = "precision_9")]
    impl Precision for Precision9 {
        type NumberOfRegisters = NumberOfRegisters9;
        const EXPONENT: u8 = 9;
        const NUMBER_OF_REGISTERS: Self::NumberOfRegisters = NumberOfRegisters9::ONE
            << 9;
        const ALPHA: f64 = ALPHA_9;
        #[cfg(feature = "plusplus")]
        const LINEAR_COUNT_ZEROS: Self::NumberOfRegisters = LINEAR_COUNT_ZEROS_9;
        #[inline]
        #[cfg(feature = "plusplus")]
        fn bias(estimate: f64) -> f64 {
            #[cfg(not(feature = "integer_plusplus"))]
            return bias(&ESTIMATES_9, &BIAS_9, estimate);
        }
        /// Computes LogLog-Beta estimate bias correction using Horner's method.
        ///
        /// Paper: https://arxiv.org/pdf/1612.02284.pdf
        /// Wikipedia: https://en.wikipedia.org/wiki/Horner%27s_method
        #[inline]
        #[cfg(feature = "beta")]
        fn beta_estimate(
            harmonic_sum: f64,
            number_of_zero_registers: Self::NumberOfRegisters,
        ) -> f64 {
            if number_of_zero_registers >= LINEAR_COUNT_ZEROS_9 {
                return Self::small_correction(number_of_zero_registers);
            }
            #[cfg(not(feature = "precomputed_beta"))]
            let beta_horner = {
                let number_of_zero_registers_ln = LN_VALUES[1
                    + usize::try_from(number_of_zero_registers).unwrap()];
                let mut res = f64::ZERO;
                for i in (1..8).rev() {
                    res = res * number_of_zero_registers_ln + BETA_9[i];
                }
                res * number_of_zero_registers_ln
                    + BETA_9[0] * f64::from(number_of_zero_registers)
            };
            ALPHA_9 * f64::integer_exp2(Self::EXPONENT)
                * (f64::integer_exp2(Self::EXPONENT)
                    - f64::from(number_of_zero_registers)) / (harmonic_sum + beta_horner)
                + 0.5
        }
        #[inline(always)]
        #[cfg(feature = "plusplus")]
        fn small_correction(number_of_zero_registers: Self::NumberOfRegisters) -> f64 {
            f64::integer_exp2(Self::EXPONENT)
                * (f64::from(Self::EXPONENT) * core::f64::consts::LN_2
                    - LN_VALUES[usize::try_from(number_of_zero_registers).unwrap()])
        }
    }
    #[non_exhaustive]
    /// The precision of the HyperLogLog counter.
    pub struct Precision10;
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Precision10 {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_unit_struct(__serializer, "Precision10")
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Precision10 {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Precision10>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Precision10;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "unit struct Precision10",
                        )
                    }
                    #[inline]
                    fn visit_unit<__E>(
                        self,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(Precision10)
                    }
                }
                _serde::Deserializer::deserialize_unit_struct(
                    __deserializer,
                    "Precision10",
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Precision10>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for Precision10 {
        #[inline]
        fn default() -> Precision10 {
            Precision10 {}
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Precision10 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Precision10")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Precision10 {
        #[inline]
        fn clone(&self) -> Precision10 {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Precision10 {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Precision10 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Precision10 {
        #[inline]
        fn eq(&self, other: &Precision10) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Precision10 {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Precision10 {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[cfg(all(feature = "precision_10", feature = "std"))]
    impl crate::prelude::Named for Precision10 {
        #[inline]
        fn name(&self) -> String {
            ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(format_args!("P{0}", 10));
                res
            })
        }
    }
    #[cfg(feature = "precision_10")]
    impl Precision for Precision10 {
        type NumberOfRegisters = NumberOfRegisters10;
        const EXPONENT: u8 = 10;
        const NUMBER_OF_REGISTERS: Self::NumberOfRegisters = NumberOfRegisters10::ONE
            << 10;
        const ALPHA: f64 = ALPHA_10;
        #[cfg(feature = "plusplus")]
        const LINEAR_COUNT_ZEROS: Self::NumberOfRegisters = LINEAR_COUNT_ZEROS_10;
        #[inline]
        #[cfg(feature = "plusplus")]
        fn bias(estimate: f64) -> f64 {
            #[cfg(not(feature = "integer_plusplus"))]
            return bias(&ESTIMATES_10, &BIAS_10, estimate);
        }
        /// Computes LogLog-Beta estimate bias correction using Horner's method.
        ///
        /// Paper: https://arxiv.org/pdf/1612.02284.pdf
        /// Wikipedia: https://en.wikipedia.org/wiki/Horner%27s_method
        #[inline]
        #[cfg(feature = "beta")]
        fn beta_estimate(
            harmonic_sum: f64,
            number_of_zero_registers: Self::NumberOfRegisters,
        ) -> f64 {
            if number_of_zero_registers >= LINEAR_COUNT_ZEROS_10 {
                return Self::small_correction(number_of_zero_registers);
            }
            #[cfg(not(feature = "precomputed_beta"))]
            let beta_horner = {
                let number_of_zero_registers_ln = LN_VALUES[1
                    + usize::try_from(number_of_zero_registers).unwrap()];
                let mut res = f64::ZERO;
                for i in (1..8).rev() {
                    res = res * number_of_zero_registers_ln + BETA_10[i];
                }
                res * number_of_zero_registers_ln
                    + BETA_10[0] * f64::from(number_of_zero_registers)
            };
            ALPHA_10 * f64::integer_exp2(Self::EXPONENT)
                * (f64::integer_exp2(Self::EXPONENT)
                    - f64::from(number_of_zero_registers)) / (harmonic_sum + beta_horner)
                + 0.5
        }
        #[inline(always)]
        #[cfg(feature = "plusplus")]
        fn small_correction(number_of_zero_registers: Self::NumberOfRegisters) -> f64 {
            f64::integer_exp2(Self::EXPONENT)
                * (f64::from(Self::EXPONENT) * core::f64::consts::LN_2
                    - LN_VALUES[usize::try_from(number_of_zero_registers).unwrap()])
        }
    }
    #[non_exhaustive]
    /// The precision of the HyperLogLog counter.
    pub struct Precision11;
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Precision11 {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_unit_struct(__serializer, "Precision11")
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Precision11 {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Precision11>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Precision11;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "unit struct Precision11",
                        )
                    }
                    #[inline]
                    fn visit_unit<__E>(
                        self,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(Precision11)
                    }
                }
                _serde::Deserializer::deserialize_unit_struct(
                    __deserializer,
                    "Precision11",
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Precision11>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for Precision11 {
        #[inline]
        fn default() -> Precision11 {
            Precision11 {}
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Precision11 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Precision11")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Precision11 {
        #[inline]
        fn clone(&self) -> Precision11 {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Precision11 {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Precision11 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Precision11 {
        #[inline]
        fn eq(&self, other: &Precision11) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Precision11 {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Precision11 {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[non_exhaustive]
    /// The precision of the HyperLogLog counter.
    pub struct Precision12;
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Precision12 {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_unit_struct(__serializer, "Precision12")
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Precision12 {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Precision12>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Precision12;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "unit struct Precision12",
                        )
                    }
                    #[inline]
                    fn visit_unit<__E>(
                        self,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(Precision12)
                    }
                }
                _serde::Deserializer::deserialize_unit_struct(
                    __deserializer,
                    "Precision12",
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Precision12>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for Precision12 {
        #[inline]
        fn default() -> Precision12 {
            Precision12 {}
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Precision12 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Precision12")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Precision12 {
        #[inline]
        fn clone(&self) -> Precision12 {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Precision12 {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Precision12 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Precision12 {
        #[inline]
        fn eq(&self, other: &Precision12) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Precision12 {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Precision12 {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[non_exhaustive]
    /// The precision of the HyperLogLog counter.
    pub struct Precision13;
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Precision13 {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_unit_struct(__serializer, "Precision13")
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Precision13 {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Precision13>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Precision13;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "unit struct Precision13",
                        )
                    }
                    #[inline]
                    fn visit_unit<__E>(
                        self,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(Precision13)
                    }
                }
                _serde::Deserializer::deserialize_unit_struct(
                    __deserializer,
                    "Precision13",
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Precision13>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for Precision13 {
        #[inline]
        fn default() -> Precision13 {
            Precision13 {}
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Precision13 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Precision13")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Precision13 {
        #[inline]
        fn clone(&self) -> Precision13 {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Precision13 {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Precision13 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Precision13 {
        #[inline]
        fn eq(&self, other: &Precision13) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Precision13 {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Precision13 {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[non_exhaustive]
    /// The precision of the HyperLogLog counter.
    pub struct Precision14;
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Precision14 {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_unit_struct(__serializer, "Precision14")
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Precision14 {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Precision14>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Precision14;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "unit struct Precision14",
                        )
                    }
                    #[inline]
                    fn visit_unit<__E>(
                        self,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(Precision14)
                    }
                }
                _serde::Deserializer::deserialize_unit_struct(
                    __deserializer,
                    "Precision14",
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Precision14>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for Precision14 {
        #[inline]
        fn default() -> Precision14 {
            Precision14 {}
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Precision14 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Precision14")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Precision14 {
        #[inline]
        fn clone(&self) -> Precision14 {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Precision14 {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Precision14 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Precision14 {
        #[inline]
        fn eq(&self, other: &Precision14) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Precision14 {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Precision14 {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[non_exhaustive]
    /// The precision of the HyperLogLog counter.
    pub struct Precision15;
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Precision15 {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_unit_struct(__serializer, "Precision15")
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Precision15 {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Precision15>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Precision15;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "unit struct Precision15",
                        )
                    }
                    #[inline]
                    fn visit_unit<__E>(
                        self,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(Precision15)
                    }
                }
                _serde::Deserializer::deserialize_unit_struct(
                    __deserializer,
                    "Precision15",
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Precision15>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for Precision15 {
        #[inline]
        fn default() -> Precision15 {
            Precision15 {}
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Precision15 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Precision15")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Precision15 {
        #[inline]
        fn clone(&self) -> Precision15 {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Precision15 {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Precision15 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Precision15 {
        #[inline]
        fn eq(&self, other: &Precision15) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Precision15 {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Precision15 {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[non_exhaustive]
    /// The precision of the HyperLogLog counter.
    pub struct Precision16;
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Precision16 {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_unit_struct(__serializer, "Precision16")
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Precision16 {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Precision16>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Precision16;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "unit struct Precision16",
                        )
                    }
                    #[inline]
                    fn visit_unit<__E>(
                        self,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(Precision16)
                    }
                }
                _serde::Deserializer::deserialize_unit_struct(
                    __deserializer,
                    "Precision16",
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Precision16>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for Precision16 {
        #[inline]
        fn default() -> Precision16 {
            Precision16 {}
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Precision16 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Precision16")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Precision16 {
        #[inline]
        fn clone(&self) -> Precision16 {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Precision16 {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Precision16 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Precision16 {
        #[inline]
        fn eq(&self, other: &Precision16) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Precision16 {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Precision16 {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[non_exhaustive]
    /// The precision of the HyperLogLog counter.
    pub struct Precision17;
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Precision17 {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_unit_struct(__serializer, "Precision17")
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Precision17 {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Precision17>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Precision17;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "unit struct Precision17",
                        )
                    }
                    #[inline]
                    fn visit_unit<__E>(
                        self,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(Precision17)
                    }
                }
                _serde::Deserializer::deserialize_unit_struct(
                    __deserializer,
                    "Precision17",
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Precision17>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for Precision17 {
        #[inline]
        fn default() -> Precision17 {
            Precision17 {}
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Precision17 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Precision17")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Precision17 {
        #[inline]
        fn clone(&self) -> Precision17 {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Precision17 {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Precision17 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Precision17 {
        #[inline]
        fn eq(&self, other: &Precision17) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Precision17 {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Precision17 {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
    #[non_exhaustive]
    /// The precision of the HyperLogLog counter.
    pub struct Precision18;
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Precision18 {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_unit_struct(__serializer, "Precision18")
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Precision18 {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Precision18>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Precision18;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "unit struct Precision18",
                        )
                    }
                    #[inline]
                    fn visit_unit<__E>(
                        self,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(Precision18)
                    }
                }
                _serde::Deserializer::deserialize_unit_struct(
                    __deserializer,
                    "Precision18",
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Precision18>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::default::Default for Precision18 {
        #[inline]
        fn default() -> Precision18 {
            Precision18 {}
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for Precision18 {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "Precision18")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Precision18 {
        #[inline]
        fn clone(&self) -> Precision18 {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Precision18 {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Precision18 {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Precision18 {
        #[inline]
        fn eq(&self, other: &Precision18) -> bool {
            true
        }
    }
    #[automatically_derived]
    impl ::core::cmp::Eq for Precision18 {
        #[inline]
        #[doc(hidden)]
        #[coverage(off)]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for Precision18 {
        #[inline]
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {}
    }
}
mod registers {
    //! Submodule providing the trait registers
    use core::fmt::Debug;
    use crate::prelude::*;
    use crate::utils::{FloatOps, Number, One, Words, Zero};
    mod array {
        //! Submodule implementing the registers trait for the array data structure.
        use super::{
            extract_register_from_word, Bits, Bits1, Bits2, Bits3, Bits4, Bits5, Bits6,
            Bits7, Bits8, FloatOps, Number, One, Precision, RegisterWord, Registers, Zero,
        };
        use core::marker::PhantomData;
        use core::slice::Iter;
        #[cfg(feature = "std")]
        use crate::prelude::Named;
        #[cfg(feature = "mem_dbg")]
        use mem_dbg::{MemDbg, MemSize};
        #[cfg(feature = "precision_10")]
        use crate::prelude::Precision10;
        #[cfg(feature = "precision_4")]
        use crate::prelude::Precision4;
        #[cfg(feature = "precision_5")]
        use crate::prelude::Precision5;
        #[cfg(feature = "precision_6")]
        use crate::prelude::Precision6;
        #[cfg(feature = "precision_7")]
        use crate::prelude::Precision7;
        #[cfg(feature = "precision_8")]
        use crate::prelude::Precision8;
        #[cfg(feature = "precision_9")]
        use crate::prelude::Precision9;
        use crate::utils::Words;
        /// Iterator over the registers.
        pub struct RegisterIter<'words, P: Precision, B: Bits> {
            /// The current register.
            current_register: P::NumberOfRegisters,
            /// The current register in the word.
            current_register_in_word: u8,
            /// The iterator over the words.
            words: Iter<'words, u64>,
            /// The current word.
            current_word: Option<u64>,
            /// The phantom data.
            _phantom: PhantomData<(P, B)>,
        }
        impl<'words, P: Precision, B: Bits> RegisterIter<'words, P, B> {
            /// Creates a new instance of the register iterator.
            fn new(mut words: Iter<'words, u64>) -> Self {
                let current_word = words.next().copied();
                Self {
                    current_register: P::NumberOfRegisters::ZERO,
                    words,
                    current_register_in_word: 0,
                    current_word,
                    _phantom: PhantomData,
                }
            }
        }
        impl<'words, P: Precision, B: Bits> Iterator for RegisterIter<'words, P, B> {
            type Item = u8;
            fn next(&mut self) -> Option<Self::Item> {
                if self.current_register == P::NUMBER_OF_REGISTERS {
                    return None;
                }
                self.current_word
                    .map(|word| {
                        let [register] = extract_register_from_word::<
                            B,
                            1,
                        >([word], self.current_register_in_word * B::NUMBER_OF_BITS);
                        self.current_register_in_word += 1;
                        self.current_register += P::NumberOfRegisters::ONE;
                        if self.current_register_in_word
                            == <u64 as RegisterWord<B>>::NUMBER_OF_REGISTERS_IN_WORD
                        {
                            self.current_register_in_word = 0;
                            self.current_word = self.words.next().copied();
                        }
                        register
                    })
            }
        }
        /// Iterator over the registers zipped with another set of registers.
        pub struct TupleIter<'words, P: Precision, B: Bits> {
            /// The current register.
            current_register: P::NumberOfRegisters,
            /// The current register in the word.
            current_register_in_word: u8,
            /// The iterator over the left registers.
            left: Iter<'words, u64>,
            /// The iterator over the right registers.
            right: Iter<'words, u64>,
            /// The current words.
            current_word: Option<(u64, u64)>,
            /// The phantom data.
            _phantom: PhantomData<(P, B)>,
        }
        impl<'words, P: Precision, B: Bits> TupleIter<'words, P, B> {
            /// Creates a new instance of the tuple iterator.
            fn new(mut left: Iter<'words, u64>, mut right: Iter<'words, u64>) -> Self {
                let current_word = left
                    .next()
                    .copied()
                    .and_then(|left_word| {
                        right.next().copied().map(|right_word| (left_word, right_word))
                    });
                Self {
                    current_register: P::NumberOfRegisters::ZERO,
                    left,
                    right,
                    current_register_in_word: 0,
                    current_word,
                    _phantom: PhantomData,
                }
            }
        }
        impl<'words, P: Precision, B: Bits> Iterator for TupleIter<'words, P, B> {
            type Item = (u8, u8);
            fn next(&mut self) -> Option<Self::Item> {
                if self.current_register == P::NUMBER_OF_REGISTERS {
                    return None;
                }
                self.current_word
                    .map(|(left, right)| {
                        let [left_register, right_register] = extract_register_from_word::<
                            B,
                            2,
                        >(
                            [left, right],
                            self.current_register_in_word * B::NUMBER_OF_BITS,
                        );
                        self.current_register_in_word += 1;
                        self.current_register += P::NumberOfRegisters::ONE;
                        if self.current_register_in_word
                            == <u64 as RegisterWord<B>>::NUMBER_OF_REGISTERS_IN_WORD
                        {
                            self.current_register_in_word = 0;
                            self.current_word = self
                                .left
                                .next()
                                .copied()
                                .and_then(|left_word| {
                                    self.right
                                        .next()
                                        .copied()
                                        .map(|right_word| (left_word, right_word))
                                });
                        }
                        (left_register, right_register)
                    })
            }
        }
        /// Trait marker to associate a specific register array with a combination of precision and bits.
        ///
        /// Meant to be associated with a specific Precision.
        pub trait ArrayRegister<B: Bits>: Precision {
            /// The type of the array register.
            #[cfg(all(feature = "std", feature = "mem_dbg"))]
            type ArrayRegister: Registers<Self, B> + Words + Named + MemDbg + MemSize;
        }
        /// Trait marker to say that a given precision implements all of the array registers.
        pub trait ArrayRegisters: ArrayRegister<
                Bits1,
            > + ArrayRegister<
                Bits2,
            > + ArrayRegister<
                Bits3,
            > + ArrayRegister<
                Bits4,
            > + ArrayRegister<
                Bits5,
            > + ArrayRegister<Bits6> + ArrayRegister<Bits7> + ArrayRegister<Bits8> {}
        #[cfg(feature = "std")]
        impl<const N: usize, W> Named for [W; N] {
            #[inline]
            fn name(&self) -> String {
                "Array".to_owned()
            }
        }
        /// Splits the index into the word position and the register position.
        fn split_index<P: Precision, B: Bits>(index: P::NumberOfRegisters) -> (usize, u8)
        where
            u64: RegisterWord<B>,
        {
            let mask: u64 = <u64 as RegisterWord<B>>::NUMBER_OF_REGISTERS_IN_WORD.into();
            let word_position: u64 = index.into() / mask;
            let register_position: u8 = u8::try_from(index.into() - word_position * mask)
                .unwrap();
            (usize::try_from(word_position).unwrap(), register_position)
        }
        #[cfg(feature = "precision_4")]
        impl ArrayRegister<Bits1> for Precision4 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 4), 64 / 1)];
        }
        #[cfg(feature = "precision_4")]
        impl Registers<Precision4, Bits1>
        for [u64; crate::utils::ceil(usize::pow(2, 4), 64 / 1)] {
            type Iter<'words> = RegisterIter<'words, Precision4, Bits1>;
            type IterZipped<'words> = TupleIter<'words, Precision4, Bits1>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 4), 64 / 1)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision4 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits1,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits1,
                            2,
                        >([left, right], step * Bits1::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision4 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits1>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision4 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision4 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision4 as Precision>::NumberOfRegisters = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits1,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision4::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits1,
                            1,
                        >([word_copy], step * Bits1::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision4::EXPONENT,
                                            Bits1::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits1::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision4 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision4 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision4::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision4::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision4::EXPONENT,
                                    Bits1::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision4,
                    Bits1,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits1::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK
                        << (register_position * Bits1::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits1::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision4 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision4,
                    Bits1,
                >(index);
                extract_register_from_word::<
                    Bits1,
                    1,
                >([self[word_position]], register_position * Bits1::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_4")]
        impl ArrayRegister<Bits2> for Precision4 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 4), 64 / 2)];
        }
        #[cfg(feature = "precision_4")]
        impl Registers<Precision4, Bits2>
        for [u64; crate::utils::ceil(usize::pow(2, 4), 64 / 2)] {
            type Iter<'words> = RegisterIter<'words, Precision4, Bits2>;
            type IterZipped<'words> = TupleIter<'words, Precision4, Bits2>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 4), 64 / 2)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision4 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits2,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits2,
                            2,
                        >([left, right], step * Bits2::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision4 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits2>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision4 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision4 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision4 as Precision>::NumberOfRegisters = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits2,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision4::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits2,
                            1,
                        >([word_copy], step * Bits2::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision4::EXPONENT,
                                            Bits2::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits2::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision4 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision4 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision4::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision4::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision4::EXPONENT,
                                    Bits2::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision4,
                    Bits2,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits2::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK
                        << (register_position * Bits2::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits2::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision4 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision4,
                    Bits2,
                >(index);
                extract_register_from_word::<
                    Bits2,
                    1,
                >([self[word_position]], register_position * Bits2::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_4")]
        impl ArrayRegister<Bits3> for Precision4 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 4), 64 / 3)];
        }
        #[cfg(feature = "precision_4")]
        impl Registers<Precision4, Bits3>
        for [u64; crate::utils::ceil(usize::pow(2, 4), 64 / 3)] {
            type Iter<'words> = RegisterIter<'words, Precision4, Bits3>;
            type IterZipped<'words> = TupleIter<'words, Precision4, Bits3>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 4), 64 / 3)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision4 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits3,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits3,
                            2,
                        >([left, right], step * Bits3::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision4 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits3>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision4 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision4 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision4 as Precision>::NumberOfRegisters = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits3,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision4::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits3,
                            1,
                        >([word_copy], step * Bits3::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision4::EXPONENT,
                                            Bits3::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits3::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision4 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision4 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision4::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision4::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision4::EXPONENT,
                                    Bits3::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision4,
                    Bits3,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits3::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK
                        << (register_position * Bits3::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits3::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision4 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision4,
                    Bits3,
                >(index);
                extract_register_from_word::<
                    Bits3,
                    1,
                >([self[word_position]], register_position * Bits3::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_4")]
        impl ArrayRegister<Bits4> for Precision4 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 4), 64 / 4)];
        }
        #[cfg(feature = "precision_4")]
        impl Registers<Precision4, Bits4>
        for [u64; crate::utils::ceil(usize::pow(2, 4), 64 / 4)] {
            type Iter<'words> = RegisterIter<'words, Precision4, Bits4>;
            type IterZipped<'words> = TupleIter<'words, Precision4, Bits4>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 4), 64 / 4)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision4 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits4,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits4,
                            2,
                        >([left, right], step * Bits4::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision4 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits4>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision4 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision4 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision4 as Precision>::NumberOfRegisters = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits4,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision4::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits4,
                            1,
                        >([word_copy], step * Bits4::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision4::EXPONENT,
                                            Bits4::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits4::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision4 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision4 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision4::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision4::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision4::EXPONENT,
                                    Bits4::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision4,
                    Bits4,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits4::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK
                        << (register_position * Bits4::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits4::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision4 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision4,
                    Bits4,
                >(index);
                extract_register_from_word::<
                    Bits4,
                    1,
                >([self[word_position]], register_position * Bits4::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_4")]
        impl ArrayRegister<Bits5> for Precision4 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 4), 64 / 5)];
        }
        #[cfg(feature = "precision_4")]
        impl Registers<Precision4, Bits5>
        for [u64; crate::utils::ceil(usize::pow(2, 4), 64 / 5)] {
            type Iter<'words> = RegisterIter<'words, Precision4, Bits5>;
            type IterZipped<'words> = TupleIter<'words, Precision4, Bits5>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 4), 64 / 5)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision4 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits5,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits5,
                            2,
                        >([left, right], step * Bits5::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision4 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits5>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision4 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision4 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision4 as Precision>::NumberOfRegisters = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits5,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision4::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits5,
                            1,
                        >([word_copy], step * Bits5::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision4::EXPONENT,
                                            Bits5::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits5::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision4 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision4 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision4::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision4::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision4::EXPONENT,
                                    Bits5::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision4,
                    Bits5,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits5::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK
                        << (register_position * Bits5::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits5::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision4 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision4,
                    Bits5,
                >(index);
                extract_register_from_word::<
                    Bits5,
                    1,
                >([self[word_position]], register_position * Bits5::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_4")]
        impl ArrayRegister<Bits6> for Precision4 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 4), 64 / 6)];
        }
        #[cfg(feature = "precision_4")]
        impl Registers<Precision4, Bits6>
        for [u64; crate::utils::ceil(usize::pow(2, 4), 64 / 6)] {
            type Iter<'words> = RegisterIter<'words, Precision4, Bits6>;
            type IterZipped<'words> = TupleIter<'words, Precision4, Bits6>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 4), 64 / 6)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision4 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits6,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits6,
                            2,
                        >([left, right], step * Bits6::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision4 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits6>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision4 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision4 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision4 as Precision>::NumberOfRegisters = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits6,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision4::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits6,
                            1,
                        >([word_copy], step * Bits6::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision4::EXPONENT,
                                            Bits6::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits6::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision4 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision4 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision4::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision4::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision4::EXPONENT,
                                    Bits6::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision4,
                    Bits6,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits6::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK
                        << (register_position * Bits6::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits6::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision4 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision4,
                    Bits6,
                >(index);
                extract_register_from_word::<
                    Bits6,
                    1,
                >([self[word_position]], register_position * Bits6::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_4")]
        impl ArrayRegister<Bits7> for Precision4 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 4), 64 / 7)];
        }
        #[cfg(feature = "precision_4")]
        impl Registers<Precision4, Bits7>
        for [u64; crate::utils::ceil(usize::pow(2, 4), 64 / 7)] {
            type Iter<'words> = RegisterIter<'words, Precision4, Bits7>;
            type IterZipped<'words> = TupleIter<'words, Precision4, Bits7>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 4), 64 / 7)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision4 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits7,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits7,
                            2,
                        >([left, right], step * Bits7::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision4 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits7>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision4 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision4 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision4 as Precision>::NumberOfRegisters = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits7,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision4::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits7,
                            1,
                        >([word_copy], step * Bits7::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision4::EXPONENT,
                                            Bits7::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits7::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision4 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision4 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision4::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision4::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision4::EXPONENT,
                                    Bits7::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision4,
                    Bits7,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits7::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK
                        << (register_position * Bits7::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits7::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision4 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision4,
                    Bits7,
                >(index);
                extract_register_from_word::<
                    Bits7,
                    1,
                >([self[word_position]], register_position * Bits7::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_4")]
        impl ArrayRegister<Bits8> for Precision4 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 4), 64 / 8)];
        }
        #[cfg(feature = "precision_4")]
        impl Registers<Precision4, Bits8>
        for [u64; crate::utils::ceil(usize::pow(2, 4), 64 / 8)] {
            type Iter<'words> = RegisterIter<'words, Precision4, Bits8>;
            type IterZipped<'words> = TupleIter<'words, Precision4, Bits8>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 4), 64 / 8)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision4 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits8,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits8,
                            2,
                        >([left, right], step * Bits8::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision4 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits8>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision4 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision4 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision4 as Precision>::NumberOfRegisters = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits8,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision4::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits8,
                            1,
                        >([word_copy], step * Bits8::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision4::EXPONENT,
                                            Bits8::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits8::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision4 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision4 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision4::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision4::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision4::EXPONENT,
                                    Bits8::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision4,
                    Bits8,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits8::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK
                        << (register_position * Bits8::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits8::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision4 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision4,
                    Bits8,
                >(index);
                extract_register_from_word::<
                    Bits8,
                    1,
                >([self[word_position]], register_position * Bits8::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_5")]
        impl ArrayRegister<Bits1> for Precision5 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 5), 64 / 1)];
        }
        #[cfg(feature = "precision_5")]
        impl Registers<Precision5, Bits1>
        for [u64; crate::utils::ceil(usize::pow(2, 5), 64 / 1)] {
            type Iter<'words> = RegisterIter<'words, Precision5, Bits1>;
            type IterZipped<'words> = TupleIter<'words, Precision5, Bits1>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 5), 64 / 1)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision5 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits1,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits1,
                            2,
                        >([left, right], step * Bits1::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision5 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits1>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision5 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision5 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision5 as Precision>::NumberOfRegisters = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits1,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision5::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits1,
                            1,
                        >([word_copy], step * Bits1::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision5::EXPONENT,
                                            Bits1::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits1::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision5 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision5 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision5::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision5::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision5::EXPONENT,
                                    Bits1::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision5,
                    Bits1,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits1::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK
                        << (register_position * Bits1::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits1::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision5 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision5,
                    Bits1,
                >(index);
                extract_register_from_word::<
                    Bits1,
                    1,
                >([self[word_position]], register_position * Bits1::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_5")]
        impl ArrayRegister<Bits2> for Precision5 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 5), 64 / 2)];
        }
        #[cfg(feature = "precision_5")]
        impl Registers<Precision5, Bits2>
        for [u64; crate::utils::ceil(usize::pow(2, 5), 64 / 2)] {
            type Iter<'words> = RegisterIter<'words, Precision5, Bits2>;
            type IterZipped<'words> = TupleIter<'words, Precision5, Bits2>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 5), 64 / 2)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision5 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits2,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits2,
                            2,
                        >([left, right], step * Bits2::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision5 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits2>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision5 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision5 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision5 as Precision>::NumberOfRegisters = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits2,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision5::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits2,
                            1,
                        >([word_copy], step * Bits2::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision5::EXPONENT,
                                            Bits2::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits2::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision5 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision5 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision5::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision5::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision5::EXPONENT,
                                    Bits2::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision5,
                    Bits2,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits2::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK
                        << (register_position * Bits2::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits2::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision5 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision5,
                    Bits2,
                >(index);
                extract_register_from_word::<
                    Bits2,
                    1,
                >([self[word_position]], register_position * Bits2::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_5")]
        impl ArrayRegister<Bits3> for Precision5 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 5), 64 / 3)];
        }
        #[cfg(feature = "precision_5")]
        impl Registers<Precision5, Bits3>
        for [u64; crate::utils::ceil(usize::pow(2, 5), 64 / 3)] {
            type Iter<'words> = RegisterIter<'words, Precision5, Bits3>;
            type IterZipped<'words> = TupleIter<'words, Precision5, Bits3>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 5), 64 / 3)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision5 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits3,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits3,
                            2,
                        >([left, right], step * Bits3::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision5 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits3>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision5 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision5 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision5 as Precision>::NumberOfRegisters = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits3,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision5::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits3,
                            1,
                        >([word_copy], step * Bits3::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision5::EXPONENT,
                                            Bits3::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits3::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision5 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision5 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision5::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision5::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision5::EXPONENT,
                                    Bits3::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision5,
                    Bits3,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits3::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK
                        << (register_position * Bits3::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits3::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision5 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision5,
                    Bits3,
                >(index);
                extract_register_from_word::<
                    Bits3,
                    1,
                >([self[word_position]], register_position * Bits3::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_5")]
        impl ArrayRegister<Bits4> for Precision5 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 5), 64 / 4)];
        }
        #[cfg(feature = "precision_5")]
        impl Registers<Precision5, Bits4>
        for [u64; crate::utils::ceil(usize::pow(2, 5), 64 / 4)] {
            type Iter<'words> = RegisterIter<'words, Precision5, Bits4>;
            type IterZipped<'words> = TupleIter<'words, Precision5, Bits4>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 5), 64 / 4)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision5 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits4,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits4,
                            2,
                        >([left, right], step * Bits4::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision5 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits4>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision5 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision5 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision5 as Precision>::NumberOfRegisters = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits4,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision5::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits4,
                            1,
                        >([word_copy], step * Bits4::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision5::EXPONENT,
                                            Bits4::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits4::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision5 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision5 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision5::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision5::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision5::EXPONENT,
                                    Bits4::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision5,
                    Bits4,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits4::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK
                        << (register_position * Bits4::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits4::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision5 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision5,
                    Bits4,
                >(index);
                extract_register_from_word::<
                    Bits4,
                    1,
                >([self[word_position]], register_position * Bits4::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_5")]
        impl ArrayRegister<Bits5> for Precision5 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 5), 64 / 5)];
        }
        #[cfg(feature = "precision_5")]
        impl Registers<Precision5, Bits5>
        for [u64; crate::utils::ceil(usize::pow(2, 5), 64 / 5)] {
            type Iter<'words> = RegisterIter<'words, Precision5, Bits5>;
            type IterZipped<'words> = TupleIter<'words, Precision5, Bits5>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 5), 64 / 5)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision5 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits5,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits5,
                            2,
                        >([left, right], step * Bits5::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision5 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits5>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision5 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision5 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision5 as Precision>::NumberOfRegisters = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits5,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision5::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits5,
                            1,
                        >([word_copy], step * Bits5::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision5::EXPONENT,
                                            Bits5::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits5::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision5 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision5 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision5::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision5::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision5::EXPONENT,
                                    Bits5::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision5,
                    Bits5,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits5::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK
                        << (register_position * Bits5::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits5::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision5 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision5,
                    Bits5,
                >(index);
                extract_register_from_word::<
                    Bits5,
                    1,
                >([self[word_position]], register_position * Bits5::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_5")]
        impl ArrayRegister<Bits6> for Precision5 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 5), 64 / 6)];
        }
        #[cfg(feature = "precision_5")]
        impl Registers<Precision5, Bits6>
        for [u64; crate::utils::ceil(usize::pow(2, 5), 64 / 6)] {
            type Iter<'words> = RegisterIter<'words, Precision5, Bits6>;
            type IterZipped<'words> = TupleIter<'words, Precision5, Bits6>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 5), 64 / 6)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision5 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits6,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits6,
                            2,
                        >([left, right], step * Bits6::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision5 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits6>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision5 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision5 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision5 as Precision>::NumberOfRegisters = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits6,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision5::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits6,
                            1,
                        >([word_copy], step * Bits6::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision5::EXPONENT,
                                            Bits6::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits6::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision5 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision5 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision5::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision5::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision5::EXPONENT,
                                    Bits6::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision5,
                    Bits6,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits6::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK
                        << (register_position * Bits6::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits6::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision5 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision5,
                    Bits6,
                >(index);
                extract_register_from_word::<
                    Bits6,
                    1,
                >([self[word_position]], register_position * Bits6::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_5")]
        impl ArrayRegister<Bits7> for Precision5 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 5), 64 / 7)];
        }
        #[cfg(feature = "precision_5")]
        impl Registers<Precision5, Bits7>
        for [u64; crate::utils::ceil(usize::pow(2, 5), 64 / 7)] {
            type Iter<'words> = RegisterIter<'words, Precision5, Bits7>;
            type IterZipped<'words> = TupleIter<'words, Precision5, Bits7>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 5), 64 / 7)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision5 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits7,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits7,
                            2,
                        >([left, right], step * Bits7::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision5 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits7>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision5 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision5 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision5 as Precision>::NumberOfRegisters = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits7,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision5::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits7,
                            1,
                        >([word_copy], step * Bits7::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision5::EXPONENT,
                                            Bits7::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits7::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision5 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision5 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision5::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision5::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision5::EXPONENT,
                                    Bits7::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision5,
                    Bits7,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits7::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK
                        << (register_position * Bits7::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits7::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision5 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision5,
                    Bits7,
                >(index);
                extract_register_from_word::<
                    Bits7,
                    1,
                >([self[word_position]], register_position * Bits7::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_5")]
        impl ArrayRegister<Bits8> for Precision5 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 5), 64 / 8)];
        }
        #[cfg(feature = "precision_5")]
        impl Registers<Precision5, Bits8>
        for [u64; crate::utils::ceil(usize::pow(2, 5), 64 / 8)] {
            type Iter<'words> = RegisterIter<'words, Precision5, Bits8>;
            type IterZipped<'words> = TupleIter<'words, Precision5, Bits8>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 5), 64 / 8)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision5 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits8,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits8,
                            2,
                        >([left, right], step * Bits8::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision5 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits8>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision5 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision5 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision5 as Precision>::NumberOfRegisters = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits8,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision5::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits8,
                            1,
                        >([word_copy], step * Bits8::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision5::EXPONENT,
                                            Bits8::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits8::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision5 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision5 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision5::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision5::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision5::EXPONENT,
                                    Bits8::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision5,
                    Bits8,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits8::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK
                        << (register_position * Bits8::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits8::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision5 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision5,
                    Bits8,
                >(index);
                extract_register_from_word::<
                    Bits8,
                    1,
                >([self[word_position]], register_position * Bits8::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_6")]
        impl ArrayRegister<Bits1> for Precision6 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 6), 64 / 1)];
        }
        #[cfg(feature = "precision_6")]
        impl Registers<Precision6, Bits1>
        for [u64; crate::utils::ceil(usize::pow(2, 6), 64 / 1)] {
            type Iter<'words> = RegisterIter<'words, Precision6, Bits1>;
            type IterZipped<'words> = TupleIter<'words, Precision6, Bits1>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 6), 64 / 1)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision6 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits1,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits1,
                            2,
                        >([left, right], step * Bits1::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision6 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits1>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision6 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision6 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision6 as Precision>::NumberOfRegisters = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits1,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision6::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits1,
                            1,
                        >([word_copy], step * Bits1::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision6::EXPONENT,
                                            Bits1::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits1::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision6 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision6 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision6::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision6::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision6::EXPONENT,
                                    Bits1::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision6,
                    Bits1,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits1::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK
                        << (register_position * Bits1::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits1::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision6 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision6,
                    Bits1,
                >(index);
                extract_register_from_word::<
                    Bits1,
                    1,
                >([self[word_position]], register_position * Bits1::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_6")]
        impl ArrayRegister<Bits2> for Precision6 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 6), 64 / 2)];
        }
        #[cfg(feature = "precision_6")]
        impl Registers<Precision6, Bits2>
        for [u64; crate::utils::ceil(usize::pow(2, 6), 64 / 2)] {
            type Iter<'words> = RegisterIter<'words, Precision6, Bits2>;
            type IterZipped<'words> = TupleIter<'words, Precision6, Bits2>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 6), 64 / 2)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision6 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits2,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits2,
                            2,
                        >([left, right], step * Bits2::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision6 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits2>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision6 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision6 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision6 as Precision>::NumberOfRegisters = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits2,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision6::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits2,
                            1,
                        >([word_copy], step * Bits2::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision6::EXPONENT,
                                            Bits2::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits2::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision6 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision6 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision6::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision6::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision6::EXPONENT,
                                    Bits2::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision6,
                    Bits2,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits2::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK
                        << (register_position * Bits2::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits2::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision6 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision6,
                    Bits2,
                >(index);
                extract_register_from_word::<
                    Bits2,
                    1,
                >([self[word_position]], register_position * Bits2::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_6")]
        impl ArrayRegister<Bits3> for Precision6 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 6), 64 / 3)];
        }
        #[cfg(feature = "precision_6")]
        impl Registers<Precision6, Bits3>
        for [u64; crate::utils::ceil(usize::pow(2, 6), 64 / 3)] {
            type Iter<'words> = RegisterIter<'words, Precision6, Bits3>;
            type IterZipped<'words> = TupleIter<'words, Precision6, Bits3>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 6), 64 / 3)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision6 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits3,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits3,
                            2,
                        >([left, right], step * Bits3::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision6 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits3>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision6 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision6 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision6 as Precision>::NumberOfRegisters = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits3,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision6::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits3,
                            1,
                        >([word_copy], step * Bits3::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision6::EXPONENT,
                                            Bits3::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits3::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision6 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision6 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision6::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision6::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision6::EXPONENT,
                                    Bits3::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision6,
                    Bits3,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits3::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK
                        << (register_position * Bits3::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits3::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision6 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision6,
                    Bits3,
                >(index);
                extract_register_from_word::<
                    Bits3,
                    1,
                >([self[word_position]], register_position * Bits3::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_6")]
        impl ArrayRegister<Bits4> for Precision6 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 6), 64 / 4)];
        }
        #[cfg(feature = "precision_6")]
        impl Registers<Precision6, Bits4>
        for [u64; crate::utils::ceil(usize::pow(2, 6), 64 / 4)] {
            type Iter<'words> = RegisterIter<'words, Precision6, Bits4>;
            type IterZipped<'words> = TupleIter<'words, Precision6, Bits4>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 6), 64 / 4)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision6 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits4,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits4,
                            2,
                        >([left, right], step * Bits4::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision6 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits4>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision6 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision6 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision6 as Precision>::NumberOfRegisters = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits4,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision6::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits4,
                            1,
                        >([word_copy], step * Bits4::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision6::EXPONENT,
                                            Bits4::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits4::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision6 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision6 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision6::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision6::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision6::EXPONENT,
                                    Bits4::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision6,
                    Bits4,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits4::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK
                        << (register_position * Bits4::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits4::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision6 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision6,
                    Bits4,
                >(index);
                extract_register_from_word::<
                    Bits4,
                    1,
                >([self[word_position]], register_position * Bits4::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_6")]
        impl ArrayRegister<Bits5> for Precision6 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 6), 64 / 5)];
        }
        #[cfg(feature = "precision_6")]
        impl Registers<Precision6, Bits5>
        for [u64; crate::utils::ceil(usize::pow(2, 6), 64 / 5)] {
            type Iter<'words> = RegisterIter<'words, Precision6, Bits5>;
            type IterZipped<'words> = TupleIter<'words, Precision6, Bits5>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 6), 64 / 5)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision6 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits5,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits5,
                            2,
                        >([left, right], step * Bits5::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision6 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits5>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision6 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision6 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision6 as Precision>::NumberOfRegisters = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits5,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision6::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits5,
                            1,
                        >([word_copy], step * Bits5::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision6::EXPONENT,
                                            Bits5::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits5::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision6 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision6 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision6::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision6::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision6::EXPONENT,
                                    Bits5::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision6,
                    Bits5,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits5::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK
                        << (register_position * Bits5::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits5::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision6 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision6,
                    Bits5,
                >(index);
                extract_register_from_word::<
                    Bits5,
                    1,
                >([self[word_position]], register_position * Bits5::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_6")]
        impl ArrayRegister<Bits6> for Precision6 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 6), 64 / 6)];
        }
        #[cfg(feature = "precision_6")]
        impl Registers<Precision6, Bits6>
        for [u64; crate::utils::ceil(usize::pow(2, 6), 64 / 6)] {
            type Iter<'words> = RegisterIter<'words, Precision6, Bits6>;
            type IterZipped<'words> = TupleIter<'words, Precision6, Bits6>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 6), 64 / 6)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision6 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits6,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits6,
                            2,
                        >([left, right], step * Bits6::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision6 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits6>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision6 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision6 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision6 as Precision>::NumberOfRegisters = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits6,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision6::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits6,
                            1,
                        >([word_copy], step * Bits6::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision6::EXPONENT,
                                            Bits6::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits6::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision6 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision6 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision6::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision6::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision6::EXPONENT,
                                    Bits6::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision6,
                    Bits6,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits6::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK
                        << (register_position * Bits6::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits6::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision6 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision6,
                    Bits6,
                >(index);
                extract_register_from_word::<
                    Bits6,
                    1,
                >([self[word_position]], register_position * Bits6::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_6")]
        impl ArrayRegister<Bits7> for Precision6 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 6), 64 / 7)];
        }
        #[cfg(feature = "precision_6")]
        impl Registers<Precision6, Bits7>
        for [u64; crate::utils::ceil(usize::pow(2, 6), 64 / 7)] {
            type Iter<'words> = RegisterIter<'words, Precision6, Bits7>;
            type IterZipped<'words> = TupleIter<'words, Precision6, Bits7>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 6), 64 / 7)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision6 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits7,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits7,
                            2,
                        >([left, right], step * Bits7::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision6 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits7>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision6 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision6 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision6 as Precision>::NumberOfRegisters = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits7,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision6::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits7,
                            1,
                        >([word_copy], step * Bits7::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision6::EXPONENT,
                                            Bits7::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits7::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision6 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision6 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision6::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision6::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision6::EXPONENT,
                                    Bits7::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision6,
                    Bits7,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits7::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK
                        << (register_position * Bits7::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits7::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision6 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision6,
                    Bits7,
                >(index);
                extract_register_from_word::<
                    Bits7,
                    1,
                >([self[word_position]], register_position * Bits7::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_6")]
        impl ArrayRegister<Bits8> for Precision6 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 6), 64 / 8)];
        }
        #[cfg(feature = "precision_6")]
        impl Registers<Precision6, Bits8>
        for [u64; crate::utils::ceil(usize::pow(2, 6), 64 / 8)] {
            type Iter<'words> = RegisterIter<'words, Precision6, Bits8>;
            type IterZipped<'words> = TupleIter<'words, Precision6, Bits8>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 6), 64 / 8)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision6 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits8,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits8,
                            2,
                        >([left, right], step * Bits8::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision6 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits8>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision6 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision6 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision6 as Precision>::NumberOfRegisters = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits8,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision6::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits8,
                            1,
                        >([word_copy], step * Bits8::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision6::EXPONENT,
                                            Bits8::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits8::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision6 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision6 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision6::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision6::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision6::EXPONENT,
                                    Bits8::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision6,
                    Bits8,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits8::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK
                        << (register_position * Bits8::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits8::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision6 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision6,
                    Bits8,
                >(index);
                extract_register_from_word::<
                    Bits8,
                    1,
                >([self[word_position]], register_position * Bits8::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_7")]
        impl ArrayRegister<Bits1> for Precision7 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 7), 64 / 1)];
        }
        #[cfg(feature = "precision_7")]
        impl Registers<Precision7, Bits1>
        for [u64; crate::utils::ceil(usize::pow(2, 7), 64 / 1)] {
            type Iter<'words> = RegisterIter<'words, Precision7, Bits1>;
            type IterZipped<'words> = TupleIter<'words, Precision7, Bits1>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 7), 64 / 1)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision7 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits1,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits1,
                            2,
                        >([left, right], step * Bits1::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision7 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits1>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision7 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision7 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision7 as Precision>::NumberOfRegisters = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits1,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision7::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits1,
                            1,
                        >([word_copy], step * Bits1::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision7::EXPONENT,
                                            Bits1::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits1::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision7 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision7 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision7::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision7::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision7::EXPONENT,
                                    Bits1::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision7,
                    Bits1,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits1::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK
                        << (register_position * Bits1::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits1::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision7 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision7,
                    Bits1,
                >(index);
                extract_register_from_word::<
                    Bits1,
                    1,
                >([self[word_position]], register_position * Bits1::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_7")]
        impl ArrayRegister<Bits2> for Precision7 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 7), 64 / 2)];
        }
        #[cfg(feature = "precision_7")]
        impl Registers<Precision7, Bits2>
        for [u64; crate::utils::ceil(usize::pow(2, 7), 64 / 2)] {
            type Iter<'words> = RegisterIter<'words, Precision7, Bits2>;
            type IterZipped<'words> = TupleIter<'words, Precision7, Bits2>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 7), 64 / 2)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision7 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits2,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits2,
                            2,
                        >([left, right], step * Bits2::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision7 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits2>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision7 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision7 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision7 as Precision>::NumberOfRegisters = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits2,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision7::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits2,
                            1,
                        >([word_copy], step * Bits2::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision7::EXPONENT,
                                            Bits2::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits2::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision7 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision7 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision7::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision7::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision7::EXPONENT,
                                    Bits2::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision7,
                    Bits2,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits2::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK
                        << (register_position * Bits2::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits2::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision7 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision7,
                    Bits2,
                >(index);
                extract_register_from_word::<
                    Bits2,
                    1,
                >([self[word_position]], register_position * Bits2::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_7")]
        impl ArrayRegister<Bits3> for Precision7 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 7), 64 / 3)];
        }
        #[cfg(feature = "precision_7")]
        impl Registers<Precision7, Bits3>
        for [u64; crate::utils::ceil(usize::pow(2, 7), 64 / 3)] {
            type Iter<'words> = RegisterIter<'words, Precision7, Bits3>;
            type IterZipped<'words> = TupleIter<'words, Precision7, Bits3>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 7), 64 / 3)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision7 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits3,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits3,
                            2,
                        >([left, right], step * Bits3::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision7 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits3>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision7 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision7 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision7 as Precision>::NumberOfRegisters = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits3,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision7::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits3,
                            1,
                        >([word_copy], step * Bits3::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision7::EXPONENT,
                                            Bits3::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits3::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision7 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision7 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision7::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision7::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision7::EXPONENT,
                                    Bits3::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision7,
                    Bits3,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits3::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK
                        << (register_position * Bits3::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits3::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision7 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision7,
                    Bits3,
                >(index);
                extract_register_from_word::<
                    Bits3,
                    1,
                >([self[word_position]], register_position * Bits3::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_7")]
        impl ArrayRegister<Bits4> for Precision7 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 7), 64 / 4)];
        }
        #[cfg(feature = "precision_7")]
        impl Registers<Precision7, Bits4>
        for [u64; crate::utils::ceil(usize::pow(2, 7), 64 / 4)] {
            type Iter<'words> = RegisterIter<'words, Precision7, Bits4>;
            type IterZipped<'words> = TupleIter<'words, Precision7, Bits4>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 7), 64 / 4)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision7 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits4,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits4,
                            2,
                        >([left, right], step * Bits4::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision7 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits4>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision7 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision7 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision7 as Precision>::NumberOfRegisters = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits4,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision7::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits4,
                            1,
                        >([word_copy], step * Bits4::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision7::EXPONENT,
                                            Bits4::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits4::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision7 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision7 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision7::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision7::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision7::EXPONENT,
                                    Bits4::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision7,
                    Bits4,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits4::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK
                        << (register_position * Bits4::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits4::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision7 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision7,
                    Bits4,
                >(index);
                extract_register_from_word::<
                    Bits4,
                    1,
                >([self[word_position]], register_position * Bits4::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_7")]
        impl ArrayRegister<Bits5> for Precision7 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 7), 64 / 5)];
        }
        #[cfg(feature = "precision_7")]
        impl Registers<Precision7, Bits5>
        for [u64; crate::utils::ceil(usize::pow(2, 7), 64 / 5)] {
            type Iter<'words> = RegisterIter<'words, Precision7, Bits5>;
            type IterZipped<'words> = TupleIter<'words, Precision7, Bits5>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 7), 64 / 5)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision7 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits5,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits5,
                            2,
                        >([left, right], step * Bits5::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision7 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits5>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision7 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision7 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision7 as Precision>::NumberOfRegisters = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits5,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision7::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits5,
                            1,
                        >([word_copy], step * Bits5::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision7::EXPONENT,
                                            Bits5::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits5::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision7 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision7 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision7::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision7::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision7::EXPONENT,
                                    Bits5::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision7,
                    Bits5,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits5::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK
                        << (register_position * Bits5::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits5::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision7 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision7,
                    Bits5,
                >(index);
                extract_register_from_word::<
                    Bits5,
                    1,
                >([self[word_position]], register_position * Bits5::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_7")]
        impl ArrayRegister<Bits6> for Precision7 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 7), 64 / 6)];
        }
        #[cfg(feature = "precision_7")]
        impl Registers<Precision7, Bits6>
        for [u64; crate::utils::ceil(usize::pow(2, 7), 64 / 6)] {
            type Iter<'words> = RegisterIter<'words, Precision7, Bits6>;
            type IterZipped<'words> = TupleIter<'words, Precision7, Bits6>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 7), 64 / 6)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision7 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits6,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits6,
                            2,
                        >([left, right], step * Bits6::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision7 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits6>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision7 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision7 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision7 as Precision>::NumberOfRegisters = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits6,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision7::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits6,
                            1,
                        >([word_copy], step * Bits6::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision7::EXPONENT,
                                            Bits6::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits6::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision7 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision7 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision7::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision7::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision7::EXPONENT,
                                    Bits6::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision7,
                    Bits6,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits6::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK
                        << (register_position * Bits6::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits6::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision7 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision7,
                    Bits6,
                >(index);
                extract_register_from_word::<
                    Bits6,
                    1,
                >([self[word_position]], register_position * Bits6::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_7")]
        impl ArrayRegister<Bits7> for Precision7 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 7), 64 / 7)];
        }
        #[cfg(feature = "precision_7")]
        impl Registers<Precision7, Bits7>
        for [u64; crate::utils::ceil(usize::pow(2, 7), 64 / 7)] {
            type Iter<'words> = RegisterIter<'words, Precision7, Bits7>;
            type IterZipped<'words> = TupleIter<'words, Precision7, Bits7>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 7), 64 / 7)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision7 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits7,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits7,
                            2,
                        >([left, right], step * Bits7::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision7 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits7>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision7 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision7 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision7 as Precision>::NumberOfRegisters = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits7,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision7::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits7,
                            1,
                        >([word_copy], step * Bits7::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision7::EXPONENT,
                                            Bits7::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits7::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision7 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision7 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision7::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision7::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision7::EXPONENT,
                                    Bits7::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision7,
                    Bits7,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits7::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK
                        << (register_position * Bits7::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits7::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision7 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision7,
                    Bits7,
                >(index);
                extract_register_from_word::<
                    Bits7,
                    1,
                >([self[word_position]], register_position * Bits7::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_7")]
        impl ArrayRegister<Bits8> for Precision7 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 7), 64 / 8)];
        }
        #[cfg(feature = "precision_7")]
        impl Registers<Precision7, Bits8>
        for [u64; crate::utils::ceil(usize::pow(2, 7), 64 / 8)] {
            type Iter<'words> = RegisterIter<'words, Precision7, Bits8>;
            type IterZipped<'words> = TupleIter<'words, Precision7, Bits8>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 7), 64 / 8)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision7 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits8,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits8,
                            2,
                        >([left, right], step * Bits8::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision7 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits8>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision7 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision7 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision7 as Precision>::NumberOfRegisters = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits8,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision7::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits8,
                            1,
                        >([word_copy], step * Bits8::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision7::EXPONENT,
                                            Bits8::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits8::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision7 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision7 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision7::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision7::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision7::EXPONENT,
                                    Bits8::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision7,
                    Bits8,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits8::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK
                        << (register_position * Bits8::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits8::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision7 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision7,
                    Bits8,
                >(index);
                extract_register_from_word::<
                    Bits8,
                    1,
                >([self[word_position]], register_position * Bits8::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_8")]
        impl ArrayRegister<Bits1> for Precision8 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 8), 64 / 1)];
        }
        #[cfg(feature = "precision_8")]
        impl Registers<Precision8, Bits1>
        for [u64; crate::utils::ceil(usize::pow(2, 8), 64 / 1)] {
            type Iter<'words> = RegisterIter<'words, Precision8, Bits1>;
            type IterZipped<'words> = TupleIter<'words, Precision8, Bits1>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 8), 64 / 1)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision8 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits1,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits1,
                            2,
                        >([left, right], step * Bits1::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision8 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits1>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision8 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision8 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision8 as Precision>::NumberOfRegisters = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits1,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision8::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits1,
                            1,
                        >([word_copy], step * Bits1::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision8::EXPONENT,
                                            Bits1::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits1::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision8 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision8 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision8::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision8::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision8::EXPONENT,
                                    Bits1::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision8,
                    Bits1,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits1::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK
                        << (register_position * Bits1::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits1::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision8 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision8,
                    Bits1,
                >(index);
                extract_register_from_word::<
                    Bits1,
                    1,
                >([self[word_position]], register_position * Bits1::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_8")]
        impl ArrayRegister<Bits2> for Precision8 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 8), 64 / 2)];
        }
        #[cfg(feature = "precision_8")]
        impl Registers<Precision8, Bits2>
        for [u64; crate::utils::ceil(usize::pow(2, 8), 64 / 2)] {
            type Iter<'words> = RegisterIter<'words, Precision8, Bits2>;
            type IterZipped<'words> = TupleIter<'words, Precision8, Bits2>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 8), 64 / 2)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision8 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits2,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits2,
                            2,
                        >([left, right], step * Bits2::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision8 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits2>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision8 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision8 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision8 as Precision>::NumberOfRegisters = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits2,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision8::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits2,
                            1,
                        >([word_copy], step * Bits2::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision8::EXPONENT,
                                            Bits2::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits2::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision8 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision8 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision8::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision8::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision8::EXPONENT,
                                    Bits2::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision8,
                    Bits2,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits2::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK
                        << (register_position * Bits2::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits2::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision8 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision8,
                    Bits2,
                >(index);
                extract_register_from_word::<
                    Bits2,
                    1,
                >([self[word_position]], register_position * Bits2::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_8")]
        impl ArrayRegister<Bits3> for Precision8 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 8), 64 / 3)];
        }
        #[cfg(feature = "precision_8")]
        impl Registers<Precision8, Bits3>
        for [u64; crate::utils::ceil(usize::pow(2, 8), 64 / 3)] {
            type Iter<'words> = RegisterIter<'words, Precision8, Bits3>;
            type IterZipped<'words> = TupleIter<'words, Precision8, Bits3>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 8), 64 / 3)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision8 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits3,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits3,
                            2,
                        >([left, right], step * Bits3::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision8 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits3>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision8 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision8 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision8 as Precision>::NumberOfRegisters = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits3,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision8::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits3,
                            1,
                        >([word_copy], step * Bits3::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision8::EXPONENT,
                                            Bits3::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits3::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision8 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision8 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision8::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision8::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision8::EXPONENT,
                                    Bits3::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision8,
                    Bits3,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits3::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK
                        << (register_position * Bits3::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits3::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision8 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision8,
                    Bits3,
                >(index);
                extract_register_from_word::<
                    Bits3,
                    1,
                >([self[word_position]], register_position * Bits3::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_8")]
        impl ArrayRegister<Bits4> for Precision8 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 8), 64 / 4)];
        }
        #[cfg(feature = "precision_8")]
        impl Registers<Precision8, Bits4>
        for [u64; crate::utils::ceil(usize::pow(2, 8), 64 / 4)] {
            type Iter<'words> = RegisterIter<'words, Precision8, Bits4>;
            type IterZipped<'words> = TupleIter<'words, Precision8, Bits4>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 8), 64 / 4)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision8 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits4,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits4,
                            2,
                        >([left, right], step * Bits4::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision8 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits4>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision8 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision8 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision8 as Precision>::NumberOfRegisters = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits4,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision8::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits4,
                            1,
                        >([word_copy], step * Bits4::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision8::EXPONENT,
                                            Bits4::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits4::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision8 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision8 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision8::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision8::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision8::EXPONENT,
                                    Bits4::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision8,
                    Bits4,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits4::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK
                        << (register_position * Bits4::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits4::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision8 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision8,
                    Bits4,
                >(index);
                extract_register_from_word::<
                    Bits4,
                    1,
                >([self[word_position]], register_position * Bits4::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_8")]
        impl ArrayRegister<Bits5> for Precision8 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 8), 64 / 5)];
        }
        #[cfg(feature = "precision_8")]
        impl Registers<Precision8, Bits5>
        for [u64; crate::utils::ceil(usize::pow(2, 8), 64 / 5)] {
            type Iter<'words> = RegisterIter<'words, Precision8, Bits5>;
            type IterZipped<'words> = TupleIter<'words, Precision8, Bits5>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 8), 64 / 5)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision8 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits5,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits5,
                            2,
                        >([left, right], step * Bits5::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision8 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits5>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision8 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision8 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision8 as Precision>::NumberOfRegisters = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits5,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision8::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits5,
                            1,
                        >([word_copy], step * Bits5::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision8::EXPONENT,
                                            Bits5::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits5::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision8 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision8 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision8::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision8::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision8::EXPONENT,
                                    Bits5::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision8,
                    Bits5,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits5::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK
                        << (register_position * Bits5::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits5::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision8 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision8,
                    Bits5,
                >(index);
                extract_register_from_word::<
                    Bits5,
                    1,
                >([self[word_position]], register_position * Bits5::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_8")]
        impl ArrayRegister<Bits6> for Precision8 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 8), 64 / 6)];
        }
        #[cfg(feature = "precision_8")]
        impl Registers<Precision8, Bits6>
        for [u64; crate::utils::ceil(usize::pow(2, 8), 64 / 6)] {
            type Iter<'words> = RegisterIter<'words, Precision8, Bits6>;
            type IterZipped<'words> = TupleIter<'words, Precision8, Bits6>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 8), 64 / 6)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision8 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits6,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits6,
                            2,
                        >([left, right], step * Bits6::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision8 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits6>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision8 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision8 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision8 as Precision>::NumberOfRegisters = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits6,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision8::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits6,
                            1,
                        >([word_copy], step * Bits6::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision8::EXPONENT,
                                            Bits6::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits6::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision8 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision8 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision8::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision8::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision8::EXPONENT,
                                    Bits6::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision8,
                    Bits6,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits6::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK
                        << (register_position * Bits6::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits6::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision8 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision8,
                    Bits6,
                >(index);
                extract_register_from_word::<
                    Bits6,
                    1,
                >([self[word_position]], register_position * Bits6::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_8")]
        impl ArrayRegister<Bits7> for Precision8 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 8), 64 / 7)];
        }
        #[cfg(feature = "precision_8")]
        impl Registers<Precision8, Bits7>
        for [u64; crate::utils::ceil(usize::pow(2, 8), 64 / 7)] {
            type Iter<'words> = RegisterIter<'words, Precision8, Bits7>;
            type IterZipped<'words> = TupleIter<'words, Precision8, Bits7>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 8), 64 / 7)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision8 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits7,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits7,
                            2,
                        >([left, right], step * Bits7::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision8 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits7>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision8 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision8 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision8 as Precision>::NumberOfRegisters = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits7,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision8::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits7,
                            1,
                        >([word_copy], step * Bits7::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision8::EXPONENT,
                                            Bits7::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits7::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision8 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision8 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision8::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision8::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision8::EXPONENT,
                                    Bits7::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision8,
                    Bits7,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits7::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK
                        << (register_position * Bits7::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits7::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision8 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision8,
                    Bits7,
                >(index);
                extract_register_from_word::<
                    Bits7,
                    1,
                >([self[word_position]], register_position * Bits7::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_8")]
        impl ArrayRegister<Bits8> for Precision8 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 8), 64 / 8)];
        }
        #[cfg(feature = "precision_8")]
        impl Registers<Precision8, Bits8>
        for [u64; crate::utils::ceil(usize::pow(2, 8), 64 / 8)] {
            type Iter<'words> = RegisterIter<'words, Precision8, Bits8>;
            type IterZipped<'words> = TupleIter<'words, Precision8, Bits8>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 8), 64 / 8)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision8 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits8,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits8,
                            2,
                        >([left, right], step * Bits8::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision8 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits8>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision8 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision8 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision8 as Precision>::NumberOfRegisters = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits8,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision8::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits8,
                            1,
                        >([word_copy], step * Bits8::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision8::EXPONENT,
                                            Bits8::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits8::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision8 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision8 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision8::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision8::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision8::EXPONENT,
                                    Bits8::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision8,
                    Bits8,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits8::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK
                        << (register_position * Bits8::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits8::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision8 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision8,
                    Bits8,
                >(index);
                extract_register_from_word::<
                    Bits8,
                    1,
                >([self[word_position]], register_position * Bits8::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_9")]
        impl ArrayRegister<Bits1> for Precision9 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 9), 64 / 1)];
        }
        #[cfg(feature = "precision_9")]
        impl Registers<Precision9, Bits1>
        for [u64; crate::utils::ceil(usize::pow(2, 9), 64 / 1)] {
            type Iter<'words> = RegisterIter<'words, Precision9, Bits1>;
            type IterZipped<'words> = TupleIter<'words, Precision9, Bits1>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 9), 64 / 1)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision9 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits1,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits1,
                            2,
                        >([left, right], step * Bits1::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision9 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits1>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision9 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision9 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision9 as Precision>::NumberOfRegisters = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits1,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision9::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits1,
                            1,
                        >([word_copy], step * Bits1::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision9::EXPONENT,
                                            Bits1::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits1::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision9 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision9 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision9::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision9::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision9::EXPONENT,
                                    Bits1::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision9,
                    Bits1,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits1::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK
                        << (register_position * Bits1::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits1::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision9 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision9,
                    Bits1,
                >(index);
                extract_register_from_word::<
                    Bits1,
                    1,
                >([self[word_position]], register_position * Bits1::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_9")]
        impl ArrayRegister<Bits2> for Precision9 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 9), 64 / 2)];
        }
        #[cfg(feature = "precision_9")]
        impl Registers<Precision9, Bits2>
        for [u64; crate::utils::ceil(usize::pow(2, 9), 64 / 2)] {
            type Iter<'words> = RegisterIter<'words, Precision9, Bits2>;
            type IterZipped<'words> = TupleIter<'words, Precision9, Bits2>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 9), 64 / 2)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision9 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits2,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits2,
                            2,
                        >([left, right], step * Bits2::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision9 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits2>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision9 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision9 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision9 as Precision>::NumberOfRegisters = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits2,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision9::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits2,
                            1,
                        >([word_copy], step * Bits2::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision9::EXPONENT,
                                            Bits2::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits2::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision9 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision9 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision9::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision9::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision9::EXPONENT,
                                    Bits2::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision9,
                    Bits2,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits2::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK
                        << (register_position * Bits2::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits2::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision9 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision9,
                    Bits2,
                >(index);
                extract_register_from_word::<
                    Bits2,
                    1,
                >([self[word_position]], register_position * Bits2::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_9")]
        impl ArrayRegister<Bits3> for Precision9 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 9), 64 / 3)];
        }
        #[cfg(feature = "precision_9")]
        impl Registers<Precision9, Bits3>
        for [u64; crate::utils::ceil(usize::pow(2, 9), 64 / 3)] {
            type Iter<'words> = RegisterIter<'words, Precision9, Bits3>;
            type IterZipped<'words> = TupleIter<'words, Precision9, Bits3>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 9), 64 / 3)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision9 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits3,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits3,
                            2,
                        >([left, right], step * Bits3::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision9 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits3>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision9 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision9 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision9 as Precision>::NumberOfRegisters = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits3,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision9::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits3,
                            1,
                        >([word_copy], step * Bits3::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision9::EXPONENT,
                                            Bits3::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits3::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision9 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision9 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision9::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision9::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision9::EXPONENT,
                                    Bits3::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision9,
                    Bits3,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits3::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK
                        << (register_position * Bits3::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits3::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision9 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision9,
                    Bits3,
                >(index);
                extract_register_from_word::<
                    Bits3,
                    1,
                >([self[word_position]], register_position * Bits3::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_9")]
        impl ArrayRegister<Bits4> for Precision9 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 9), 64 / 4)];
        }
        #[cfg(feature = "precision_9")]
        impl Registers<Precision9, Bits4>
        for [u64; crate::utils::ceil(usize::pow(2, 9), 64 / 4)] {
            type Iter<'words> = RegisterIter<'words, Precision9, Bits4>;
            type IterZipped<'words> = TupleIter<'words, Precision9, Bits4>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 9), 64 / 4)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision9 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits4,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits4,
                            2,
                        >([left, right], step * Bits4::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision9 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits4>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision9 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision9 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision9 as Precision>::NumberOfRegisters = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits4,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision9::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits4,
                            1,
                        >([word_copy], step * Bits4::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision9::EXPONENT,
                                            Bits4::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits4::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision9 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision9 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision9::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision9::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision9::EXPONENT,
                                    Bits4::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision9,
                    Bits4,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits4::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK
                        << (register_position * Bits4::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits4::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision9 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision9,
                    Bits4,
                >(index);
                extract_register_from_word::<
                    Bits4,
                    1,
                >([self[word_position]], register_position * Bits4::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_9")]
        impl ArrayRegister<Bits5> for Precision9 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 9), 64 / 5)];
        }
        #[cfg(feature = "precision_9")]
        impl Registers<Precision9, Bits5>
        for [u64; crate::utils::ceil(usize::pow(2, 9), 64 / 5)] {
            type Iter<'words> = RegisterIter<'words, Precision9, Bits5>;
            type IterZipped<'words> = TupleIter<'words, Precision9, Bits5>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 9), 64 / 5)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision9 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits5,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits5,
                            2,
                        >([left, right], step * Bits5::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision9 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits5>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision9 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision9 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision9 as Precision>::NumberOfRegisters = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits5,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision9::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits5,
                            1,
                        >([word_copy], step * Bits5::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision9::EXPONENT,
                                            Bits5::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits5::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision9 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision9 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision9::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision9::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision9::EXPONENT,
                                    Bits5::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision9,
                    Bits5,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits5::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK
                        << (register_position * Bits5::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits5::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision9 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision9,
                    Bits5,
                >(index);
                extract_register_from_word::<
                    Bits5,
                    1,
                >([self[word_position]], register_position * Bits5::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_9")]
        impl ArrayRegister<Bits6> for Precision9 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 9), 64 / 6)];
        }
        #[cfg(feature = "precision_9")]
        impl Registers<Precision9, Bits6>
        for [u64; crate::utils::ceil(usize::pow(2, 9), 64 / 6)] {
            type Iter<'words> = RegisterIter<'words, Precision9, Bits6>;
            type IterZipped<'words> = TupleIter<'words, Precision9, Bits6>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 9), 64 / 6)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision9 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits6,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits6,
                            2,
                        >([left, right], step * Bits6::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision9 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits6>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision9 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision9 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision9 as Precision>::NumberOfRegisters = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits6,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision9::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits6,
                            1,
                        >([word_copy], step * Bits6::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision9::EXPONENT,
                                            Bits6::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits6::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision9 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision9 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision9::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision9::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision9::EXPONENT,
                                    Bits6::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision9,
                    Bits6,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits6::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK
                        << (register_position * Bits6::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits6::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision9 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision9,
                    Bits6,
                >(index);
                extract_register_from_word::<
                    Bits6,
                    1,
                >([self[word_position]], register_position * Bits6::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_9")]
        impl ArrayRegister<Bits7> for Precision9 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 9), 64 / 7)];
        }
        #[cfg(feature = "precision_9")]
        impl Registers<Precision9, Bits7>
        for [u64; crate::utils::ceil(usize::pow(2, 9), 64 / 7)] {
            type Iter<'words> = RegisterIter<'words, Precision9, Bits7>;
            type IterZipped<'words> = TupleIter<'words, Precision9, Bits7>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 9), 64 / 7)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision9 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits7,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits7,
                            2,
                        >([left, right], step * Bits7::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision9 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits7>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision9 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision9 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision9 as Precision>::NumberOfRegisters = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits7,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision9::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits7,
                            1,
                        >([word_copy], step * Bits7::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision9::EXPONENT,
                                            Bits7::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits7::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision9 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision9 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision9::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision9::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision9::EXPONENT,
                                    Bits7::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision9,
                    Bits7,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits7::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK
                        << (register_position * Bits7::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits7::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision9 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision9,
                    Bits7,
                >(index);
                extract_register_from_word::<
                    Bits7,
                    1,
                >([self[word_position]], register_position * Bits7::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_9")]
        impl ArrayRegister<Bits8> for Precision9 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 9), 64 / 8)];
        }
        #[cfg(feature = "precision_9")]
        impl Registers<Precision9, Bits8>
        for [u64; crate::utils::ceil(usize::pow(2, 9), 64 / 8)] {
            type Iter<'words> = RegisterIter<'words, Precision9, Bits8>;
            type IterZipped<'words> = TupleIter<'words, Precision9, Bits8>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 9), 64 / 8)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision9 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits8,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits8,
                            2,
                        >([left, right], step * Bits8::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision9 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits8>>::NUMBER_OF_REGISTERS_IN_WORD,
                            ) - u64::from(<Precision9 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision9 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision9 as Precision>::NumberOfRegisters = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits8,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision9::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits8,
                            1,
                        >([word_copy], step * Bits8::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision9::EXPONENT,
                                            Bits8::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits8::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision9 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision9 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision9::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision9::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision9::EXPONENT,
                                    Bits8::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision9,
                    Bits8,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits8::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK
                        << (register_position * Bits8::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits8::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision9 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision9,
                    Bits8,
                >(index);
                extract_register_from_word::<
                    Bits8,
                    1,
                >([self[word_position]], register_position * Bits8::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_10")]
        impl ArrayRegister<Bits1> for Precision10 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 10), 64 / 1)];
        }
        #[cfg(feature = "precision_10")]
        impl Registers<Precision10, Bits1>
        for [u64; crate::utils::ceil(usize::pow(2, 10), 64 / 1)] {
            type Iter<'words> = RegisterIter<'words, Precision10, Bits1>;
            type IterZipped<'words> = TupleIter<'words, Precision10, Bits1>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 10), 64 / 1)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision10 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits1,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits1,
                            2,
                        >([left, right], step * Bits1::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision10 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits1>>::NUMBER_OF_REGISTERS_IN_WORD,
                            )
                            - u64::from(<Precision10 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision10 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision10 as Precision>::NumberOfRegisters = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits1,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision10::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits1,
                            1,
                        >([word_copy], step * Bits1::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision10::EXPONENT,
                                            Bits1::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits1::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision10 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision10 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision10::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision10::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision10::EXPONENT,
                                    Bits1::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision10,
                    Bits1,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits1::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK
                        << (register_position * Bits1::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits1::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision10 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision10,
                    Bits1,
                >(index);
                extract_register_from_word::<
                    Bits1,
                    1,
                >([self[word_position]], register_position * Bits1::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_10")]
        impl ArrayRegister<Bits2> for Precision10 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 10), 64 / 2)];
        }
        #[cfg(feature = "precision_10")]
        impl Registers<Precision10, Bits2>
        for [u64; crate::utils::ceil(usize::pow(2, 10), 64 / 2)] {
            type Iter<'words> = RegisterIter<'words, Precision10, Bits2>;
            type IterZipped<'words> = TupleIter<'words, Precision10, Bits2>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 10), 64 / 2)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision10 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits2,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits2,
                            2,
                        >([left, right], step * Bits2::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision10 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits2>>::NUMBER_OF_REGISTERS_IN_WORD,
                            )
                            - u64::from(<Precision10 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision10 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision10 as Precision>::NumberOfRegisters = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits2,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision10::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits2,
                            1,
                        >([word_copy], step * Bits2::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision10::EXPONENT,
                                            Bits2::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits2::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision10 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision10 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision10::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision10::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision10::EXPONENT,
                                    Bits2::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision10,
                    Bits2,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits2::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK
                        << (register_position * Bits2::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits2::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision10 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision10,
                    Bits2,
                >(index);
                extract_register_from_word::<
                    Bits2,
                    1,
                >([self[word_position]], register_position * Bits2::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_10")]
        impl ArrayRegister<Bits3> for Precision10 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 10), 64 / 3)];
        }
        #[cfg(feature = "precision_10")]
        impl Registers<Precision10, Bits3>
        for [u64; crate::utils::ceil(usize::pow(2, 10), 64 / 3)] {
            type Iter<'words> = RegisterIter<'words, Precision10, Bits3>;
            type IterZipped<'words> = TupleIter<'words, Precision10, Bits3>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 10), 64 / 3)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision10 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits3,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits3,
                            2,
                        >([left, right], step * Bits3::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision10 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits3>>::NUMBER_OF_REGISTERS_IN_WORD,
                            )
                            - u64::from(<Precision10 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision10 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision10 as Precision>::NumberOfRegisters = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits3,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision10::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits3,
                            1,
                        >([word_copy], step * Bits3::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision10::EXPONENT,
                                            Bits3::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits3::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision10 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision10 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision10::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision10::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision10::EXPONENT,
                                    Bits3::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision10,
                    Bits3,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits3::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK
                        << (register_position * Bits3::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits3::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision10 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision10,
                    Bits3,
                >(index);
                extract_register_from_word::<
                    Bits3,
                    1,
                >([self[word_position]], register_position * Bits3::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_10")]
        impl ArrayRegister<Bits4> for Precision10 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 10), 64 / 4)];
        }
        #[cfg(feature = "precision_10")]
        impl Registers<Precision10, Bits4>
        for [u64; crate::utils::ceil(usize::pow(2, 10), 64 / 4)] {
            type Iter<'words> = RegisterIter<'words, Precision10, Bits4>;
            type IterZipped<'words> = TupleIter<'words, Precision10, Bits4>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 10), 64 / 4)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision10 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits4,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits4,
                            2,
                        >([left, right], step * Bits4::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision10 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits4>>::NUMBER_OF_REGISTERS_IN_WORD,
                            )
                            - u64::from(<Precision10 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision10 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision10 as Precision>::NumberOfRegisters = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits4,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision10::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits4,
                            1,
                        >([word_copy], step * Bits4::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision10::EXPONENT,
                                            Bits4::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits4::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision10 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision10 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision10::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision10::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision10::EXPONENT,
                                    Bits4::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision10,
                    Bits4,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits4::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK
                        << (register_position * Bits4::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits4::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision10 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision10,
                    Bits4,
                >(index);
                extract_register_from_word::<
                    Bits4,
                    1,
                >([self[word_position]], register_position * Bits4::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_10")]
        impl ArrayRegister<Bits5> for Precision10 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 10), 64 / 5)];
        }
        #[cfg(feature = "precision_10")]
        impl Registers<Precision10, Bits5>
        for [u64; crate::utils::ceil(usize::pow(2, 10), 64 / 5)] {
            type Iter<'words> = RegisterIter<'words, Precision10, Bits5>;
            type IterZipped<'words> = TupleIter<'words, Precision10, Bits5>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 10), 64 / 5)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision10 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits5,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits5,
                            2,
                        >([left, right], step * Bits5::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision10 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits5>>::NUMBER_OF_REGISTERS_IN_WORD,
                            )
                            - u64::from(<Precision10 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision10 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision10 as Precision>::NumberOfRegisters = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits5,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision10::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits5,
                            1,
                        >([word_copy], step * Bits5::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision10::EXPONENT,
                                            Bits5::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits5::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision10 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision10 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision10::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision10::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision10::EXPONENT,
                                    Bits5::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision10,
                    Bits5,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits5::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK
                        << (register_position * Bits5::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits5::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision10 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision10,
                    Bits5,
                >(index);
                extract_register_from_word::<
                    Bits5,
                    1,
                >([self[word_position]], register_position * Bits5::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_10")]
        impl ArrayRegister<Bits6> for Precision10 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 10), 64 / 6)];
        }
        #[cfg(feature = "precision_10")]
        impl Registers<Precision10, Bits6>
        for [u64; crate::utils::ceil(usize::pow(2, 10), 64 / 6)] {
            type Iter<'words> = RegisterIter<'words, Precision10, Bits6>;
            type IterZipped<'words> = TupleIter<'words, Precision10, Bits6>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 10), 64 / 6)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision10 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits6,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits6,
                            2,
                        >([left, right], step * Bits6::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision10 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits6>>::NUMBER_OF_REGISTERS_IN_WORD,
                            )
                            - u64::from(<Precision10 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision10 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision10 as Precision>::NumberOfRegisters = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits6,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision10::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits6,
                            1,
                        >([word_copy], step * Bits6::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision10::EXPONENT,
                                            Bits6::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits6::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision10 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision10 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision10::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision10::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision10::EXPONENT,
                                    Bits6::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision10,
                    Bits6,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits6::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK
                        << (register_position * Bits6::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits6::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision10 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision10,
                    Bits6,
                >(index);
                extract_register_from_word::<
                    Bits6,
                    1,
                >([self[word_position]], register_position * Bits6::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_10")]
        impl ArrayRegister<Bits7> for Precision10 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 10), 64 / 7)];
        }
        #[cfg(feature = "precision_10")]
        impl Registers<Precision10, Bits7>
        for [u64; crate::utils::ceil(usize::pow(2, 10), 64 / 7)] {
            type Iter<'words> = RegisterIter<'words, Precision10, Bits7>;
            type IterZipped<'words> = TupleIter<'words, Precision10, Bits7>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 10), 64 / 7)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision10 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits7,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits7,
                            2,
                        >([left, right], step * Bits7::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision10 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits7>>::NUMBER_OF_REGISTERS_IN_WORD,
                            )
                            - u64::from(<Precision10 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision10 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision10 as Precision>::NumberOfRegisters = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits7,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision10::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits7,
                            1,
                        >([word_copy], step * Bits7::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision10::EXPONENT,
                                            Bits7::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits7::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision10 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision10 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision10::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision10::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision10::EXPONENT,
                                    Bits7::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision10,
                    Bits7,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits7::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK
                        << (register_position * Bits7::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits7::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision10 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision10,
                    Bits7,
                >(index);
                extract_register_from_word::<
                    Bits7,
                    1,
                >([self[word_position]], register_position * Bits7::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_10")]
        impl ArrayRegister<Bits8> for Precision10 {
            type ArrayRegister = [u64; crate::utils::ceil(usize::pow(2, 10), 64 / 8)];
        }
        #[cfg(feature = "precision_10")]
        impl Registers<Precision10, Bits8>
        for [u64; crate::utils::ceil(usize::pow(2, 10), 64 / 8)] {
            type Iter<'words> = RegisterIter<'words, Precision10, Bits8>;
            type IterZipped<'words> = TupleIter<'words, Precision10, Bits8>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                [0; crate::utils::ceil(usize::pow(2, 10), 64 / 8)]
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                TupleIter::new(self.iter(), other.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision10 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                for i in 0..self.len() {
                    let left = self[i];
                    let right = other[i];
                    let mut partial_sum = f64::ZERO;
                    let mut partial_zeros = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                    for step in 0..<u64 as RegisterWord<
                        Bits8,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        let [left_register, right_register] = extract_register_from_word::<
                            Bits8,
                            2,
                        >([left, right], step * Bits8::NUMBER_OF_BITS);
                        let max_register = left_register.max(right_register);
                        partial_sum += f64::integer_exp2_minus(max_register);
                        partial_zeros
                            += <Precision10 as Precision>::NumberOfRegisters::from_bool(
                                max_register == 0,
                            );
                    }
                    harmonic_sum += partial_sum;
                    union_zeros += partial_zeros;
                }
                let number_of_padding_registers: u8 = u8::try_from(
                        u64::try_from(self.len()).unwrap()
                            * u64::from(
                                <u64 as RegisterWord<Bits8>>::NUMBER_OF_REGISTERS_IN_WORD,
                            )
                            - u64::from(<Precision10 as Precision>::NUMBER_OF_REGISTERS),
                    )
                    .unwrap();
                union_zeros
                    -= <Precision10 as Precision>::NumberOfRegisters::from(
                        number_of_padding_registers,
                    );
                harmonic_sum -= f64::from(number_of_padding_registers);
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers: <Precision10 as Precision>::NumberOfRegisters = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                for word in self.iter_mut() {
                    let word_copy = *word;
                    let mut tmp_word: u64 = 0;
                    for step in 0..<u64 as RegisterWord<
                        Bits8,
                    >>::NUMBER_OF_REGISTERS_IN_WORD {
                        if number_of_registers == Precision10::NUMBER_OF_REGISTERS {
                            break;
                        }
                        let [register] = extract_register_from_word::<
                            Bits8,
                            1,
                        >([word_copy], step * Bits8::NUMBER_OF_BITS);
                        let new_register = register_function(register);
                        if true {
                            if !(new_register
                                <= u8::try_from(
                                        <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                                    )
                                    .unwrap())
                            {
                                {
                                    ::core::panicking::panic_fmt(
                                        format_args!(
                                            "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                            Precision10::EXPONENT,
                                            Bits8::NUMBER_OF_BITS,
                                            u8::try_from(
                                                    <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                                                )
                                                .unwrap(),
                                            new_register,
                                        ),
                                    );
                                }
                            }
                        }
                        tmp_word
                            |= u64::from(new_register) << (step * Bits8::NUMBER_OF_BITS);
                        number_of_registers
                            += <Precision10 as Precision>::NumberOfRegisters::ONE;
                    }
                    *word = tmp_word;
                }
            }
            #[inline]
            fn set_greater(
                &mut self,
                index: <Precision10 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision10::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision10::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "Expected the new register at precision {0} and bits {1} to be <= {2} but got {3}.",
                                    Precision10::EXPONENT,
                                    Bits8::NUMBER_OF_BITS,
                                    u8::try_from(
                                            <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                                        )
                                        .unwrap(),
                                    new_register,
                                ),
                            );
                        }
                    }
                }
                let (word_position, register_position) = split_index::<
                    Precision10,
                    Bits8,
                >(index);
                let register_value: u8 = u8::try_from(
                        (self[word_position]
                            >> (register_position * Bits8::NUMBER_OF_BITS))
                            & <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                    )
                    .unwrap();
                if register_value >= new_register {
                    return (register_value, register_value);
                }
                self[word_position]
                    &= !(<u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK
                        << (register_position * Bits8::NUMBER_OF_BITS));
                self[word_position]
                    |= u64::from(new_register)
                        << (register_position * Bits8::NUMBER_OF_BITS);
                (register_value, new_register)
            }
            #[inline]
            fn get_register(
                &self,
                index: <Precision10 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, register_position) = split_index::<
                    Precision10,
                    Bits8,
                >(index);
                extract_register_from_word::<
                    Bits8,
                    1,
                >([self[word_position]], register_position * Bits8::NUMBER_OF_BITS)[0]
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.iter_mut() {
                    *word = 0;
                }
            }
        }
    }
    mod packed_array {
        //! Packed array for registers.
        //!
        //! The principal difference between this implementation and the one in either `array.rs` or
        //! `vector.rs` is that this implementation uses a packed array to store the registers. This means
        //! that while in the other implementations we store as many registers as they fit in a word and we
        //! discard the padding bits (e.g. when using a 64-bit word and a 6-bit register, we store 10 registers and
        //! discard 4 bits), in this implementation we store the registers in a packed array, so we don't discard
        //! any bits. This will tendentially make the packed array implementation more memory efficient, but
        //! it will also make it slower, as we need to perform more operations to extract the registers from the
        //! packed array, expecially in the case of bridge registers, i.e. registers that span two words.
        use super::{
            extract_register_from_word, Bits, Bits1, Bits2, Bits3, Bits4, Bits5, Bits6,
            Bits7, Bits8, FloatOps, Number, One, Precision, RegisterWord, Registers,
            Words, Zero,
        };
        use core::fmt::Debug;
        use core::iter::Copied;
        use core::marker::PhantomData;
        use core::slice::Iter;
        #[cfg(feature = "std")]
        use crate::utils::Named;
        #[cfg(feature = "mem_dbg")]
        use mem_dbg::{MemDbg, MemSize};
        #[cfg(feature = "precision_10")]
        use crate::prelude::Precision10;
        #[cfg(feature = "precision_4")]
        use crate::prelude::Precision4;
        #[cfg(feature = "precision_5")]
        use crate::prelude::Precision5;
        #[cfg(feature = "precision_6")]
        use crate::prelude::Precision6;
        #[cfg(feature = "precision_7")]
        use crate::prelude::Precision7;
        #[cfg(feature = "precision_8")]
        use crate::prelude::Precision8;
        #[cfg(feature = "precision_9")]
        use crate::prelude::Precision9;
        /// Extracts a bridge register from a starting word and an ending word.
        fn extract_bridge_register_from_word<B: Bits, const N: usize>(
            lower_word: [u64; N],
            upper_word: [u64; N],
            offset: u8,
        ) -> [u8; N]
        where
            u64: RegisterWord<B>,
        {
            if true {
                if !(offset + B::NUMBER_OF_BITS > u64::NUMBER_OF_BITS) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "Offset + bits ({0} + {1}) should be greater than {2}",
                                offset,
                                B::NUMBER_OF_BITS,
                                u64::NUMBER_OF_BITS,
                            ),
                        );
                    }
                }
            }
            if true {
                if !(offset <= u64::NUMBER_OF_BITS) {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "Offset {0} should be less than {1}",
                                offset,
                                u64::NUMBER_OF_BITS,
                            ),
                        );
                    }
                }
            }
            let mut registers = [0_u8; N];
            for i in 0..N {
                let number_of_bits_in_lower_register = u64::NUMBER_OF_BITS - offset;
                let number_of_bits_in_upper_register = B::NUMBER_OF_BITS
                    - number_of_bits_in_lower_register;
                let upper_register_mask = (u64::ONE << number_of_bits_in_upper_register)
                    - u64::ONE;
                let lower_register = if offset == u64::NUMBER_OF_BITS {
                    u64::ZERO
                } else {
                    lower_word[i] >> offset
                };
                let upper_register = upper_word[i] & upper_register_mask;
                registers[i] = u8::try_from(
                        (upper_register << number_of_bits_in_lower_register)
                            | lower_register,
                    )
                    .unwrap();
            }
            registers
        }
        /// Iterator over the registers of a packed array.
        pub struct RegisterIter<'words, P: Precision, B: Bits> {
            /// The current register index across the packed array.
            current_register: P::NumberOfRegisters,
            /// The offset in bits of the current word. In the case of bridge registers, this will be the
            /// offset of the bridge size from the previous word.
            word_offset: u8,
            /// The iterator over the words of the packed array.
            words: Iter<'words, u64>,
            /// The current register being processed.
            current_word: Option<u64>,
            /// Phantom data to keep track of the precision, bits, and registers.
            _phantom: PhantomData<(P, B)>,
        }
        /// New constructor for [`RegisterIter`].
        impl<'words, P: Precision, B: Bits> RegisterIter<'words, P, B> {
            /// Creates a new instance of the register iterator.
            fn new(mut words: Iter<'words, u64>) -> Self {
                Self {
                    current_register: P::NumberOfRegisters::ZERO,
                    word_offset: 0,
                    current_word: words.next().copied(),
                    words,
                    _phantom: PhantomData,
                }
            }
        }
        /// Implementation of the Iterator trait for [`RegisterIter`].
        impl<'words, P: Precision, B: Bits> Iterator for RegisterIter<'words, P, B> {
            type Item = u8;
            fn next(&mut self) -> Option<Self::Item> {
                if self.current_register == P::NUMBER_OF_REGISTERS {
                    return None;
                }
                self.current_word
                    .and_then(|word| {
                        self.current_register += P::NumberOfRegisters::ONE;
                        if self.word_offset + B::NUMBER_OF_BITS <= 64 {
                            let [register] = extract_register_from_word::<
                                B,
                                1,
                            >([word], self.word_offset);
                            self.word_offset += B::NUMBER_OF_BITS;
                            return Some(register);
                        }
                        self.current_word = self.words.next().copied();
                        self.current_word
                            .map(|next_word| {
                                let register = extract_bridge_register_from_word::<
                                    B,
                                    1,
                                >([word], [next_word], self.word_offset)[0];
                                self.word_offset = B::NUMBER_OF_BITS
                                    - (64 - self.word_offset);
                                register
                            })
                    })
            }
        }
        /// Iterator over the registers of two packed arrays.
        pub struct RegisterTupleIter<'words, P: Precision, B: Bits> {
            /// The current register index across the packed array.
            current_register: P::NumberOfRegisters,
            /// The offset in bits of the current word. In the case of bridge registers, this will be the
            /// offset of the bridge size from the previous word.
            word_offset: u8,
            /// The iterator over the words of the left packed array.
            left: Iter<'words, u64>,
            /// The iterator over the words of the right packed array.
            right: Iter<'words, u64>,
            /// The current word tuple being processed.
            current_word: Option<(u64, u64)>,
            /// Phantom data to keep track of the precision, bits, and registers.
            _phantom: PhantomData<(P, B)>,
        }
        /// Constructor for [`RegisterTupleIter`].
        impl<'words, P: Precision, B: Bits> RegisterTupleIter<'words, P, B> {
            #[inline]
            /// Creates a new instance of the register tuple iterator.
            fn new(mut left: Iter<'words, u64>, mut right: Iter<'words, u64>) -> Self {
                let current_word = left
                    .next()
                    .copied()
                    .and_then(|left_word| {
                        right.next().copied().map(|right_word| (left_word, right_word))
                    });
                Self {
                    current_register: P::NumberOfRegisters::ZERO,
                    word_offset: 0,
                    left,
                    right,
                    current_word,
                    _phantom: PhantomData,
                }
            }
        }
        /// Implementation of the Iterator trait for [`RegisterTupleIter`].
        impl<'words, P: Precision, B: Bits> Iterator
        for RegisterTupleIter<'words, P, B> {
            type Item = (u8, u8);
            fn next(&mut self) -> Option<Self::Item> {
                if self.current_register == P::NUMBER_OF_REGISTERS {
                    return None;
                }
                self.current_word
                    .and_then(|(left_word, right_word)| {
                        self.current_register += P::NumberOfRegisters::ONE;
                        if self.word_offset + B::NUMBER_OF_BITS <= 64 {
                            let [left_register, right_register] = extract_register_from_word::<
                                B,
                                2,
                            >([left_word, right_word], self.word_offset);
                            self.word_offset += B::NUMBER_OF_BITS;
                            return Some((left_register, right_register));
                        }
                        self.current_word = self
                            .left
                            .next()
                            .copied()
                            .and_then(|new_left_word| {
                                self.right
                                    .next()
                                    .copied()
                                    .map(|new_right_word| (new_left_word, new_right_word))
                            });
                        self.current_word
                            .map(|(next_left_word, next_right_word)| {
                                let [left_register, right_register] = extract_bridge_register_from_word::<
                                    B,
                                    2,
                                >(
                                    [left_word, right_word],
                                    [next_left_word, next_right_word],
                                    self.word_offset,
                                );
                                self.word_offset = B::NUMBER_OF_BITS
                                    - (64 - self.word_offset);
                                (left_register, right_register)
                            })
                    })
            }
        }
        /// Register implementation for the packed array registers.
        pub struct PackedArray<const N: usize> {
            /// The packed array of registers.
            words: [u64; N],
        }
        #[automatically_derived]
        impl<const N: usize> mem_dbg::MemDbgImpl for PackedArray<N>
        where
            [u64; N]: mem_dbg::MemDbgImpl,
        {
            #[inline(always)]
            fn _mem_dbg_rec_on(
                &self,
                _memdbg_writer: &mut impl core::fmt::Write,
                _memdbg_total_size: usize,
                _memdbg_max_depth: usize,
                _memdbg_prefix: &mut String,
                _memdbg_is_last: bool,
                _memdbg_flags: mem_dbg::DbgFlags,
            ) -> core::fmt::Result {
                let mut id_sizes: Vec<(usize, usize)> = ::alloc::vec::Vec::new();
                id_sizes
                    .push((0usize, { builtin # offset_of(PackedArray < N >, words) }));
                let n = id_sizes.len();
                id_sizes.push((n, core::mem::size_of::<Self>()));
                id_sizes.sort_by_key(|x| x.1);
                for i in 0..n {
                    id_sizes[i].1 = id_sizes[i + 1].1 - id_sizes[i].1;
                }
                if !_memdbg_flags.contains(mem_dbg::DbgFlags::RUST_LAYOUT) {
                    id_sizes.sort_by_key(|x| x.0);
                }
                for (i, (field_idx, padded_size)) in id_sizes
                    .into_iter()
                    .enumerate()
                    .take(n)
                {
                    match field_idx {
                        0usize => {
                            <[u64; N] as mem_dbg::MemDbgImpl>::_mem_dbg_depth_on(
                                &self.words,
                                _memdbg_writer,
                                _memdbg_total_size,
                                _memdbg_max_depth,
                                _memdbg_prefix,
                                Some("words"),
                                i == n - 1,
                                padded_size,
                                _memdbg_flags,
                            )?
                        }
                        _ => {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                    }
                }
                Ok(())
            }
        }
        #[automatically_derived]
        impl<const N: usize> mem_dbg::CopyType for PackedArray<N>
        where
            [u64; N]: mem_dbg::MemSize,
        {
            type Copy = mem_dbg::False;
        }
        #[automatically_derived]
        impl<const N: usize> mem_dbg::MemSize for PackedArray<N>
        where
            [u64; N]: mem_dbg::MemSize,
        {
            fn mem_size(&self, _memsize_flags: mem_dbg::SizeFlags) -> usize {
                let mut bytes = core::mem::size_of::<Self>();
                bytes
                    += <[u64; N] as mem_dbg::MemSize>::mem_size(
                        &self.words,
                        _memsize_flags,
                    ) - core::mem::size_of::<[u64; N]>();
                bytes
            }
        }
        #[automatically_derived]
        impl<const N: usize> ::core::fmt::Debug for PackedArray<N> {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "PackedArray",
                    "words",
                    &&self.words,
                )
            }
        }
        #[automatically_derived]
        impl<const N: usize> ::core::clone::Clone for PackedArray<N> {
            #[inline]
            fn clone(&self) -> PackedArray<N> {
                let _: ::core::clone::AssertParamIsClone<[u64; N]>;
                *self
            }
        }
        #[automatically_derived]
        impl<const N: usize> ::core::marker::Copy for PackedArray<N> {}
        #[automatically_derived]
        impl<const N: usize> ::core::cmp::Eq for PackedArray<N> {
            #[inline]
            #[doc(hidden)]
            #[coverage(off)]
            fn assert_receiver_is_total_eq(&self) -> () {
                let _: ::core::cmp::AssertParamIsEq<[u64; N]>;
            }
        }
        #[automatically_derived]
        impl<const N: usize> ::core::marker::StructuralPartialEq for PackedArray<N> {}
        #[automatically_derived]
        impl<const N: usize> ::core::cmp::PartialEq for PackedArray<N> {
            #[inline]
            fn eq(&self, other: &PackedArray<N>) -> bool {
                self.words == other.words
            }
        }
        #[automatically_derived]
        impl<const N: usize> ::core::hash::Hash for PackedArray<N> {
            #[inline]
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                ::core::hash::Hash::hash(&self.words, state)
            }
        }
        #[cfg(feature = "std")]
        impl<const N: usize> Named for PackedArray<N> {
            #[inline]
            fn name(&self) -> String {
                "PackedArray".to_owned()
            }
        }
        impl<const N: usize> Words for PackedArray<N> {
            type WordIter<'words> = Copied<Iter<'words, u64>> where Self: 'words;
            #[inline]
            fn number_of_words(&self) -> usize {
                N
            }
            #[inline]
            fn find_sorted_with_len(&self, value: u64, len: usize) -> bool {
                self.words.find_sorted_with_len(value, len)
            }
            #[inline]
            fn sorted_insert_with_len(&mut self, value: u64, len: usize) -> bool {
                self.words.sorted_insert_with_len(value, len)
            }
            #[inline]
            fn words(&self) -> Self::WordIter<'_> {
                self.words.iter().copied()
            }
        }
        /// Trait marker to associate a specific register array with a combination of precision and bits.
        ///
        /// Meant to be associated with a specific Precision.
        pub trait PackedArrayRegister<B: Bits>: Precision {
            /// The type of the packed array register.
            #[cfg(all(feature = "std", feature = "mem_dbg"))]
            type PackedArrayRegister: Registers<Self, B>
                + Words
                + Named
                + MemDbg
                + MemSize;
        }
        /// Trait marker to associate a precision to all possible packed array registers.
        pub trait PackedArrayRegisters: PackedArrayRegister<
                Bits1,
            > + PackedArrayRegister<
                Bits2,
            > + PackedArrayRegister<
                Bits3,
            > + PackedArrayRegister<
                Bits4,
            > + PackedArrayRegister<
                Bits5,
            > + PackedArrayRegister<
                Bits6,
            > + PackedArrayRegister<Bits7> + PackedArrayRegister<Bits8> {}
        /// Extracts the word position and the relative register offset from the packed index.
        fn split_packed_index<P: Precision, B: Bits>(
            index: P::NumberOfRegisters,
        ) -> (usize, u8)
        where
            u64: RegisterWord<B>,
        {
            let number_of_bits: u64 = B::NUMBER_OF_BITS.into();
            let absolute_register_offset: u64 = number_of_bits * index.into();
            let word_position: u64 = absolute_register_offset / 64;
            let relative_register_offset = u8::try_from(
                    absolute_register_offset - word_position * 64,
                )
                .unwrap();
            (usize::try_from(word_position).unwrap(), relative_register_offset)
        }
        #[cfg(feature = "precision_4")]
        impl PackedArrayRegister<Bits1> for Precision4 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 4) * 1, 64) },
            >;
        }
        #[cfg(feature = "precision_4")]
        impl Registers<Precision4, Bits1>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 4) * 1, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision4, Bits1>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision4, Bits1>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 4) * 1, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision4 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision4::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits1::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits1,
                            2,
                        >(words, word_offset);
                        word_offset += Bits1::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits1,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits1::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision4 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision4::NUMBER_OF_REGISTERS {
                    if register_offset + Bits1::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits1,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits1::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits1::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision4 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision4::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision4::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision4,
                    Bits1,
                >(index);
                if relative_register_offset + Bits1::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits1,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits1::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision4 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision4,
                    Bits1,
                >(index);
                if relative_register_offset + Bits1::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits1,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits1,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_4")]
        impl PackedArrayRegister<Bits2> for Precision4 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 4) * 2, 64) },
            >;
        }
        #[cfg(feature = "precision_4")]
        impl Registers<Precision4, Bits2>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 4) * 2, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision4, Bits2>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision4, Bits2>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 4) * 2, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision4 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision4::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits2::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits2,
                            2,
                        >(words, word_offset);
                        word_offset += Bits2::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits2,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits2::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision4 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision4::NUMBER_OF_REGISTERS {
                    if register_offset + Bits2::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits2,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits2::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits2::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision4 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision4::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision4::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision4,
                    Bits2,
                >(index);
                if relative_register_offset + Bits2::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits2,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits2::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision4 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision4,
                    Bits2,
                >(index);
                if relative_register_offset + Bits2::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits2,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits2,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_4")]
        impl PackedArrayRegister<Bits3> for Precision4 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 4) * 3, 64) },
            >;
        }
        #[cfg(feature = "precision_4")]
        impl Registers<Precision4, Bits3>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 4) * 3, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision4, Bits3>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision4, Bits3>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 4) * 3, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision4 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision4::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits3::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits3,
                            2,
                        >(words, word_offset);
                        word_offset += Bits3::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits3,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits3::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision4 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision4::NUMBER_OF_REGISTERS {
                    if register_offset + Bits3::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits3,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits3::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits3::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision4 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision4::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision4::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision4,
                    Bits3,
                >(index);
                if relative_register_offset + Bits3::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits3,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits3::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision4 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision4,
                    Bits3,
                >(index);
                if relative_register_offset + Bits3::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits3,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits3,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_4")]
        impl PackedArrayRegister<Bits4> for Precision4 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 4) * 4, 64) },
            >;
        }
        #[cfg(feature = "precision_4")]
        impl Registers<Precision4, Bits4>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 4) * 4, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision4, Bits4>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision4, Bits4>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 4) * 4, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision4 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision4::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits4::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits4,
                            2,
                        >(words, word_offset);
                        word_offset += Bits4::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits4,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits4::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision4 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision4::NUMBER_OF_REGISTERS {
                    if register_offset + Bits4::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits4,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits4::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits4::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision4 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision4::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision4::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision4,
                    Bits4,
                >(index);
                if relative_register_offset + Bits4::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits4,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits4::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision4 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision4,
                    Bits4,
                >(index);
                if relative_register_offset + Bits4::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits4,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits4,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_4")]
        impl PackedArrayRegister<Bits5> for Precision4 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 4) * 5, 64) },
            >;
        }
        #[cfg(feature = "precision_4")]
        impl Registers<Precision4, Bits5>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 4) * 5, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision4, Bits5>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision4, Bits5>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 4) * 5, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision4 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision4::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits5::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits5,
                            2,
                        >(words, word_offset);
                        word_offset += Bits5::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits5,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits5::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision4 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision4::NUMBER_OF_REGISTERS {
                    if register_offset + Bits5::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits5,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits5::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits5::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision4 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision4::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision4::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision4,
                    Bits5,
                >(index);
                if relative_register_offset + Bits5::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits5,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits5::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision4 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision4,
                    Bits5,
                >(index);
                if relative_register_offset + Bits5::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits5,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits5,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_4")]
        impl PackedArrayRegister<Bits6> for Precision4 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 4) * 6, 64) },
            >;
        }
        #[cfg(feature = "precision_4")]
        impl Registers<Precision4, Bits6>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 4) * 6, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision4, Bits6>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision4, Bits6>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 4) * 6, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision4 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision4::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits6::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits6,
                            2,
                        >(words, word_offset);
                        word_offset += Bits6::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits6,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits6::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision4 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision4::NUMBER_OF_REGISTERS {
                    if register_offset + Bits6::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits6,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits6::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits6::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision4 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision4::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision4::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision4,
                    Bits6,
                >(index);
                if relative_register_offset + Bits6::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits6,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits6::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision4 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision4,
                    Bits6,
                >(index);
                if relative_register_offset + Bits6::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits6,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits6,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_4")]
        impl PackedArrayRegister<Bits7> for Precision4 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 4) * 7, 64) },
            >;
        }
        #[cfg(feature = "precision_4")]
        impl Registers<Precision4, Bits7>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 4) * 7, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision4, Bits7>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision4, Bits7>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 4) * 7, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision4 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision4::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits7::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits7,
                            2,
                        >(words, word_offset);
                        word_offset += Bits7::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits7,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits7::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision4 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision4::NUMBER_OF_REGISTERS {
                    if register_offset + Bits7::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits7,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits7::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits7::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision4 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision4::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision4::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision4,
                    Bits7,
                >(index);
                if relative_register_offset + Bits7::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits7,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits7::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision4 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision4,
                    Bits7,
                >(index);
                if relative_register_offset + Bits7::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits7,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits7,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_4")]
        impl PackedArrayRegister<Bits8> for Precision4 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 4) * 8, 64) },
            >;
        }
        #[cfg(feature = "precision_4")]
        impl Registers<Precision4, Bits8>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 4) * 8, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision4, Bits8>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision4, Bits8>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 4) * 8, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision4 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision4 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision4::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits8::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits8,
                            2,
                        >(words, word_offset);
                        word_offset += Bits8::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits8,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits8::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision4 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision4::NUMBER_OF_REGISTERS {
                    if register_offset + Bits8::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits8,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits8::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits8::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision4 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision4::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision4::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision4,
                    Bits8,
                >(index);
                if relative_register_offset + Bits8::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits8,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits8::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision4 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision4,
                    Bits8,
                >(index);
                if relative_register_offset + Bits8::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits8,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits8,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_5")]
        impl PackedArrayRegister<Bits1> for Precision5 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 5) * 1, 64) },
            >;
        }
        #[cfg(feature = "precision_5")]
        impl Registers<Precision5, Bits1>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 5) * 1, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision5, Bits1>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision5, Bits1>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 5) * 1, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision5 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision5::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits1::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits1,
                            2,
                        >(words, word_offset);
                        word_offset += Bits1::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits1,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits1::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision5 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision5::NUMBER_OF_REGISTERS {
                    if register_offset + Bits1::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits1,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits1::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits1::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision5 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision5::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision5::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision5,
                    Bits1,
                >(index);
                if relative_register_offset + Bits1::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits1,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits1::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision5 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision5,
                    Bits1,
                >(index);
                if relative_register_offset + Bits1::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits1,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits1,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_5")]
        impl PackedArrayRegister<Bits2> for Precision5 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 5) * 2, 64) },
            >;
        }
        #[cfg(feature = "precision_5")]
        impl Registers<Precision5, Bits2>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 5) * 2, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision5, Bits2>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision5, Bits2>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 5) * 2, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision5 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision5::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits2::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits2,
                            2,
                        >(words, word_offset);
                        word_offset += Bits2::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits2,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits2::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision5 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision5::NUMBER_OF_REGISTERS {
                    if register_offset + Bits2::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits2,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits2::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits2::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision5 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision5::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision5::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision5,
                    Bits2,
                >(index);
                if relative_register_offset + Bits2::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits2,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits2::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision5 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision5,
                    Bits2,
                >(index);
                if relative_register_offset + Bits2::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits2,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits2,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_5")]
        impl PackedArrayRegister<Bits3> for Precision5 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 5) * 3, 64) },
            >;
        }
        #[cfg(feature = "precision_5")]
        impl Registers<Precision5, Bits3>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 5) * 3, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision5, Bits3>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision5, Bits3>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 5) * 3, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision5 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision5::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits3::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits3,
                            2,
                        >(words, word_offset);
                        word_offset += Bits3::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits3,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits3::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision5 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision5::NUMBER_OF_REGISTERS {
                    if register_offset + Bits3::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits3,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits3::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits3::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision5 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision5::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision5::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision5,
                    Bits3,
                >(index);
                if relative_register_offset + Bits3::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits3,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits3::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision5 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision5,
                    Bits3,
                >(index);
                if relative_register_offset + Bits3::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits3,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits3,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_5")]
        impl PackedArrayRegister<Bits4> for Precision5 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 5) * 4, 64) },
            >;
        }
        #[cfg(feature = "precision_5")]
        impl Registers<Precision5, Bits4>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 5) * 4, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision5, Bits4>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision5, Bits4>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 5) * 4, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision5 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision5::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits4::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits4,
                            2,
                        >(words, word_offset);
                        word_offset += Bits4::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits4,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits4::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision5 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision5::NUMBER_OF_REGISTERS {
                    if register_offset + Bits4::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits4,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits4::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits4::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision5 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision5::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision5::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision5,
                    Bits4,
                >(index);
                if relative_register_offset + Bits4::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits4,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits4::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision5 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision5,
                    Bits4,
                >(index);
                if relative_register_offset + Bits4::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits4,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits4,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_5")]
        impl PackedArrayRegister<Bits5> for Precision5 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 5) * 5, 64) },
            >;
        }
        #[cfg(feature = "precision_5")]
        impl Registers<Precision5, Bits5>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 5) * 5, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision5, Bits5>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision5, Bits5>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 5) * 5, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision5 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision5::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits5::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits5,
                            2,
                        >(words, word_offset);
                        word_offset += Bits5::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits5,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits5::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision5 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision5::NUMBER_OF_REGISTERS {
                    if register_offset + Bits5::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits5,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits5::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits5::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision5 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision5::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision5::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision5,
                    Bits5,
                >(index);
                if relative_register_offset + Bits5::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits5,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits5::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision5 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision5,
                    Bits5,
                >(index);
                if relative_register_offset + Bits5::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits5,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits5,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_5")]
        impl PackedArrayRegister<Bits6> for Precision5 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 5) * 6, 64) },
            >;
        }
        #[cfg(feature = "precision_5")]
        impl Registers<Precision5, Bits6>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 5) * 6, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision5, Bits6>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision5, Bits6>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 5) * 6, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision5 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision5::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits6::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits6,
                            2,
                        >(words, word_offset);
                        word_offset += Bits6::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits6,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits6::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision5 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision5::NUMBER_OF_REGISTERS {
                    if register_offset + Bits6::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits6,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits6::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits6::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision5 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision5::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision5::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision5,
                    Bits6,
                >(index);
                if relative_register_offset + Bits6::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits6,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits6::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision5 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision5,
                    Bits6,
                >(index);
                if relative_register_offset + Bits6::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits6,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits6,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_5")]
        impl PackedArrayRegister<Bits7> for Precision5 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 5) * 7, 64) },
            >;
        }
        #[cfg(feature = "precision_5")]
        impl Registers<Precision5, Bits7>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 5) * 7, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision5, Bits7>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision5, Bits7>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 5) * 7, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision5 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision5::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits7::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits7,
                            2,
                        >(words, word_offset);
                        word_offset += Bits7::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits7,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits7::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision5 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision5::NUMBER_OF_REGISTERS {
                    if register_offset + Bits7::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits7,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits7::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits7::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision5 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision5::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision5::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision5,
                    Bits7,
                >(index);
                if relative_register_offset + Bits7::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits7,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits7::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision5 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision5,
                    Bits7,
                >(index);
                if relative_register_offset + Bits7::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits7,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits7,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_5")]
        impl PackedArrayRegister<Bits8> for Precision5 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 5) * 8, 64) },
            >;
        }
        #[cfg(feature = "precision_5")]
        impl Registers<Precision5, Bits8>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 5) * 8, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision5, Bits8>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision5, Bits8>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 5) * 8, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision5 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision5 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision5::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits8::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits8,
                            2,
                        >(words, word_offset);
                        word_offset += Bits8::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits8,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits8::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision5 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision5::NUMBER_OF_REGISTERS {
                    if register_offset + Bits8::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits8,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits8::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits8::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision5 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision5::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision5::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision5,
                    Bits8,
                >(index);
                if relative_register_offset + Bits8::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits8,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits8::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision5 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision5,
                    Bits8,
                >(index);
                if relative_register_offset + Bits8::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits8,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits8,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_6")]
        impl PackedArrayRegister<Bits1> for Precision6 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 6) * 1, 64) },
            >;
        }
        #[cfg(feature = "precision_6")]
        impl Registers<Precision6, Bits1>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 6) * 1, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision6, Bits1>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision6, Bits1>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 6) * 1, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision6 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision6::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits1::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits1,
                            2,
                        >(words, word_offset);
                        word_offset += Bits1::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits1,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits1::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision6 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision6::NUMBER_OF_REGISTERS {
                    if register_offset + Bits1::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits1,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits1::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits1::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision6 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision6::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision6::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision6,
                    Bits1,
                >(index);
                if relative_register_offset + Bits1::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits1,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits1::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision6 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision6,
                    Bits1,
                >(index);
                if relative_register_offset + Bits1::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits1,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits1,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_6")]
        impl PackedArrayRegister<Bits2> for Precision6 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 6) * 2, 64) },
            >;
        }
        #[cfg(feature = "precision_6")]
        impl Registers<Precision6, Bits2>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 6) * 2, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision6, Bits2>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision6, Bits2>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 6) * 2, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision6 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision6::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits2::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits2,
                            2,
                        >(words, word_offset);
                        word_offset += Bits2::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits2,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits2::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision6 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision6::NUMBER_OF_REGISTERS {
                    if register_offset + Bits2::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits2,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits2::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits2::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision6 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision6::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision6::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision6,
                    Bits2,
                >(index);
                if relative_register_offset + Bits2::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits2,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits2::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision6 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision6,
                    Bits2,
                >(index);
                if relative_register_offset + Bits2::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits2,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits2,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_6")]
        impl PackedArrayRegister<Bits3> for Precision6 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 6) * 3, 64) },
            >;
        }
        #[cfg(feature = "precision_6")]
        impl Registers<Precision6, Bits3>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 6) * 3, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision6, Bits3>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision6, Bits3>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 6) * 3, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision6 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision6::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits3::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits3,
                            2,
                        >(words, word_offset);
                        word_offset += Bits3::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits3,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits3::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision6 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision6::NUMBER_OF_REGISTERS {
                    if register_offset + Bits3::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits3,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits3::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits3::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision6 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision6::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision6::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision6,
                    Bits3,
                >(index);
                if relative_register_offset + Bits3::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits3,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits3::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision6 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision6,
                    Bits3,
                >(index);
                if relative_register_offset + Bits3::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits3,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits3,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_6")]
        impl PackedArrayRegister<Bits4> for Precision6 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 6) * 4, 64) },
            >;
        }
        #[cfg(feature = "precision_6")]
        impl Registers<Precision6, Bits4>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 6) * 4, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision6, Bits4>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision6, Bits4>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 6) * 4, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision6 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision6::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits4::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits4,
                            2,
                        >(words, word_offset);
                        word_offset += Bits4::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits4,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits4::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision6 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision6::NUMBER_OF_REGISTERS {
                    if register_offset + Bits4::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits4,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits4::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits4::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision6 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision6::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision6::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision6,
                    Bits4,
                >(index);
                if relative_register_offset + Bits4::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits4,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits4::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision6 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision6,
                    Bits4,
                >(index);
                if relative_register_offset + Bits4::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits4,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits4,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_6")]
        impl PackedArrayRegister<Bits5> for Precision6 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 6) * 5, 64) },
            >;
        }
        #[cfg(feature = "precision_6")]
        impl Registers<Precision6, Bits5>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 6) * 5, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision6, Bits5>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision6, Bits5>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 6) * 5, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision6 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision6::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits5::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits5,
                            2,
                        >(words, word_offset);
                        word_offset += Bits5::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits5,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits5::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision6 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision6::NUMBER_OF_REGISTERS {
                    if register_offset + Bits5::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits5,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits5::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits5::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision6 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision6::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision6::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision6,
                    Bits5,
                >(index);
                if relative_register_offset + Bits5::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits5,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits5::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision6 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision6,
                    Bits5,
                >(index);
                if relative_register_offset + Bits5::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits5,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits5,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_6")]
        impl PackedArrayRegister<Bits6> for Precision6 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 6) * 6, 64) },
            >;
        }
        #[cfg(feature = "precision_6")]
        impl Registers<Precision6, Bits6>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 6) * 6, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision6, Bits6>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision6, Bits6>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 6) * 6, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision6 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision6::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits6::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits6,
                            2,
                        >(words, word_offset);
                        word_offset += Bits6::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits6,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits6::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision6 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision6::NUMBER_OF_REGISTERS {
                    if register_offset + Bits6::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits6,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits6::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits6::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision6 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision6::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision6::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision6,
                    Bits6,
                >(index);
                if relative_register_offset + Bits6::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits6,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits6::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision6 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision6,
                    Bits6,
                >(index);
                if relative_register_offset + Bits6::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits6,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits6,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_6")]
        impl PackedArrayRegister<Bits7> for Precision6 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 6) * 7, 64) },
            >;
        }
        #[cfg(feature = "precision_6")]
        impl Registers<Precision6, Bits7>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 6) * 7, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision6, Bits7>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision6, Bits7>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 6) * 7, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision6 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision6::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits7::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits7,
                            2,
                        >(words, word_offset);
                        word_offset += Bits7::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits7,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits7::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision6 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision6::NUMBER_OF_REGISTERS {
                    if register_offset + Bits7::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits7,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits7::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits7::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision6 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision6::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision6::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision6,
                    Bits7,
                >(index);
                if relative_register_offset + Bits7::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits7,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits7::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision6 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision6,
                    Bits7,
                >(index);
                if relative_register_offset + Bits7::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits7,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits7,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_6")]
        impl PackedArrayRegister<Bits8> for Precision6 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 6) * 8, 64) },
            >;
        }
        #[cfg(feature = "precision_6")]
        impl Registers<Precision6, Bits8>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 6) * 8, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision6, Bits8>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision6, Bits8>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 6) * 8, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision6 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision6 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision6::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits8::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits8,
                            2,
                        >(words, word_offset);
                        word_offset += Bits8::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits8,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits8::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision6 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision6::NUMBER_OF_REGISTERS {
                    if register_offset + Bits8::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits8,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits8::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits8::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision6 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision6::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision6::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision6,
                    Bits8,
                >(index);
                if relative_register_offset + Bits8::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits8,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits8::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision6 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision6,
                    Bits8,
                >(index);
                if relative_register_offset + Bits8::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits8,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits8,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_7")]
        impl PackedArrayRegister<Bits1> for Precision7 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 7) * 1, 64) },
            >;
        }
        #[cfg(feature = "precision_7")]
        impl Registers<Precision7, Bits1>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 7) * 1, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision7, Bits1>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision7, Bits1>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 7) * 1, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision7 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision7::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits1::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits1,
                            2,
                        >(words, word_offset);
                        word_offset += Bits1::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits1,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits1::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision7 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision7::NUMBER_OF_REGISTERS {
                    if register_offset + Bits1::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits1,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits1::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits1::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision7 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision7::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision7::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision7,
                    Bits1,
                >(index);
                if relative_register_offset + Bits1::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits1,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits1::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision7 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision7,
                    Bits1,
                >(index);
                if relative_register_offset + Bits1::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits1,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits1,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_7")]
        impl PackedArrayRegister<Bits2> for Precision7 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 7) * 2, 64) },
            >;
        }
        #[cfg(feature = "precision_7")]
        impl Registers<Precision7, Bits2>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 7) * 2, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision7, Bits2>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision7, Bits2>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 7) * 2, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision7 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision7::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits2::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits2,
                            2,
                        >(words, word_offset);
                        word_offset += Bits2::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits2,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits2::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision7 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision7::NUMBER_OF_REGISTERS {
                    if register_offset + Bits2::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits2,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits2::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits2::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision7 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision7::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision7::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision7,
                    Bits2,
                >(index);
                if relative_register_offset + Bits2::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits2,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits2::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision7 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision7,
                    Bits2,
                >(index);
                if relative_register_offset + Bits2::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits2,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits2,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_7")]
        impl PackedArrayRegister<Bits3> for Precision7 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 7) * 3, 64) },
            >;
        }
        #[cfg(feature = "precision_7")]
        impl Registers<Precision7, Bits3>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 7) * 3, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision7, Bits3>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision7, Bits3>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 7) * 3, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision7 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision7::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits3::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits3,
                            2,
                        >(words, word_offset);
                        word_offset += Bits3::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits3,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits3::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision7 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision7::NUMBER_OF_REGISTERS {
                    if register_offset + Bits3::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits3,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits3::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits3::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision7 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision7::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision7::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision7,
                    Bits3,
                >(index);
                if relative_register_offset + Bits3::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits3,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits3::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision7 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision7,
                    Bits3,
                >(index);
                if relative_register_offset + Bits3::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits3,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits3,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_7")]
        impl PackedArrayRegister<Bits4> for Precision7 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 7) * 4, 64) },
            >;
        }
        #[cfg(feature = "precision_7")]
        impl Registers<Precision7, Bits4>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 7) * 4, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision7, Bits4>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision7, Bits4>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 7) * 4, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision7 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision7::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits4::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits4,
                            2,
                        >(words, word_offset);
                        word_offset += Bits4::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits4,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits4::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision7 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision7::NUMBER_OF_REGISTERS {
                    if register_offset + Bits4::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits4,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits4::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits4::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision7 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision7::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision7::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision7,
                    Bits4,
                >(index);
                if relative_register_offset + Bits4::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits4,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits4::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision7 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision7,
                    Bits4,
                >(index);
                if relative_register_offset + Bits4::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits4,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits4,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_7")]
        impl PackedArrayRegister<Bits5> for Precision7 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 7) * 5, 64) },
            >;
        }
        #[cfg(feature = "precision_7")]
        impl Registers<Precision7, Bits5>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 7) * 5, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision7, Bits5>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision7, Bits5>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 7) * 5, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision7 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision7::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits5::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits5,
                            2,
                        >(words, word_offset);
                        word_offset += Bits5::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits5,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits5::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision7 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision7::NUMBER_OF_REGISTERS {
                    if register_offset + Bits5::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits5,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits5::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits5::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision7 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision7::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision7::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision7,
                    Bits5,
                >(index);
                if relative_register_offset + Bits5::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits5,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits5::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision7 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision7,
                    Bits5,
                >(index);
                if relative_register_offset + Bits5::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits5,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits5,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_7")]
        impl PackedArrayRegister<Bits6> for Precision7 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 7) * 6, 64) },
            >;
        }
        #[cfg(feature = "precision_7")]
        impl Registers<Precision7, Bits6>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 7) * 6, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision7, Bits6>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision7, Bits6>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 7) * 6, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision7 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision7::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits6::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits6,
                            2,
                        >(words, word_offset);
                        word_offset += Bits6::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits6,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits6::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision7 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision7::NUMBER_OF_REGISTERS {
                    if register_offset + Bits6::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits6,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits6::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits6::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision7 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision7::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision7::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision7,
                    Bits6,
                >(index);
                if relative_register_offset + Bits6::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits6,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits6::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision7 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision7,
                    Bits6,
                >(index);
                if relative_register_offset + Bits6::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits6,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits6,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_7")]
        impl PackedArrayRegister<Bits7> for Precision7 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 7) * 7, 64) },
            >;
        }
        #[cfg(feature = "precision_7")]
        impl Registers<Precision7, Bits7>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 7) * 7, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision7, Bits7>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision7, Bits7>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 7) * 7, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision7 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision7::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits7::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits7,
                            2,
                        >(words, word_offset);
                        word_offset += Bits7::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits7,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits7::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision7 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision7::NUMBER_OF_REGISTERS {
                    if register_offset + Bits7::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits7,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits7::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits7::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision7 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision7::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision7::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision7,
                    Bits7,
                >(index);
                if relative_register_offset + Bits7::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits7,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits7::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision7 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision7,
                    Bits7,
                >(index);
                if relative_register_offset + Bits7::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits7,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits7,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_7")]
        impl PackedArrayRegister<Bits8> for Precision7 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 7) * 8, 64) },
            >;
        }
        #[cfg(feature = "precision_7")]
        impl Registers<Precision7, Bits8>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 7) * 8, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision7, Bits8>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision7, Bits8>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 7) * 8, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision7 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision7 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision7::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits8::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits8,
                            2,
                        >(words, word_offset);
                        word_offset += Bits8::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits8,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits8::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision7 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision7::NUMBER_OF_REGISTERS {
                    if register_offset + Bits8::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits8,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits8::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits8::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision7 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision7::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision7::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision7,
                    Bits8,
                >(index);
                if relative_register_offset + Bits8::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits8,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits8::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision7 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision7,
                    Bits8,
                >(index);
                if relative_register_offset + Bits8::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits8,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits8,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_8")]
        impl PackedArrayRegister<Bits1> for Precision8 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 8) * 1, 64) },
            >;
        }
        #[cfg(feature = "precision_8")]
        impl Registers<Precision8, Bits1>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 8) * 1, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision8, Bits1>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision8, Bits1>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 8) * 1, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision8 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision8::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits1::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits1,
                            2,
                        >(words, word_offset);
                        word_offset += Bits1::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits1,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits1::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision8 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision8::NUMBER_OF_REGISTERS {
                    if register_offset + Bits1::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits1,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits1::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits1::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision8 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision8::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision8::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision8,
                    Bits1,
                >(index);
                if relative_register_offset + Bits1::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits1,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits1::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision8 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision8,
                    Bits1,
                >(index);
                if relative_register_offset + Bits1::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits1,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits1,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_8")]
        impl PackedArrayRegister<Bits2> for Precision8 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 8) * 2, 64) },
            >;
        }
        #[cfg(feature = "precision_8")]
        impl Registers<Precision8, Bits2>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 8) * 2, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision8, Bits2>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision8, Bits2>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 8) * 2, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision8 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision8::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits2::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits2,
                            2,
                        >(words, word_offset);
                        word_offset += Bits2::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits2,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits2::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision8 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision8::NUMBER_OF_REGISTERS {
                    if register_offset + Bits2::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits2,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits2::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits2::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision8 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision8::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision8::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision8,
                    Bits2,
                >(index);
                if relative_register_offset + Bits2::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits2,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits2::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision8 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision8,
                    Bits2,
                >(index);
                if relative_register_offset + Bits2::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits2,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits2,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_8")]
        impl PackedArrayRegister<Bits3> for Precision8 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 8) * 3, 64) },
            >;
        }
        #[cfg(feature = "precision_8")]
        impl Registers<Precision8, Bits3>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 8) * 3, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision8, Bits3>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision8, Bits3>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 8) * 3, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision8 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision8::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits3::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits3,
                            2,
                        >(words, word_offset);
                        word_offset += Bits3::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits3,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits3::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision8 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision8::NUMBER_OF_REGISTERS {
                    if register_offset + Bits3::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits3,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits3::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits3::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision8 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision8::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision8::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision8,
                    Bits3,
                >(index);
                if relative_register_offset + Bits3::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits3,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits3::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision8 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision8,
                    Bits3,
                >(index);
                if relative_register_offset + Bits3::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits3,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits3,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_8")]
        impl PackedArrayRegister<Bits4> for Precision8 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 8) * 4, 64) },
            >;
        }
        #[cfg(feature = "precision_8")]
        impl Registers<Precision8, Bits4>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 8) * 4, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision8, Bits4>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision8, Bits4>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 8) * 4, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision8 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision8::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits4::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits4,
                            2,
                        >(words, word_offset);
                        word_offset += Bits4::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits4,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits4::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision8 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision8::NUMBER_OF_REGISTERS {
                    if register_offset + Bits4::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits4,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits4::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits4::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision8 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision8::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision8::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision8,
                    Bits4,
                >(index);
                if relative_register_offset + Bits4::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits4,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits4::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision8 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision8,
                    Bits4,
                >(index);
                if relative_register_offset + Bits4::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits4,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits4,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_8")]
        impl PackedArrayRegister<Bits5> for Precision8 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 8) * 5, 64) },
            >;
        }
        #[cfg(feature = "precision_8")]
        impl Registers<Precision8, Bits5>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 8) * 5, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision8, Bits5>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision8, Bits5>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 8) * 5, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision8 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision8::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits5::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits5,
                            2,
                        >(words, word_offset);
                        word_offset += Bits5::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits5,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits5::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision8 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision8::NUMBER_OF_REGISTERS {
                    if register_offset + Bits5::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits5,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits5::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits5::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision8 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision8::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision8::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision8,
                    Bits5,
                >(index);
                if relative_register_offset + Bits5::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits5,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits5::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision8 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision8,
                    Bits5,
                >(index);
                if relative_register_offset + Bits5::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits5,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits5,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_8")]
        impl PackedArrayRegister<Bits6> for Precision8 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 8) * 6, 64) },
            >;
        }
        #[cfg(feature = "precision_8")]
        impl Registers<Precision8, Bits6>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 8) * 6, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision8, Bits6>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision8, Bits6>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 8) * 6, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision8 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision8::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits6::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits6,
                            2,
                        >(words, word_offset);
                        word_offset += Bits6::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits6,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits6::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision8 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision8::NUMBER_OF_REGISTERS {
                    if register_offset + Bits6::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits6,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits6::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits6::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision8 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision8::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision8::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision8,
                    Bits6,
                >(index);
                if relative_register_offset + Bits6::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits6,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits6::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision8 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision8,
                    Bits6,
                >(index);
                if relative_register_offset + Bits6::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits6,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits6,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_8")]
        impl PackedArrayRegister<Bits7> for Precision8 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 8) * 7, 64) },
            >;
        }
        #[cfg(feature = "precision_8")]
        impl Registers<Precision8, Bits7>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 8) * 7, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision8, Bits7>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision8, Bits7>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 8) * 7, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision8 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision8::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits7::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits7,
                            2,
                        >(words, word_offset);
                        word_offset += Bits7::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits7,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits7::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision8 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision8::NUMBER_OF_REGISTERS {
                    if register_offset + Bits7::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits7,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits7::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits7::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision8 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision8::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision8::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision8,
                    Bits7,
                >(index);
                if relative_register_offset + Bits7::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits7,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits7::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision8 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision8,
                    Bits7,
                >(index);
                if relative_register_offset + Bits7::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits7,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits7,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_8")]
        impl PackedArrayRegister<Bits8> for Precision8 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 8) * 8, 64) },
            >;
        }
        #[cfg(feature = "precision_8")]
        impl Registers<Precision8, Bits8>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 8) * 8, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision8, Bits8>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision8, Bits8>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 8) * 8, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision8 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision8 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision8::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits8::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits8,
                            2,
                        >(words, word_offset);
                        word_offset += Bits8::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits8,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits8::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision8 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision8::NUMBER_OF_REGISTERS {
                    if register_offset + Bits8::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits8,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits8::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits8::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision8 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision8::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision8::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision8,
                    Bits8,
                >(index);
                if relative_register_offset + Bits8::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits8,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits8::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision8 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision8,
                    Bits8,
                >(index);
                if relative_register_offset + Bits8::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits8,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits8,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_9")]
        impl PackedArrayRegister<Bits1> for Precision9 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 9) * 1, 64) },
            >;
        }
        #[cfg(feature = "precision_9")]
        impl Registers<Precision9, Bits1>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 9) * 1, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision9, Bits1>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision9, Bits1>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 9) * 1, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision9 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision9::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits1::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits1,
                            2,
                        >(words, word_offset);
                        word_offset += Bits1::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits1,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits1::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision9 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision9::NUMBER_OF_REGISTERS {
                    if register_offset + Bits1::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits1,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits1::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits1::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision9 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision9::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision9::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision9,
                    Bits1,
                >(index);
                if relative_register_offset + Bits1::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits1,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits1::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision9 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision9,
                    Bits1,
                >(index);
                if relative_register_offset + Bits1::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits1,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits1,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_9")]
        impl PackedArrayRegister<Bits2> for Precision9 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 9) * 2, 64) },
            >;
        }
        #[cfg(feature = "precision_9")]
        impl Registers<Precision9, Bits2>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 9) * 2, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision9, Bits2>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision9, Bits2>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 9) * 2, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision9 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision9::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits2::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits2,
                            2,
                        >(words, word_offset);
                        word_offset += Bits2::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits2,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits2::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision9 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision9::NUMBER_OF_REGISTERS {
                    if register_offset + Bits2::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits2,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits2::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits2::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision9 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision9::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision9::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision9,
                    Bits2,
                >(index);
                if relative_register_offset + Bits2::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits2,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits2::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision9 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision9,
                    Bits2,
                >(index);
                if relative_register_offset + Bits2::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits2,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits2,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_9")]
        impl PackedArrayRegister<Bits3> for Precision9 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 9) * 3, 64) },
            >;
        }
        #[cfg(feature = "precision_9")]
        impl Registers<Precision9, Bits3>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 9) * 3, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision9, Bits3>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision9, Bits3>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 9) * 3, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision9 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision9::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits3::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits3,
                            2,
                        >(words, word_offset);
                        word_offset += Bits3::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits3,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits3::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision9 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision9::NUMBER_OF_REGISTERS {
                    if register_offset + Bits3::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits3,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits3::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits3::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision9 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision9::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision9::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision9,
                    Bits3,
                >(index);
                if relative_register_offset + Bits3::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits3,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits3::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision9 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision9,
                    Bits3,
                >(index);
                if relative_register_offset + Bits3::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits3,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits3,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_9")]
        impl PackedArrayRegister<Bits4> for Precision9 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 9) * 4, 64) },
            >;
        }
        #[cfg(feature = "precision_9")]
        impl Registers<Precision9, Bits4>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 9) * 4, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision9, Bits4>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision9, Bits4>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 9) * 4, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision9 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision9::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits4::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits4,
                            2,
                        >(words, word_offset);
                        word_offset += Bits4::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits4,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits4::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision9 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision9::NUMBER_OF_REGISTERS {
                    if register_offset + Bits4::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits4,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits4::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits4::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision9 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision9::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision9::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision9,
                    Bits4,
                >(index);
                if relative_register_offset + Bits4::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits4,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits4::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision9 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision9,
                    Bits4,
                >(index);
                if relative_register_offset + Bits4::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits4,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits4,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_9")]
        impl PackedArrayRegister<Bits5> for Precision9 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 9) * 5, 64) },
            >;
        }
        #[cfg(feature = "precision_9")]
        impl Registers<Precision9, Bits5>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 9) * 5, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision9, Bits5>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision9, Bits5>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 9) * 5, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision9 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision9::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits5::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits5,
                            2,
                        >(words, word_offset);
                        word_offset += Bits5::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits5,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits5::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision9 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision9::NUMBER_OF_REGISTERS {
                    if register_offset + Bits5::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits5,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits5::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits5::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision9 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision9::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision9::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision9,
                    Bits5,
                >(index);
                if relative_register_offset + Bits5::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits5,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits5::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision9 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision9,
                    Bits5,
                >(index);
                if relative_register_offset + Bits5::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits5,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits5,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_9")]
        impl PackedArrayRegister<Bits6> for Precision9 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 9) * 6, 64) },
            >;
        }
        #[cfg(feature = "precision_9")]
        impl Registers<Precision9, Bits6>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 9) * 6, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision9, Bits6>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision9, Bits6>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 9) * 6, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision9 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision9::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits6::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits6,
                            2,
                        >(words, word_offset);
                        word_offset += Bits6::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits6,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits6::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision9 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision9::NUMBER_OF_REGISTERS {
                    if register_offset + Bits6::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits6,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits6::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits6::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision9 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision9::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision9::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision9,
                    Bits6,
                >(index);
                if relative_register_offset + Bits6::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits6,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits6::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision9 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision9,
                    Bits6,
                >(index);
                if relative_register_offset + Bits6::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits6,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits6,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_9")]
        impl PackedArrayRegister<Bits7> for Precision9 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 9) * 7, 64) },
            >;
        }
        #[cfg(feature = "precision_9")]
        impl Registers<Precision9, Bits7>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 9) * 7, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision9, Bits7>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision9, Bits7>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 9) * 7, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision9 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision9::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits7::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits7,
                            2,
                        >(words, word_offset);
                        word_offset += Bits7::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits7,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits7::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision9 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision9::NUMBER_OF_REGISTERS {
                    if register_offset + Bits7::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits7,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits7::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits7::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision9 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision9::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision9::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision9,
                    Bits7,
                >(index);
                if relative_register_offset + Bits7::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits7,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits7::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision9 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision9,
                    Bits7,
                >(index);
                if relative_register_offset + Bits7::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits7,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits7,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_9")]
        impl PackedArrayRegister<Bits8> for Precision9 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 9) * 8, 64) },
            >;
        }
        #[cfg(feature = "precision_9")]
        impl Registers<Precision9, Bits8>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 9) * 8, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision9, Bits8>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision9, Bits8>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 9) * 8, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision9 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision9 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision9::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits8::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits8,
                            2,
                        >(words, word_offset);
                        word_offset += Bits8::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits8,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits8::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision9 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision9::NUMBER_OF_REGISTERS {
                    if register_offset + Bits8::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits8,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits8::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits8::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision9 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision9::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision9::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision9,
                    Bits8,
                >(index);
                if relative_register_offset + Bits8::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits8,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits8::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision9 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision9,
                    Bits8,
                >(index);
                if relative_register_offset + Bits8::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits8,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits8,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_10")]
        impl PackedArrayRegister<Bits1> for Precision10 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 10) * 1, 64) },
            >;
        }
        #[cfg(feature = "precision_10")]
        impl Registers<Precision10, Bits1>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 10) * 1, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision10, Bits1>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision10, Bits1>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 10) * 1, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision10 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision10::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits1::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits1,
                            2,
                        >(words, word_offset);
                        word_offset += Bits1::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits1,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits1::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision10 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision10::NUMBER_OF_REGISTERS {
                    if register_offset + Bits1::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits1,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits1::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits1::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision10 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision10::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision10::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision10,
                    Bits1,
                >(index);
                if relative_register_offset + Bits1::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits1,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits1::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits1>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision10 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision10,
                    Bits1,
                >(index);
                if relative_register_offset + Bits1::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits1,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits1,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_10")]
        impl PackedArrayRegister<Bits2> for Precision10 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 10) * 2, 64) },
            >;
        }
        #[cfg(feature = "precision_10")]
        impl Registers<Precision10, Bits2>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 10) * 2, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision10, Bits2>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision10, Bits2>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 10) * 2, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision10 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision10::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits2::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits2,
                            2,
                        >(words, word_offset);
                        word_offset += Bits2::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits2,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits2::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision10 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision10::NUMBER_OF_REGISTERS {
                    if register_offset + Bits2::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits2,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits2::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits2::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision10 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision10::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision10::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision10,
                    Bits2,
                >(index);
                if relative_register_offset + Bits2::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits2,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits2::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits2>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision10 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision10,
                    Bits2,
                >(index);
                if relative_register_offset + Bits2::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits2,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits2,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_10")]
        impl PackedArrayRegister<Bits3> for Precision10 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 10) * 3, 64) },
            >;
        }
        #[cfg(feature = "precision_10")]
        impl Registers<Precision10, Bits3>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 10) * 3, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision10, Bits3>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision10, Bits3>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 10) * 3, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision10 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision10::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits3::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits3,
                            2,
                        >(words, word_offset);
                        word_offset += Bits3::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits3,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits3::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision10 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision10::NUMBER_OF_REGISTERS {
                    if register_offset + Bits3::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits3,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits3::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits3::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision10 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision10::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision10::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision10,
                    Bits3,
                >(index);
                if relative_register_offset + Bits3::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits3,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits3::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits3>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision10 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision10,
                    Bits3,
                >(index);
                if relative_register_offset + Bits3::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits3,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits3,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_10")]
        impl PackedArrayRegister<Bits4> for Precision10 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 10) * 4, 64) },
            >;
        }
        #[cfg(feature = "precision_10")]
        impl Registers<Precision10, Bits4>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 10) * 4, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision10, Bits4>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision10, Bits4>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 10) * 4, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision10 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision10::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits4::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits4,
                            2,
                        >(words, word_offset);
                        word_offset += Bits4::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits4,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits4::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision10 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision10::NUMBER_OF_REGISTERS {
                    if register_offset + Bits4::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits4,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits4::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits4::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision10 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision10::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision10::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision10,
                    Bits4,
                >(index);
                if relative_register_offset + Bits4::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits4,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits4::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits4>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision10 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision10,
                    Bits4,
                >(index);
                if relative_register_offset + Bits4::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits4,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits4,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_10")]
        impl PackedArrayRegister<Bits5> for Precision10 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 10) * 5, 64) },
            >;
        }
        #[cfg(feature = "precision_10")]
        impl Registers<Precision10, Bits5>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 10) * 5, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision10, Bits5>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision10, Bits5>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 10) * 5, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision10 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision10::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits5::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits5,
                            2,
                        >(words, word_offset);
                        word_offset += Bits5::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits5,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits5::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision10 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision10::NUMBER_OF_REGISTERS {
                    if register_offset + Bits5::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits5,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits5::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits5::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision10 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision10::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision10::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision10,
                    Bits5,
                >(index);
                if relative_register_offset + Bits5::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits5,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits5::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits5>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision10 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision10,
                    Bits5,
                >(index);
                if relative_register_offset + Bits5::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits5,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits5,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_10")]
        impl PackedArrayRegister<Bits6> for Precision10 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 10) * 6, 64) },
            >;
        }
        #[cfg(feature = "precision_10")]
        impl Registers<Precision10, Bits6>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 10) * 6, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision10, Bits6>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision10, Bits6>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 10) * 6, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision10 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision10::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits6::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits6,
                            2,
                        >(words, word_offset);
                        word_offset += Bits6::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits6,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits6::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision10 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision10::NUMBER_OF_REGISTERS {
                    if register_offset + Bits6::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits6,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits6::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits6::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision10 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision10::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision10::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision10,
                    Bits6,
                >(index);
                if relative_register_offset + Bits6::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits6,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits6::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits6>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision10 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision10,
                    Bits6,
                >(index);
                if relative_register_offset + Bits6::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits6,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits6,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_10")]
        impl PackedArrayRegister<Bits7> for Precision10 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 10) * 7, 64) },
            >;
        }
        #[cfg(feature = "precision_10")]
        impl Registers<Precision10, Bits7>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 10) * 7, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision10, Bits7>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision10, Bits7>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 10) * 7, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision10 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision10::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits7::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits7,
                            2,
                        >(words, word_offset);
                        word_offset += Bits7::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits7,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits7::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision10 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision10::NUMBER_OF_REGISTERS {
                    if register_offset + Bits7::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits7,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits7::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits7::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision10 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision10::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision10::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision10,
                    Bits7,
                >(index);
                if relative_register_offset + Bits7::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits7,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits7::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits7>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision10 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision10,
                    Bits7,
                >(index);
                if relative_register_offset + Bits7::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits7,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits7,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
        #[cfg(feature = "precision_10")]
        impl PackedArrayRegister<Bits8> for Precision10 {
            type PackedArrayRegister = PackedArray<
                { crate::utils::ceil(usize::pow(2, 10) * 8, 64) },
            >;
        }
        #[cfg(feature = "precision_10")]
        impl Registers<Precision10, Bits8>
        for PackedArray<{ crate::utils::ceil(usize::pow(2, 10) * 8, 64) }> {
            type Iter<'words> = RegisterIter<'words, Precision10, Bits8>;
            type IterZipped<'words> = RegisterTupleIter<'words, Precision10, Bits8>
            where
                Self: 'words;
            #[inline]
            fn zeroed() -> Self {
                PackedArray {
                    words: [0; crate::utils::ceil(usize::pow(2, 10) * 8, 64)],
                }
            }
            #[inline]
            fn iter_registers(&self) -> Self::Iter<'_> {
                RegisterIter::new(self.words.iter())
            }
            #[inline]
            fn iter_registers_zipped<'words>(
                &'words self,
                other: &'words Self,
            ) -> Self::IterZipped<'words> {
                RegisterTupleIter::new(self.words.iter(), other.words.iter())
            }
            #[inline]
            fn get_harmonic_sum_and_zeros(
                &self,
                other: &Self,
            ) -> (f64, <Precision10 as Precision>::NumberOfRegisters) {
                let mut harmonic_sum = f64::ZERO;
                let mut union_zeros = <Precision10 as Precision>::NumberOfRegisters::ZERO;
                let mut word_offset = 0;
                let mut word_index = 0;
                let mut number_of_registers = 0;
                let mut words = [self.words[word_index], other.words[word_index]];
                while number_of_registers < Precision10::NUMBER_OF_REGISTERS {
                    let [left_register, right_register] = if word_offset
                        + Bits8::NUMBER_OF_BITS <= 64
                    {
                        let registers = extract_register_from_word::<
                            Bits8,
                            2,
                        >(words, word_offset);
                        word_offset += Bits8::NUMBER_OF_BITS;
                        registers
                    } else {
                        let old_words = words;
                        words = [
                            self.words[word_index + 1],
                            other.words[word_index + 1],
                        ];
                        let registers = extract_bridge_register_from_word::<
                            Bits8,
                            2,
                        >(old_words, words, word_offset);
                        word_offset = word_offset + Bits8::NUMBER_OF_BITS - 64;
                        word_index += 1;
                        registers
                    };
                    number_of_registers += 1;
                    let max_register = core::cmp::max(left_register, right_register);
                    harmonic_sum += f64::integer_exp2_minus(max_register);
                    union_zeros
                        += <Precision10 as Precision>::NumberOfRegisters::from_bool(
                            max_register.is_zero(),
                        );
                }
                (harmonic_sum, union_zeros)
            }
            #[inline]
            fn apply<F>(&mut self, mut register_function: F)
            where
                F: FnMut(u8) -> u8,
            {
                let mut number_of_registers = 0;
                let mut register_offset = 0;
                let mut word_index = 0;
                while number_of_registers < Precision10::NUMBER_OF_REGISTERS {
                    if register_offset + Bits8::NUMBER_OF_BITS <= 64 {
                        let [register] = extract_register_from_word::<
                            Bits8,
                            1,
                        >([self.words[word_index]], register_offset);
                        let new_register = register_function(
                            u8::try_from(register).unwrap(),
                        );
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        register_offset += Bits8::NUMBER_OF_BITS;
                        number_of_registers += 1;
                    } else {
                        let number_of_bits_in_lower_register = 64 - register_offset;
                        let number_of_bits_in_upper_register = Bits8::NUMBER_OF_BITS
                            - number_of_bits_in_lower_register;
                        let upper_register_mask = (1 << number_of_bits_in_upper_register)
                            - 1;
                        let lower_register = self.words[word_index] >> register_offset;
                        let upper_register = self.words[word_index + 1]
                            & upper_register_mask;
                        let register = u8::try_from(
                                (upper_register << number_of_bits_in_lower_register)
                                    | lower_register,
                            )
                            .unwrap();
                        let new_register = register_function(register);
                        self.words[word_index]
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            ) << register_offset);
                        self.words[word_index]
                            |= u64::from(new_register) << register_offset;
                        self.words[word_index + 1] &= !upper_register_mask;
                        self.words[word_index + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        register_offset = number_of_bits_in_upper_register;
                        number_of_registers += 1;
                        word_index += 1;
                    }
                }
            }
            #[inline(always)]
            fn set_greater(
                &mut self,
                index: <Precision10 as Precision>::NumberOfRegisters,
                new_register: u8,
            ) -> (u8, u8) {
                if true {
                    if !(index < Precision10::NUMBER_OF_REGISTERS) {
                        ::core::panicking::panic(
                            "assertion failed: index < Precision10::NUMBER_OF_REGISTERS",
                        )
                    }
                }
                if true {
                    if !(new_register
                        <= u8::try_from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            )
                            .unwrap())
                    {
                        ::core::panicking::panic(
                            "assertion failed: new_register <=\n    u8::try_from(<u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK).unwrap()",
                        )
                    }
                }
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision10,
                    Bits8,
                >(index);
                if relative_register_offset + Bits8::NUMBER_OF_BITS <= 64 {
                    let word = &mut self.words[word_position];
                    let [old_register] = extract_register_from_word::<
                        Bits8,
                        1,
                    >([*word], relative_register_offset);
                    if new_register > old_register {
                        *word
                            &= !(u64::from(
                                <u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK,
                            ) << relative_register_offset);
                        *word |= u64::from(new_register) << relative_register_offset;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                } else {
                    let number_of_bits_in_lower_register = 64 - relative_register_offset;
                    let number_of_bits_in_upper_register = Bits8::NUMBER_OF_BITS
                        - number_of_bits_in_lower_register;
                    let upper_register_mask = (1 << number_of_bits_in_upper_register)
                        - 1;
                    let lower_register = self.words[word_position]
                        >> relative_register_offset;
                    let upper_register = self.words[word_position + 1]
                        & upper_register_mask;
                    let old_register = u8::try_from(
                            (upper_register << number_of_bits_in_lower_register)
                                | lower_register,
                        )
                        .unwrap();
                    if new_register > old_register {
                        self.words[word_position]
                            &= !(<u64 as RegisterWord<Bits8>>::LOWER_REGISTER_MASK
                                << relative_register_offset);
                        self.words[word_position + 1] &= !upper_register_mask;
                        self.words[word_position]
                            |= u64::from(new_register) << relative_register_offset;
                        self.words[word_position + 1]
                            |= u64::from(new_register)
                                >> number_of_bits_in_lower_register;
                        (old_register, new_register)
                    } else {
                        (old_register, old_register)
                    }
                }
            }
            #[inline]
            /// Returns the value of the register at the given index in the packed array.
            fn get_register(
                &self,
                index: <Precision10 as Precision>::NumberOfRegisters,
            ) -> u8 {
                let (word_position, relative_register_offset) = split_packed_index::<
                    Precision10,
                    Bits8,
                >(index);
                if relative_register_offset + Bits8::NUMBER_OF_BITS <= 64 {
                    extract_register_from_word::<
                        Bits8,
                        1,
                    >([self.words[word_position]], relative_register_offset)[0]
                } else {
                    extract_bridge_register_from_word::<
                        Bits8,
                        1,
                    >(
                        [self.words[word_position]],
                        [self.words[word_position + 1]],
                        relative_register_offset,
                    )[0]
                }
            }
            #[inline]
            fn clear(&mut self) {
                for word in self.words.iter_mut() {
                    *word = 0;
                }
            }
        }
    }
    pub use array::{ArrayRegister, ArrayRegisters};
    pub use packed_array::{PackedArray, PackedArrayRegister, PackedArrayRegisters};
    /// Trait for a register word.
    pub(super) trait RegisterWord<B: Bits> {
        /// The mask for the lower register.
        const LOWER_REGISTER_MASK: Self;
        /// The number of bits in the word.
        const NUMBER_OF_BITS: u8;
        /// The number of registers in the word.
        const NUMBER_OF_REGISTERS_IN_WORD: u8 = Self::NUMBER_OF_BITS / B::NUMBER_OF_BITS;
    }
    impl<B: Bits> RegisterWord<B> for u64 {
        const LOWER_REGISTER_MASK: Self = (1 << B::NUMBER_OF_BITS) - 1;
        const NUMBER_OF_BITS: u8 = 64;
    }
    /// Extracts the register from one or more words at the given offset.
    ///
    /// # Arguments
    /// * `word` - The word array from which the register is to be extracted.
    /// * `offset` - The offset at which the register starts.
    fn extract_register_from_word<B: Bits, const N: usize>(
        word: [u64; N],
        offset: u8,
    ) -> [u8; N]
    where
        u64: RegisterWord<B>,
    {
        if true {
            if !(offset + B::NUMBER_OF_BITS <= u64::NUMBER_OF_BITS) {
                {
                    ::core::panicking::panic_fmt(
                        format_args!("The offset is too large."),
                    );
                }
            }
        }
        let mut registers = [0_u8; N];
        for i in 0..N {
            registers[i] = u8::try_from((word[i] >> offset) & u64::LOWER_REGISTER_MASK)
                .unwrap();
        }
        registers
    }
    /// Trait marker for the registers.
    pub trait Registers<
        P: Precision,
        B: Bits,
    >: Eq + PartialEq + Clone + Debug + Send + Sync {
        /// Iterator over the registers.
        type Iter<'register>: Iterator<Item = u8> where Self: 'register;
        /// Iterator over the registers zipped with another set of registers.
        type IterZipped<'registers>: Iterator<Item = (u8, u8)> where Self: 'registers;
        /// Returns an iterator over the registers.
        fn iter_registers(&self) -> Self::Iter<'_>;
        /// Returns an iterator over the registers zipped with another set of registers.
        fn iter_registers_zipped<'registers>(
            &'registers self,
            other: &'registers Self,
        ) -> Self::IterZipped<'registers>;
        /// Returns the harmonic sum of the maximum value of the registers and the number of zero registers.
        fn get_harmonic_sum_and_zeros(
            &self,
            other: &Self,
        ) -> (f64, P::NumberOfRegisters);
        /// Applies a function to each register.
        fn apply<F>(&mut self, f: F)
        where
            F: FnMut(u8) -> u8;
        /// Returns a new instance of the registers with all the values set to zero.
        fn zeroed() -> Self;
        /// Updates the register at the given index with the given value,
        /// if the value is greater than the current value in the register.
        ///
        /// # Arguments
        /// * `index` - The index of the register to be updated.
        /// * `value` - The value to be set in the register.
        ///
        /// # Returns
        /// The previous value of the register, and the larger of the two values.
        fn set_greater(&mut self, index: P::NumberOfRegisters, value: u8) -> (u8, u8);
        /// Returns the value of the register at the given index.
        fn get_register(&self, index: P::NumberOfRegisters) -> u8;
        /// Clears the registers to zero.
        fn clear(&mut self);
    }
}
pub mod sketches {
    //! Exact sketching algorithms.
    //!
    //! This submodule contains the implementation of the exact sketching algorithms
    //! as part of a trait.
    //!
    //! A sketch is a representation of the similarity between two list of sets.
    //!
    //! It is used in cases such as in graphs for representing the similarity between
    //! two nodes, de facto providing features that characterize a candidate edge
    //! between two nodes.
    //!
    //! While in the [`HyperLogLog`] case we provide the approximated version of this algorithm,
    //! sometimes it is necessary, such as in test cases, to have the exact version of the
    //! algorithm. The approximated version is faster and uses less memory, but it is not,
    //! of course, guaranteed to be exact.
    use crate::prelude::{Estimator, FloatOps, Number, Zero};
    /// Trait for sketching algorithms that provide the overlap and differences cardinality matrices.
    pub trait HyperSpheresSketch<N: Number>: Estimator<N> {
        #[inline]
        /// Returns the overlap and differences cardinality matrices of two lists of sets.
        ///
        /// # Arguments
        /// * `left` - The first list of sets.
        /// * `right` - The second list of sets.
        ///
        /// # Returns
        /// * `overlap_cardinality_matrix` - Matrix of estimated overlapping cardinalities between the elements of the left and right arrays.
        /// * `left_difference_cardinality_vector` - Vector of estimated difference cardinalities between the elements of the left array and the last element of the right array.
        /// * `right_difference_cardinality_vector` - Vector of estimated difference cardinalities between the elements of the right array and the last element of the left array.
        ///
        /// # Implementative details
        /// We expect the elements of the left and right arrays to be increasingly contained in the next one.
        ///
        /// # Examples
        /// In the following illustration, we show that for two vectors left and right of three elements,
        /// we expect to compute the exclusively overlap matrix $A_{ij}$ and the exclusively differences vectors $`B_i`$.
        ///
        /// ![Illustration of overlaps](https://github.com/LucaCappelletti94/hyperloglog-rs/blob/main/triple_overlap.png?raw=true)
        ///
        /// Very similarly, for the case of vectors of two elements:
        ///
        /// ![Illustration of overlaps](https://github.com/LucaCappelletti94/hyperloglog-rs/blob/main/tuple_overlap.png?raw=true)
        fn overlap_and_differences_cardinality_matrices<const L: usize, const R: usize>(
            lefts: &[Self; L],
            rights: &[Self; R],
        ) -> ([[N; R]; L], [N; L], [N; R]) {
            let mut last_row = [N::ZERO; R];
            let mut differential_overlap_cardinality_matrix = [[N::ZERO; R]; L];
            let mut left_difference_cardinality_vector = [N::ZERO; L];
            let mut right_cardinalities = [N::ZERO; R];
            rights
                .iter()
                .zip(right_cardinalities.iter_mut())
                .for_each(|(right, right_cardinality)| {
                    *right_cardinality = right.estimate_cardinality();
                });
            let mut right_difference_cardinality_vector = [N::ZERO; R];
            let mut euc: EstimatedUnionCardinalities<N> = EstimatedUnionCardinalities {
                left: N::ZERO,
                right: N::ZERO,
                union: N::ZERO,
            };
            let mut last_left_difference = N::ZERO;
            for (i, left) in lefts.iter().enumerate() {
                let mut last_right_difference = N::ZERO;
                let left_cardinality = left.estimate_cardinality();
                let mut comulative_row = N::ZERO;
                for (j, (right, right_cardinality)) in rights
                    .iter()
                    .zip(right_cardinalities)
                    .enumerate()
                {
                    let union_cardinality = left.estimate_union_cardinality(right);
                    euc = EstimatedUnionCardinalities {
                        left: left_cardinality,
                        right: right_cardinality,
                        union: union_cardinality,
                    };
                    let delta = last_row[j] + comulative_row;
                    differential_overlap_cardinality_matrix[i][j] = euc
                        .get_intersection_cardinality()
                        .saturating_zero_sub(delta);
                    last_row[j] = if euc.get_intersection_cardinality() > delta {
                        euc.get_intersection_cardinality()
                    } else {
                        delta
                    };
                    comulative_row += differential_overlap_cardinality_matrix[i][j];
                    right_difference_cardinality_vector[j] = euc
                        .get_right_difference_cardinality()
                        .saturating_zero_sub(last_right_difference);
                    last_right_difference = euc.get_right_difference_cardinality();
                }
                left_difference_cardinality_vector[i] = euc
                    .get_left_difference_cardinality()
                    .saturating_zero_sub(last_left_difference);
                last_left_difference = euc.get_left_difference_cardinality();
            }
            (
                differential_overlap_cardinality_matrix,
                left_difference_cardinality_vector,
                right_difference_cardinality_vector,
            )
        }
    }
    /// Trait for sketching algorithms that provide the normalized overlap and differences cardinality matrices.
    pub trait NormalizedHyperSpheresSketch: HyperSpheresSketch<f64> {
        #[inline]
        /// Returns the normalized overlap and differences cardinality matrices of two lists of sets.
        ///
        /// # Arguments
        /// * `left` - The first list of sets.
        /// * `right` - The second list of sets.
        ///
        /// # Returns
        /// * `overlap_cardinality_matrix` - Matrix of normalized estimated overlapping cardinalities between the elements of the left and right arrays.
        /// * `left_difference_cardinality_vector` - Vector of normalized estimated difference cardinalities between the elements of the left array and the last element of the right array.
        /// * `right_difference_cardinality_vector` - Vector of normalized estimated difference cardinalities between the elements of the right array and the last element of the left array.
        fn normalized_overlap_and_differences_cardinality_matrices<
            const L: usize,
            const R: usize,
        >(lefts: &[Self; L], rights: &[Self; R]) -> ([[f64; R]; L], [f64; L], [f64; R]) {
            let mut last_row = [f64::ZERO; R];
            let mut differential_overlap_cardinality_matrix = [[f64::ZERO; R]; L];
            let mut left_difference_cardinality_vector = [f64::ZERO; L];
            let mut right_cardinalities = [f64::ZERO; R];
            rights
                .iter()
                .zip(right_cardinalities.iter_mut())
                .for_each(|(right, right_cardinality)| {
                    *right_cardinality = right.estimate_cardinality();
                });
            if true {
                if !right_cardinalities
                    .iter()
                    .zip(right_cardinalities.iter().skip(1))
                    .all(|(left, right)| left <= right)
                {
                    {
                        ::core::panicking::panic_fmt(
                            format_args!(
                                "The right cardinalities should be sorted in ascending order.",
                            ),
                        );
                    }
                }
            }
            let mut right_difference_cardinality_vector = [f64::ZERO; R];
            let mut euc: EstimatedUnionCardinalities<f64> = EstimatedUnionCardinalities {
                left: f64::ZERO,
                right: f64::ZERO,
                union: f64::ZERO,
            };
            let mut last_left_difference = f64::ZERO;
            let mut last_inner_left_differences = [f64::ZERO; R];
            let mut last_left_cardinality = f64::ZERO;
            for (i, left) in lefts.iter().enumerate() {
                let mut last_right_difference = f64::ZERO;
                let left_cardinality = left.estimate_cardinality();
                let mut comulative_row = f64::ZERO;
                let mut last_right_cardinality = f64::ZERO;
                for (j, (right, (right_cardinality, last_inner_left_difference))) in rights
                    .iter()
                    .zip(
                        right_cardinalities
                            .iter()
                            .copied()
                            .zip(last_inner_left_differences.iter_mut()),
                    )
                    .enumerate()
                {
                    let union_cardinality = left.estimate_union_cardinality(right);
                    euc = EstimatedUnionCardinalities {
                        left: left_cardinality,
                        right: right_cardinality,
                        union: union_cardinality,
                    };
                    let delta = last_row[j] + comulative_row;
                    let differential_intersection = euc
                        .get_intersection_cardinality()
                        .saturating_zero_sub(delta);
                    if true {
                        if !(differential_intersection >= f64::ZERO) {
                            {
                                ::core::panicking::panic_fmt(
                                    format_args!(
                                        "Expected differential_intersection to be larger than zero, but it is not. Got: differential_intersection: {0:?}, delta: {1:?}",
                                        differential_intersection,
                                        delta,
                                    ),
                                );
                            }
                        }
                    }
                    let maximal_differential_intersection_cardinality = (euc
                        .get_left_difference_cardinality() + right_cardinality)
                        .saturating_zero_sub(
                            *last_inner_left_difference + last_right_cardinality,
                        );
                    *last_inner_left_difference = euc.get_left_difference_cardinality();
                    differential_overlap_cardinality_matrix[i][j] = differential_intersection
                        .saturating_one_div(
                            maximal_differential_intersection_cardinality,
                        );
                    last_row[j] = if euc.get_intersection_cardinality() > delta {
                        euc.get_intersection_cardinality()
                    } else {
                        delta
                    };
                    comulative_row += differential_intersection;
                    let differential_right_difference = euc
                        .get_right_difference_cardinality()
                        .saturating_zero_sub(last_right_difference);
                    right_difference_cardinality_vector[j] = differential_right_difference
                        .saturating_one_div(
                            right_cardinality.saturating_zero_sub(last_right_cardinality),
                        );
                    last_right_difference = euc.get_right_difference_cardinality();
                    last_right_cardinality = right_cardinality;
                }
                left_difference_cardinality_vector[i] = euc
                    .get_left_difference_cardinality()
                    .saturating_zero_sub(last_left_difference)
                    .saturating_one_div(
                        left_cardinality.saturating_zero_sub(last_left_cardinality),
                    );
                last_left_cardinality = left_cardinality;
                last_left_difference = euc.get_left_difference_cardinality();
            }
            (
                differential_overlap_cardinality_matrix,
                left_difference_cardinality_vector,
                right_difference_cardinality_vector,
            )
        }
    }
    impl<N: Number, M> HyperSpheresSketch<N> for M
    where
        M: Estimator<N>,
    {}
    impl<M> NormalizedHyperSpheresSketch for M
    where
        M: Estimator<f64>,
    {}
    /// A struct for more readable code.
    struct EstimatedUnionCardinalities<F> {
        /// The estimated cardinality of the left set.
        left: F,
        /// The estimated cardinality of the right set.
        right: F,
        /// The estimated cardinality of the union of the two sets.
        union: F,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<F> _serde::Serialize for EstimatedUnionCardinalities<F>
        where
            F: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = _serde::Serializer::serialize_struct(
                    __serializer,
                    "EstimatedUnionCardinalities",
                    false as usize + 1 + 1 + 1,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "left",
                    &self.left,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "right",
                    &self.right,
                )?;
                _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "union",
                    &self.union,
                )?;
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, F> _serde::Deserialize<'de> for EstimatedUnionCardinalities<F>
        where
            F: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                #[doc(hidden)]
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "left" => _serde::__private::Ok(__Field::__field0),
                            "right" => _serde::__private::Ok(__Field::__field1),
                            "union" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"left" => _serde::__private::Ok(__Field::__field0),
                            b"right" => _serde::__private::Ok(__Field::__field1),
                            b"union" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                #[doc(hidden)]
                struct __Visitor<'de, F>
                where
                    F: _serde::Deserialize<'de>,
                {
                    marker: _serde::__private::PhantomData<
                        EstimatedUnionCardinalities<F>,
                    >,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de, F> _serde::de::Visitor<'de> for __Visitor<'de, F>
                where
                    F: _serde::Deserialize<'de>,
                {
                    type Value = EstimatedUnionCardinalities<F>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct EstimatedUnionCardinalities",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match _serde::de::SeqAccess::next_element::<
                            F,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct EstimatedUnionCardinalities with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match _serde::de::SeqAccess::next_element::<
                            F,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct EstimatedUnionCardinalities with 3 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match _serde::de::SeqAccess::next_element::<
                            F,
                        >(&mut __seq)? {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct EstimatedUnionCardinalities with 3 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(EstimatedUnionCardinalities {
                            left: __field0,
                            right: __field1,
                            union: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<F> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<F> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<F> = _serde::__private::None;
                        while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                            __Field,
                        >(&mut __map)? {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("left"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<F>(&mut __map)?,
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("right"),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<F>(&mut __map)?,
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("union"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        _serde::de::MapAccess::next_value::<F>(&mut __map)?,
                                    );
                                }
                                _ => {
                                    let _ = _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)?;
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("left")?
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("right")?
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                _serde::__private::de::missing_field("union")?
                            }
                        };
                        _serde::__private::Ok(EstimatedUnionCardinalities {
                            left: __field0,
                            right: __field1,
                            union: __field2,
                        })
                    }
                }
                #[doc(hidden)]
                const FIELDS: &'static [&'static str] = &["left", "right", "union"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "EstimatedUnionCardinalities",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<
                            EstimatedUnionCardinalities<F>,
                        >,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl<F> mem_dbg::MemDbgImpl for EstimatedUnionCardinalities<F>
    where
        F: mem_dbg::MemDbgImpl,
        F: mem_dbg::MemDbgImpl,
        F: mem_dbg::MemDbgImpl,
    {
        #[inline(always)]
        fn _mem_dbg_rec_on(
            &self,
            _memdbg_writer: &mut impl core::fmt::Write,
            _memdbg_total_size: usize,
            _memdbg_max_depth: usize,
            _memdbg_prefix: &mut String,
            _memdbg_is_last: bool,
            _memdbg_flags: mem_dbg::DbgFlags,
        ) -> core::fmt::Result {
            let mut id_sizes: Vec<(usize, usize)> = ::alloc::vec::Vec::new();
            id_sizes
                .push((
                    0usize,
                    { builtin # offset_of(EstimatedUnionCardinalities < F >, left) },
                ));
            id_sizes
                .push((
                    1usize,
                    { builtin # offset_of(EstimatedUnionCardinalities < F >, right) },
                ));
            id_sizes
                .push((
                    2usize,
                    { builtin # offset_of(EstimatedUnionCardinalities < F >, union) },
                ));
            let n = id_sizes.len();
            id_sizes.push((n, core::mem::size_of::<Self>()));
            id_sizes.sort_by_key(|x| x.1);
            for i in 0..n {
                id_sizes[i].1 = id_sizes[i + 1].1 - id_sizes[i].1;
            }
            if !_memdbg_flags.contains(mem_dbg::DbgFlags::RUST_LAYOUT) {
                id_sizes.sort_by_key(|x| x.0);
            }
            for (i, (field_idx, padded_size)) in id_sizes.into_iter().enumerate().take(n)
            {
                match field_idx {
                    0usize => {
                        <F as mem_dbg::MemDbgImpl>::_mem_dbg_depth_on(
                            &self.left,
                            _memdbg_writer,
                            _memdbg_total_size,
                            _memdbg_max_depth,
                            _memdbg_prefix,
                            Some("left"),
                            i == n - 1,
                            padded_size,
                            _memdbg_flags,
                        )?
                    }
                    1usize => {
                        <F as mem_dbg::MemDbgImpl>::_mem_dbg_depth_on(
                            &self.right,
                            _memdbg_writer,
                            _memdbg_total_size,
                            _memdbg_max_depth,
                            _memdbg_prefix,
                            Some("right"),
                            i == n - 1,
                            padded_size,
                            _memdbg_flags,
                        )?
                    }
                    2usize => {
                        <F as mem_dbg::MemDbgImpl>::_mem_dbg_depth_on(
                            &self.union,
                            _memdbg_writer,
                            _memdbg_total_size,
                            _memdbg_max_depth,
                            _memdbg_prefix,
                            Some("union"),
                            i == n - 1,
                            padded_size,
                            _memdbg_flags,
                        )?
                    }
                    _ => {
                        ::core::panicking::panic(
                            "internal error: entered unreachable code",
                        )
                    }
                }
            }
            Ok(())
        }
    }
    #[automatically_derived]
    impl<F> mem_dbg::CopyType for EstimatedUnionCardinalities<F>
    where
        F: mem_dbg::MemSize,
        F: mem_dbg::MemSize,
        F: mem_dbg::MemSize,
    {
        type Copy = mem_dbg::False;
    }
    #[automatically_derived]
    impl<F> mem_dbg::MemSize for EstimatedUnionCardinalities<F>
    where
        F: mem_dbg::MemSize,
        F: mem_dbg::MemSize,
        F: mem_dbg::MemSize,
    {
        fn mem_size(&self, _memsize_flags: mem_dbg::SizeFlags) -> usize {
            let mut bytes = core::mem::size_of::<Self>();
            bytes
                += <F as mem_dbg::MemSize>::mem_size(&self.left, _memsize_flags)
                    - core::mem::size_of::<F>();
            bytes
                += <F as mem_dbg::MemSize>::mem_size(&self.right, _memsize_flags)
                    - core::mem::size_of::<F>();
            bytes
                += <F as mem_dbg::MemSize>::mem_size(&self.union, _memsize_flags)
                    - core::mem::size_of::<F>();
            bytes
        }
    }
    #[automatically_derived]
    impl<F: ::core::clone::Clone> ::core::clone::Clone
    for EstimatedUnionCardinalities<F> {
        #[inline]
        fn clone(&self) -> EstimatedUnionCardinalities<F> {
            EstimatedUnionCardinalities {
                left: ::core::clone::Clone::clone(&self.left),
                right: ::core::clone::Clone::clone(&self.right),
                union: ::core::clone::Clone::clone(&self.union),
            }
        }
    }
    #[automatically_derived]
    impl<F: ::core::marker::Copy> ::core::marker::Copy
    for EstimatedUnionCardinalities<F> {}
    #[automatically_derived]
    impl<F: ::core::fmt::Debug> ::core::fmt::Debug for EstimatedUnionCardinalities<F> {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field3_finish(
                f,
                "EstimatedUnionCardinalities",
                "left",
                &self.left,
                "right",
                &self.right,
                "union",
                &&self.union,
            )
        }
    }
    #[automatically_derived]
    impl<F> ::core::marker::StructuralPartialEq for EstimatedUnionCardinalities<F> {}
    #[automatically_derived]
    impl<F: ::core::cmp::PartialEq> ::core::cmp::PartialEq
    for EstimatedUnionCardinalities<F> {
        #[inline]
        fn eq(&self, other: &EstimatedUnionCardinalities<F>) -> bool {
            self.left == other.left && self.right == other.right
                && self.union == other.union
        }
    }
    impl<F: Number> EstimatedUnionCardinalities<F> {
        /// Returns the estimated cardinality of the intersection of the two sets.
        fn get_intersection_cardinality(&self) -> F {
            self.left + self.right - self.union
        }
        /// Returns the estimated cardinality of the left set minus the right set.
        fn get_left_difference_cardinality(&self) -> F {
            self.union - self.right
        }
        /// Returns the estimated cardinality of the right set minus the left set.
        fn get_right_difference_cardinality(&self) -> F {
            self.union - self.left
        }
    }
}
mod utils {
    //! # Utils
    //!
    //! This module provides utility functions used by the [`HyperLogLog`] algorithm implementation.
    //!
    //! The functions provided are:
    //!
    //! - `ceil(numerator: usize, denominator: usize) -> usize`: Calculates the integer ceil of the division
    //!   of `numerator` by `denominator`.
    //!
    //! - `word_from_registers<const NUMBER_OF_BITS_PER_REGISTER: usize>(registers: &[u32]) -> u32`: Converts an array
    //!   of HLL registers into a single 32-bit word.
    mod constants {
        //! Constants for common values.
        /// The zero value for this type.
        pub trait Zero {
            /// The zero value for this type.
            const ZERO: Self;
            /// Whether the value is zero.
            fn is_zero(&self) -> bool;
        }
        /// The one value for this type.
        pub trait One {
            /// The one value for this type.
            const ONE: Self;
            /// Whether the value is one.
            fn is_one(&self) -> bool;
        }
        #[cfg(feature = "plusplus")]
        /// The two value for this type.
        pub(crate) trait Two {
            /// The two value for this type.
            const TWO: Self;
        }
        impl One for u8 {
            const ONE: Self = 1;
            #[inline(always)]
            fn is_one(&self) -> bool {
                *self == 1
            }
        }
        impl Zero for u8 {
            const ZERO: Self = 0;
            #[inline(always)]
            fn is_zero(&self) -> bool {
                *self == 0
            }
        }
        #[cfg(feature = "plusplus")]
        impl Two for u8 {
            const TWO: Self = 2;
        }
        impl One for u16 {
            const ONE: Self = 1;
            #[inline(always)]
            fn is_one(&self) -> bool {
                *self == 1
            }
        }
        impl Zero for u16 {
            const ZERO: Self = 0;
            #[inline(always)]
            fn is_zero(&self) -> bool {
                *self == 0
            }
        }
        #[cfg(feature = "plusplus")]
        impl Two for u16 {
            const TWO: Self = 2;
        }
        impl One for u32 {
            const ONE: Self = 1;
            #[inline(always)]
            fn is_one(&self) -> bool {
                *self == 1
            }
        }
        impl Zero for u32 {
            const ZERO: Self = 0;
            #[inline(always)]
            fn is_zero(&self) -> bool {
                *self == 0
            }
        }
        #[cfg(feature = "plusplus")]
        impl Two for u32 {
            const TWO: Self = 2;
        }
        impl One for u64 {
            const ONE: Self = 1;
            #[inline(always)]
            fn is_one(&self) -> bool {
                *self == 1
            }
        }
        impl Zero for u64 {
            const ZERO: Self = 0;
            #[inline(always)]
            fn is_zero(&self) -> bool {
                *self == 0
            }
        }
        #[cfg(feature = "plusplus")]
        impl Two for u64 {
            const TWO: Self = 2;
        }
        impl One for usize {
            const ONE: Self = 1;
            #[inline(always)]
            fn is_one(&self) -> bool {
                *self == 1
            }
        }
        impl Zero for usize {
            const ZERO: Self = 0;
            #[inline(always)]
            fn is_zero(&self) -> bool {
                *self == 0
            }
        }
        #[cfg(feature = "plusplus")]
        impl Two for usize {
            const TWO: Self = 2;
        }
        impl One for i32 {
            const ONE: Self = 1;
            #[inline(always)]
            fn is_one(&self) -> bool {
                *self == 1
            }
        }
        impl Zero for i32 {
            const ZERO: Self = 0;
            #[inline(always)]
            fn is_zero(&self) -> bool {
                *self == 0
            }
        }
        #[cfg(feature = "plusplus")]
        impl Two for i32 {
            const TWO: Self = 2;
        }
        impl One for f64 {
            const ONE: Self = 1.0;
            #[inline]
            fn is_one(&self) -> bool {
                (*self - 1.0).abs() < Self::EPSILON
            }
        }
        impl Zero for f64 {
            const ZERO: Self = 0.0;
            #[inline]
            fn is_zero(&self) -> bool {
                *self == 0.0
            }
        }
        #[cfg(feature = "plusplus")]
        impl Two for f64 {
            const TWO: Self = 2.0;
        }
    }
    mod hasher_type {
        //! Trait for Hashers that can be deaulted and shared among threads.
        use core::hash::Hasher;
        /// Trait for Hashers that can be deaulted and shared among threads.
        pub trait HasherType: Default + Hasher + Send + Sync + Clone {}
        impl<T> HasherType for T
        where
            T: Default + Hasher + Send + Sync + Clone,
        {}
    }
    mod number {
        //! Traits regarding numbers.
        use crate::utils::{One, Zero};
        use core::fmt::{Debug, Display};
        use core::ops::{Add, AddAssign, Div, Mul, Neg, Shl, Shr, Sub, SubAssign};
        /// A trait for numbers.
        pub trait Number: Copy + Add<
                Self,
                Output = Self,
            > + Sub<
                Self,
                Output = Self,
            > + Div<
                Self,
                Output = Self,
            > + Mul<
                Self,
                Output = Self,
            > + AddAssign + SubAssign + Debug + Display + Zero + One + PartialOrd + Send + Sync {
            #[must_use]
            /// A method to subtract the second number from the first number, returning zero if the result is negative.
            fn saturating_zero_sub(self, other: Self) -> Self;
            #[must_use]
            #[inline]
            /// Converts a boolean value to a number.
            fn from_bool(value: bool) -> Self {
                if value { Self::ONE } else { Self::ZERO }
            }
        }
        /// A trait for positive integer numbers.
        pub trait PositiveInteger: Number + Eq + Into<
                u64,
            > + Ord + Shl<u8, Output = Self> + Shr<u8, Output = Self> {
            /// The error type for the `try_from_u64` method.
            type TryFromU64Error: Debug;
            /// Converts a `u64` to a positive integer number.
            ///
            /// # Errors
            /// * If the value is too large to be converted to a positive integer number.
            fn try_from_u64(value: u64) -> Result<Self, Self::TryFromU64Error>;
            /// Converts the positive integer number to a `usize`.
            fn to_usize(self) -> usize;
        }
        /// A trait for floating point numbers.
        pub(crate) trait FloatOps: Number + Neg<Output = Self> {
            /// Returns the value of 2^(-register), with strict positivite register.
            fn integer_exp2_minus(register: u8) -> Self;
            /// Returns the value of 2^(-register), including negative registers.
            fn integer_exp2_minus_signed(register: i8) -> Self;
            /// Returns the value of 2^(register)
            fn integer_exp2(register: u8) -> Self;
            #[must_use]
            #[inline]
            /// Computes the saturating division of two numbers that are expected to be positive.
            /// and at most equal to one.
            fn saturating_one_div(self, other: Self) -> Self {
                if true {
                    if !(self >= Self::ZERO) {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!("The dividend must be positive."),
                            );
                        }
                    }
                }
                if true {
                    if !(other >= Self::ZERO) {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!("The divisor must be positive."),
                            );
                        }
                    }
                }
                if self >= other { Self::ONE } else { self / other }
            }
        }
        impl Number for u8 {
            #[inline(always)]
            fn saturating_zero_sub(self, other: Self) -> Self {
                if true {
                    if !(self >= Self::ZERO) {
                        ::core::panicking::panic("assertion failed: self >= Self::ZERO")
                    }
                }
                if true {
                    if !(other >= Self::ZERO) {
                        ::core::panicking::panic("assertion failed: other >= Self::ZERO")
                    }
                }
                if self < other { Self::ZERO } else { self - other }
            }
        }
        impl Number for u16 {
            #[inline(always)]
            fn saturating_zero_sub(self, other: Self) -> Self {
                if true {
                    if !(self >= Self::ZERO) {
                        ::core::panicking::panic("assertion failed: self >= Self::ZERO")
                    }
                }
                if true {
                    if !(other >= Self::ZERO) {
                        ::core::panicking::panic("assertion failed: other >= Self::ZERO")
                    }
                }
                if self < other { Self::ZERO } else { self - other }
            }
        }
        impl Number for u32 {
            #[inline(always)]
            fn saturating_zero_sub(self, other: Self) -> Self {
                if true {
                    if !(self >= Self::ZERO) {
                        ::core::panicking::panic("assertion failed: self >= Self::ZERO")
                    }
                }
                if true {
                    if !(other >= Self::ZERO) {
                        ::core::panicking::panic("assertion failed: other >= Self::ZERO")
                    }
                }
                if self < other { Self::ZERO } else { self - other }
            }
        }
        impl Number for u64 {
            #[inline(always)]
            fn saturating_zero_sub(self, other: Self) -> Self {
                if true {
                    if !(self >= Self::ZERO) {
                        ::core::panicking::panic("assertion failed: self >= Self::ZERO")
                    }
                }
                if true {
                    if !(other >= Self::ZERO) {
                        ::core::panicking::panic("assertion failed: other >= Self::ZERO")
                    }
                }
                if self < other { Self::ZERO } else { self - other }
            }
        }
        impl Number for usize {
            #[inline(always)]
            fn saturating_zero_sub(self, other: Self) -> Self {
                if true {
                    if !(self >= Self::ZERO) {
                        ::core::panicking::panic("assertion failed: self >= Self::ZERO")
                    }
                }
                if true {
                    if !(other >= Self::ZERO) {
                        ::core::panicking::panic("assertion failed: other >= Self::ZERO")
                    }
                }
                if self < other { Self::ZERO } else { self - other }
            }
        }
        impl Number for i32 {
            #[inline(always)]
            fn saturating_zero_sub(self, other: Self) -> Self {
                if true {
                    if !(self >= Self::ZERO) {
                        ::core::panicking::panic("assertion failed: self >= Self::ZERO")
                    }
                }
                if true {
                    if !(other >= Self::ZERO) {
                        ::core::panicking::panic("assertion failed: other >= Self::ZERO")
                    }
                }
                if self < other { Self::ZERO } else { self - other }
            }
        }
        impl Number for f64 {
            #[inline(always)]
            fn saturating_zero_sub(self, other: Self) -> Self {
                if true {
                    if !(self >= Self::ZERO) {
                        ::core::panicking::panic("assertion failed: self >= Self::ZERO")
                    }
                }
                if true {
                    if !(other >= Self::ZERO) {
                        ::core::panicking::panic("assertion failed: other >= Self::ZERO")
                    }
                }
                if self < other { Self::ZERO } else { self - other }
            }
        }
        impl PositiveInteger for u8 {
            type TryFromU64Error = <u8 as core::convert::TryFrom<u64>>::Error;
            #[inline(always)]
            fn try_from_u64(value: u64) -> Result<Self, Self::TryFromU64Error> {
                <u8 as core::convert::TryFrom<u64>>::try_from(value)
            }
            #[inline(always)]
            #[must_use]
            fn to_usize(self) -> usize {
                usize::try_from(self).unwrap()
            }
        }
        impl PositiveInteger for u16 {
            type TryFromU64Error = <u16 as core::convert::TryFrom<u64>>::Error;
            #[inline(always)]
            fn try_from_u64(value: u64) -> Result<Self, Self::TryFromU64Error> {
                <u16 as core::convert::TryFrom<u64>>::try_from(value)
            }
            #[inline(always)]
            #[must_use]
            fn to_usize(self) -> usize {
                usize::try_from(self).unwrap()
            }
        }
        impl PositiveInteger for u32 {
            type TryFromU64Error = <u32 as core::convert::TryFrom<u64>>::Error;
            #[inline(always)]
            fn try_from_u64(value: u64) -> Result<Self, Self::TryFromU64Error> {
                <u32 as core::convert::TryFrom<u64>>::try_from(value)
            }
            #[inline(always)]
            #[must_use]
            fn to_usize(self) -> usize {
                usize::try_from(self).unwrap()
            }
        }
        impl FloatOps for f64 {
            #[must_use]
            #[inline]
            fn integer_exp2_minus(register: u8) -> Self {
                f64::from_le_bytes(
                    (u64::from(1023_u16 - u16::from(register)) << 52).to_le_bytes(),
                )
            }
            #[must_use]
            #[inline]
            fn integer_exp2_minus_signed(register: i8) -> Self {
                f64::from_le_bytes(
                    (u64::try_from(1023_i16 - i16::from(register)).unwrap() << 52)
                        .to_le_bytes(),
                )
            }
            #[must_use]
            #[inline]
            fn integer_exp2(register: u8) -> Self {
                f64::from_le_bytes(
                    (u64::from(1023_u16 + u16::from(register)) << 52).to_le_bytes(),
                )
            }
        }
    }
    mod random {
        //! Random number generators.
        #[must_use]
        #[inline]
        /// `SplitMix64` is a pseudorandom number generator that is very fast and has a good quality of randomness.
        pub fn splitmix64(mut x: u64) -> u64 {
            x = x.wrapping_add(0x9E37_79B9_7F4A_7C15);
            x = (x ^ (x >> 30)).wrapping_mul(0xBF58_476D_1CE4_E5B9);
            x = (x ^ (x >> 27)).wrapping_mul(0x94D0_49BB_1331_11EB);
            x ^ (x >> 31)
        }
        /// `Xorshift64` is a pseudorandom number generator that is very fast and has a good quality of randomness.
        #[must_use]
        #[inline]
        pub fn xorshift64(mut x: u64) -> u64 {
            x ^= x << 13_u8;
            x ^= x >> 7_u8;
            x ^= x << 17_u8;
            x
        }
        #[inline]
        /// Returns an iterator over random values.
        ///
        /// # Arguments
        /// * `maximal_size` - The maximal size of the iterator.
        /// * `maximal_value` - The maximal value of the iterator.
        /// * `random_state` - The random state.
        ///
        /// # Panics
        /// Panics if the maximal size is greater than `u64::MAX`.
        pub fn iter_random_values(
            maximal_size: usize,
            maximal_value: Option<u64>,
            mut random_state: u64,
        ) -> impl Iterator<Item = u64> {
            random_state = splitmix64(splitmix64(random_state));
            let actual_maximal_size = if maximal_size > 0 {
                random_state % u64::try_from(maximal_size).unwrap()
            } else {
                0
            };
            random_state = splitmix64(splitmix64(random_state));
            let actual_maximal_value = maximal_value
                .map_or(u64::MAX, |mv| xorshift64(random_state) % mv);
            (0..actual_maximal_size)
                .map(move |_| {
                    random_state = splitmix64(splitmix64(random_state));
                    random_state = xorshift64(random_state);
                    if actual_maximal_value > 0 {
                        random_state % actual_maximal_value
                    } else {
                        0
                    }
                })
        }
    }
    mod words {
        //! Submodule for words-arrays
        use core::iter::Copied;
        use core::slice::Iter;
        /// Trait for arrays of words.
        pub trait Words {
            /// The type of the iterator over the words.
            type WordIter<'words>: Iterator<Item = u64> where Self: 'words;
            /// Returns the number of words in the array, i.e., the length of the array.
            fn number_of_words(&self) -> usize;
            /// Searches a value in the array and returns `true` if the value is found.
            fn find_sorted_with_len(&self, value: u64, len: usize) -> bool;
            /// Inserts a value into the array searching for the correct position within a given length.
            fn sorted_insert_with_len(&mut self, value: u64, len: usize) -> bool;
            /// Returns an iterator over the words.
            fn words(&self) -> Self::WordIter<'_>;
        }
        impl<const N: usize> Words for [u64; N] {
            type WordIter<'words> = Copied<Iter<'words, u64>> where Self: 'words;
            #[must_use]
            #[inline]
            fn number_of_words(&self) -> usize {
                N
            }
            #[must_use]
            #[inline]
            fn find_sorted_with_len(&self, value: u64, len: usize) -> bool {
                if true {
                    if !(len <= N) {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "The length must be less than or equal to the number of words.",
                                ),
                            );
                        }
                    }
                }
                if true {
                    if !self[..len].windows(2).all(|w| w[0] <= w[1]) {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!("The array must be sorted."),
                            );
                        }
                    }
                }
                self[..len].binary_search(&value).is_ok()
            }
            #[must_use]
            #[inline]
            fn sorted_insert_with_len(&mut self, value: u64, len: usize) -> bool {
                if true {
                    if !(len <= N) {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!(
                                    "The length must be less than or equal to the number of words.",
                                ),
                            );
                        }
                    }
                }
                if true {
                    if !self[..len].windows(2).all(|w| w[0] <= w[1]) {
                        {
                            ::core::panicking::panic_fmt(
                                format_args!("The array must be sorted."),
                            );
                        }
                    }
                }
                match self[..len].binary_search(&value) {
                    Ok(_) => false,
                    Err(index) => {
                        self.copy_within(index..len, index + 1);
                        self[index] = value;
                        true
                    }
                }
            }
            #[must_use]
            #[inline]
            fn words(&self) -> Self::WordIter<'_> {
                self.iter().copied()
            }
        }
    }
    pub use constants::*;
    pub use hasher_type::HasherType;
    pub(crate) use number::{FloatOps, Number, PositiveInteger};
    pub use random::*;
    pub use words::Words;
    #[cfg(feature = "std")]
    /// Trait for an object with a name.
    pub trait Named {
        /// Returns the name of the object.
        fn name(&self) -> String;
    }
    #[inline]
    /// Calculates the integer ceil of the division of `numerator` by `denominator`.
    ///
    /// # Arguments
    /// * `numerator` - The numerator of the division.
    /// * `denominator` - The denominator of the division.
    pub(crate) const fn ceil(numerator: usize, denominator: usize) -> usize {
        (numerator + denominator - 1) / denominator
    }
    #[inline]
    /// Returns the maximal multiplicity of the registers given the precision and the number of bits.
    pub(crate) const fn maximal_multeplicity(precision: u8, bits: u8) -> u8 {
        if true {
            if !(precision >= 4) {
                {
                    ::core::panicking::panic_fmt(
                        format_args!("The precision must be greater than or equal to 4."),
                    );
                }
            }
        }
        if true {
            if !(precision <= 18) {
                {
                    ::core::panicking::panic_fmt(
                        format_args!("The precision must be less than or equal to 16."),
                    );
                }
            }
        }
        if bits < 6 { 1 << bits } else { 64 - precision }
    }
    #[inline]
    /// Applies a correction to the provided union cardinality estimate.
    pub(crate) fn correct_union_estimate(
        left_cardinality: f64,
        right_cardinality: f64,
        union_cardinality: f64,
    ) -> f64 {
        union_cardinality
            .min(right_cardinality + left_cardinality)
            .max(right_cardinality.max(left_cardinality))
    }
}
#[cfg(feature = "serde")]
pub mod serde {
    //! Module to handle serialization and deserialization of the registers
    use core::any::type_name;
    use core::fmt::Formatter;
    use core::marker::PhantomData;
    use serde::de::SeqAccess;
    use serde::de::Visitor;
    /// Struct to deserialize a vector of T
    pub(crate) struct RegisterVisitor<T> {
        /// The expected length of the vector
        expected_length: usize,
        /// Phantom data to keep the type
        _phantom: PhantomData<T>,
    }
    impl<T> RegisterVisitor<T> {
        /// Creates a new [`RegisterVisitor`]
        pub(crate) fn new(expected_length: usize) -> Self {
            Self {
                expected_length,
                _phantom: PhantomData,
            }
        }
    }
    impl<'de, T: Default + Copy + serde::Deserialize<'de>> Visitor<'de>
    for RegisterVisitor<T> {
        type Value = Vec<T>;
        fn expecting(&self, formatter: &mut Formatter) -> core::fmt::Result {
            formatter
                .write_str(
                    &::alloc::__export::must_use({
                        let res = ::alloc::fmt::format(
                            format_args!(
                                "an array of {0} {1} elements",
                                self.expected_length,
                                type_name::<T>(),
                            ),
                        );
                        res
                    }),
                )
        }
        fn visit_seq<A: SeqAccess<'de>>(
            self,
            mut seq: A,
        ) -> Result<Self::Value, A::Error> {
            let mut array = ::alloc::vec::from_elem(T::default(), self.expected_length);
            {
                let mut array_iter = array.iter_mut();
                while let Some(value) = seq.next_element()? {
                    if let Some(target) = array_iter.next() {
                        *target = value;
                    } else {
                        return Err(serde::de::Error::invalid_length(array.len(), &self));
                    }
                }
            }
            Ok(array)
        }
    }
}
#[cfg(feature = "std")]
mod hashset {
    //! Submodule providing the implementation of `HyperSphere` sketches for `HashSets`.
    use crate::prelude::*;
    use core::hash::BuildHasher;
    use core::hash::Hash;
    use std::collections::HashSet;
    impl<I, S: Default + Send + Sync + BuildHasher> Named for HashSet<I, S>
    where
        I: Eq + Hash,
    {
        #[inline]
        fn name(&self) -> String {
            "HashSet".to_owned()
        }
    }
    /// Implementation of the `Estimator` trait for `HashSet`.
    impl<I, S: Default + Send + Sync + BuildHasher> Estimator<f64> for HashSet<I, S>
    where
        I: Eq + Hash + Send + Sync,
    {
        #[inline]
        #[expect(
            clippy::cast_precision_loss,
            reason = "This is an adapter trait for tests."
        )]
        #[expect(clippy::as_conversions, reason = "There are no better options.")]
        fn estimate_union_cardinality(&self, other: &Self) -> f64 {
            self.union(other).count() as f64
        }
        #[inline]
        #[expect(
            clippy::cast_precision_loss,
            reason = "This is an adapter trait for tests."
        )]
        #[expect(clippy::as_conversions, reason = "There are no better options.")]
        fn estimate_cardinality(&self) -> f64 {
            self.len() as f64
        }
        #[inline]
        fn is_union_estimate_non_deterministic(&self, _other: &Self) -> bool {
            false
        }
    }
    impl<I, S: Default + Send + Sync + BuildHasher> Estimator<usize> for HashSet<I, S>
    where
        I: Eq + Hash + Send + Sync,
    {
        #[inline]
        fn estimate_union_cardinality(&self, other: &Self) -> usize {
            self.union(other).count()
        }
        #[inline]
        fn estimate_cardinality(&self) -> usize {
            self.len()
        }
        #[inline]
        fn is_union_estimate_non_deterministic(&self, _other: &Self) -> bool {
            false
        }
    }
    impl<T, S: Default + Send + Sync + BuildHasher> SetProperties for HashSet<T, S> {
        #[inline]
        fn is_empty(&self) -> bool {
            self.is_empty()
        }
        #[inline]
        fn is_full(&self) -> bool {
            false
        }
    }
    impl<T, S: Default + Send + Sync + BuildHasher> MutableSet for HashSet<T, S> {
        #[inline]
        fn clear(&mut self) {
            self.clear();
        }
    }
    impl<T, S: Default + Send + Sync + BuildHasher> ApproximatedSet<T> for HashSet<T, S>
    where
        T: Hash + Eq,
    {
        #[inline]
        fn may_contain(&self, element: &T) -> bool {
            self.contains(element)
        }
    }
    impl<T, S: Default + Send + Sync + BuildHasher> ExtendableApproximatedSet<T>
    for HashSet<T, S>
    where
        T: Hash + Eq + Clone,
    {
        #[inline]
        fn insert(&mut self, element: &T) -> bool {
            self.insert(element.clone())
        }
    }
}
/// Re-exports of the most important traits and structs.
pub mod prelude {
    pub use crate::bits::*;
    pub use crate::estimator::*;
    pub use crate::hybrid::*;
    pub use crate::hyperloglog::*;
    #[cfg(feature = "beta")]
    pub use crate::loglogbeta::*;
    #[cfg(feature = "mle")]
    pub use crate::mle::*;
    #[cfg(feature = "plusplus")]
    pub use crate::plusplus::*;
    pub use crate::precisions::*;
    pub use crate::registers::*;
    pub use crate::sketches::*;
    pub use crate::utils::*;
    pub use core::ops::{BitOr, BitOrAssign};
}
